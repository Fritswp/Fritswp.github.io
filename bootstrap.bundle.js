/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/assets/js/bootstrap.bundle.js":
/*!*******************************************!*\
  !*** ./src/assets/js/bootstrap.bundle.js ***!
  \*******************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;function _get() { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, \"prototype\", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\n/*!\n  * Bootstrap v5.0.2 (https://getbootstrap.com/)\n  * Copyright 2011-2021 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)\n  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n  */\n(function (global, factory) {\n  ( false ? 0 : _typeof(exports)) === 'object' && \"object\" !== 'undefined' ? module.exports = factory() :  true ? !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : (0);\n})(this, function () {\n  'use strict';\n\n  /**\n   * --------------------------------------------------------------------------\n   * Bootstrap (v5.0.2): dom/selector-engine.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */\n\n  /**\n   * ------------------------------------------------------------------------\n   * Constants\n   * ------------------------------------------------------------------------\n   */\n  var _KEY_TO_DIRECTION;\n  var NODE_TEXT = 3;\n  var SelectorEngine = {\n    find: function find(selector) {\n      var _ref5;\n      var element = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : document.documentElement;\n      return (_ref5 = []).concat.apply(_ref5, _toConsumableArray(Element.prototype.querySelectorAll.call(element, selector)));\n    },\n    findOne: function findOne(selector) {\n      var element = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : document.documentElement;\n      return Element.prototype.querySelector.call(element, selector);\n    },\n    children: function children(element, selector) {\n      var _ref6;\n      return (_ref6 = []).concat.apply(_ref6, _toConsumableArray(element.children)).filter(function (child) {\n        return child.matches(selector);\n      });\n    },\n    parents: function parents(element, selector) {\n      var parents = [];\n      var ancestor = element.parentNode;\n      while (ancestor && ancestor.nodeType === Node.ELEMENT_NODE && ancestor.nodeType !== NODE_TEXT) {\n        if (ancestor.matches(selector)) {\n          parents.push(ancestor);\n        }\n        ancestor = ancestor.parentNode;\n      }\n      return parents;\n    },\n    prev: function prev(element, selector) {\n      var previous = element.previousElementSibling;\n      while (previous) {\n        if (previous.matches(selector)) {\n          return [previous];\n        }\n        previous = previous.previousElementSibling;\n      }\n      return [];\n    },\n    next: function next(element, selector) {\n      var next = element.nextElementSibling;\n      while (next) {\n        if (next.matches(selector)) {\n          return [next];\n        }\n        next = next.nextElementSibling;\n      }\n      return [];\n    }\n  };\n\n  /**\n   * --------------------------------------------------------------------------\n   * Bootstrap (v5.0.2): util/index.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */\n\n  var MAX_UID = 1000000;\n  var MILLISECONDS_MULTIPLIER = 1000;\n  var TRANSITION_END = 'transitionend'; // Shoutout AngusCroll (https://goo.gl/pxwQGp)\n\n  var toType = function toType(obj) {\n    if (obj === null || obj === undefined) {\n      return \"\".concat(obj);\n    }\n    return {}.toString.call(obj).match(/\\s([a-z]+)/i)[1].toLowerCase();\n  };\n  /**\n   * --------------------------------------------------------------------------\n   * Public Util Api\n   * --------------------------------------------------------------------------\n   */\n\n  var getUID = function getUID(prefix) {\n    do {\n      prefix += Math.floor(Math.random() * MAX_UID);\n    } while (document.getElementById(prefix));\n    return prefix;\n  };\n  var getSelector = function getSelector(element) {\n    var selector = element.getAttribute('data-bs-target');\n    if (!selector || selector === '#') {\n      var hrefAttr = element.getAttribute('href'); // The only valid content that could double as a selector are IDs or classes,\n      // so everything starting with `#` or `.`. If a \"real\" URL is used as the selector,\n      // `document.querySelector` will rightfully complain it is invalid.\n      // See https://github.com/twbs/bootstrap/issues/32273\n\n      if (!hrefAttr || !hrefAttr.includes('#') && !hrefAttr.startsWith('.')) {\n        return null;\n      } // Just in case some CMS puts out a full URL with the anchor appended\n\n      if (hrefAttr.includes('#') && !hrefAttr.startsWith('#')) {\n        hrefAttr = \"#\".concat(hrefAttr.split('#')[1]);\n      }\n      selector = hrefAttr && hrefAttr !== '#' ? hrefAttr.trim() : null;\n    }\n    return selector;\n  };\n  var getSelectorFromElement = function getSelectorFromElement(element) {\n    var selector = getSelector(element);\n    if (selector) {\n      return document.querySelector(selector) ? selector : null;\n    }\n    return null;\n  };\n  var getElementFromSelector = function getElementFromSelector(element) {\n    var selector = getSelector(element);\n    return selector ? document.querySelector(selector) : null;\n  };\n  var getTransitionDurationFromElement = function getTransitionDurationFromElement(element) {\n    if (!element) {\n      return 0;\n    } // Get transition-duration of the element\n\n    var _window$getComputedSt = window.getComputedStyle(element),\n      transitionDuration = _window$getComputedSt.transitionDuration,\n      transitionDelay = _window$getComputedSt.transitionDelay;\n    var floatTransitionDuration = Number.parseFloat(transitionDuration);\n    var floatTransitionDelay = Number.parseFloat(transitionDelay); // Return 0 if element or transition duration is not found\n\n    if (!floatTransitionDuration && !floatTransitionDelay) {\n      return 0;\n    } // If multiple durations are defined, take the first\n\n    transitionDuration = transitionDuration.split(',')[0];\n    transitionDelay = transitionDelay.split(',')[0];\n    return (Number.parseFloat(transitionDuration) + Number.parseFloat(transitionDelay)) * MILLISECONDS_MULTIPLIER;\n  };\n  var triggerTransitionEnd = function triggerTransitionEnd(element) {\n    element.dispatchEvent(new Event(TRANSITION_END));\n  };\n  var isElement$1 = function isElement$1(obj) {\n    if (!obj || _typeof(obj) !== 'object') {\n      return false;\n    }\n    if (typeof obj.jquery !== 'undefined') {\n      obj = obj[0];\n    }\n    return typeof obj.nodeType !== 'undefined';\n  };\n  var getElement = function getElement(obj) {\n    if (isElement$1(obj)) {\n      // it's a jQuery object or a node element\n      return obj.jquery ? obj[0] : obj;\n    }\n    if (typeof obj === 'string' && obj.length > 0) {\n      return SelectorEngine.findOne(obj);\n    }\n    return null;\n  };\n  var typeCheckConfig = function typeCheckConfig(componentName, config, configTypes) {\n    Object.keys(configTypes).forEach(function (property) {\n      var expectedTypes = configTypes[property];\n      var value = config[property];\n      var valueType = value && isElement$1(value) ? 'element' : toType(value);\n      if (!new RegExp(expectedTypes).test(valueType)) {\n        throw new TypeError(\"\".concat(componentName.toUpperCase(), \": Option \\\"\").concat(property, \"\\\" provided type \\\"\").concat(valueType, \"\\\" but expected type \\\"\").concat(expectedTypes, \"\\\".\"));\n      }\n    });\n  };\n  var isVisible = function isVisible(element) {\n    if (!isElement$1(element) || element.getClientRects().length === 0) {\n      return false;\n    }\n    return getComputedStyle(element).getPropertyValue('visibility') === 'visible';\n  };\n  var isDisabled = function isDisabled(element) {\n    if (!element || element.nodeType !== Node.ELEMENT_NODE) {\n      return true;\n    }\n    if (element.classList.contains('disabled')) {\n      return true;\n    }\n    if (typeof element.disabled !== 'undefined') {\n      return element.disabled;\n    }\n    return element.hasAttribute('disabled') && element.getAttribute('disabled') !== 'false';\n  };\n  var findShadowRoot = function findShadowRoot(element) {\n    if (!document.documentElement.attachShadow) {\n      return null;\n    } // Can find the shadow root otherwise it'll return the document\n\n    if (typeof element.getRootNode === 'function') {\n      var root = element.getRootNode();\n      return root instanceof ShadowRoot ? root : null;\n    }\n    if (element instanceof ShadowRoot) {\n      return element;\n    } // when we don't find a shadow root\n\n    if (!element.parentNode) {\n      return null;\n    }\n    return findShadowRoot(element.parentNode);\n  };\n  var noop = function noop() {};\n  var reflow = function reflow(element) {\n    return element.offsetHeight;\n  };\n  var getjQuery = function getjQuery() {\n    var _window = window,\n      jQuery = _window.jQuery;\n    if (jQuery && !document.body.hasAttribute('data-bs-no-jquery')) {\n      return jQuery;\n    }\n    return null;\n  };\n  var DOMContentLoadedCallbacks = [];\n  var onDOMContentLoaded = function onDOMContentLoaded(callback) {\n    if (document.readyState === 'loading') {\n      // add listener on the first call when the document is in loading state\n      if (!DOMContentLoadedCallbacks.length) {\n        document.addEventListener('DOMContentLoaded', function () {\n          DOMContentLoadedCallbacks.forEach(function (callback) {\n            return callback();\n          });\n        });\n      }\n      DOMContentLoadedCallbacks.push(callback);\n    } else {\n      callback();\n    }\n  };\n  var isRTL = function isRTL() {\n    return document.documentElement.dir === 'rtl';\n  };\n  var defineJQueryPlugin = function defineJQueryPlugin(plugin) {\n    onDOMContentLoaded(function () {\n      var $ = getjQuery();\n      /* istanbul ignore if */\n\n      if ($) {\n        var name = plugin.NAME;\n        var JQUERY_NO_CONFLICT = $.fn[name];\n        $.fn[name] = plugin.jQueryInterface;\n        $.fn[name].Constructor = plugin;\n        $.fn[name].noConflict = function () {\n          $.fn[name] = JQUERY_NO_CONFLICT;\n          return plugin.jQueryInterface;\n        };\n      }\n    });\n  };\n  var execute = function execute(callback) {\n    if (typeof callback === 'function') {\n      callback();\n    }\n  };\n  var executeAfterTransition = function executeAfterTransition(callback, transitionElement) {\n    var waitForTransition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    if (!waitForTransition) {\n      execute(callback);\n      return;\n    }\n    var durationPadding = 5;\n    var emulatedDuration = getTransitionDurationFromElement(transitionElement) + durationPadding;\n    var called = false;\n    var handler = function handler(_ref7) {\n      var target = _ref7.target;\n      if (target !== transitionElement) {\n        return;\n      }\n      called = true;\n      transitionElement.removeEventListener(TRANSITION_END, handler);\n      execute(callback);\n    };\n    transitionElement.addEventListener(TRANSITION_END, handler);\n    setTimeout(function () {\n      if (!called) {\n        triggerTransitionEnd(transitionElement);\n      }\n    }, emulatedDuration);\n  };\n  /**\n   * Return the previous/next element of a list.\n   *\n   * @param {array} list    The list of elements\n   * @param activeElement   The active element\n   * @param shouldGetNext   Choose to get next or previous element\n   * @param isCycleAllowed\n   * @return {Element|elem} The proper element\n   */\n\n  var getNextActiveElement = function getNextActiveElement(list, activeElement, shouldGetNext, isCycleAllowed) {\n    var index = list.indexOf(activeElement); // if the element does not exist in the list return an element depending on the direction and if cycle is allowed\n\n    if (index === -1) {\n      return list[!shouldGetNext && isCycleAllowed ? list.length - 1 : 0];\n    }\n    var listLength = list.length;\n    index += shouldGetNext ? 1 : -1;\n    if (isCycleAllowed) {\n      index = (index + listLength) % listLength;\n    }\n    return list[Math.max(0, Math.min(index, listLength - 1))];\n  };\n\n  /**\n   * --------------------------------------------------------------------------\n   * Bootstrap (v5.0.2): dom/event-handler.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */\n  /**\n   * ------------------------------------------------------------------------\n   * Constants\n   * ------------------------------------------------------------------------\n   */\n\n  var namespaceRegex = /[^.]*(?=\\..*)\\.|.*/;\n  var stripNameRegex = /\\..*/;\n  var stripUidRegex = /::\\d+$/;\n  var eventRegistry = {}; // Events storage\n\n  var uidEvent = 1;\n  var customEvents = {\n    mouseenter: 'mouseover',\n    mouseleave: 'mouseout'\n  };\n  var customEventsRegex = /^(mouseenter|mouseleave)/i;\n  var nativeEvents = new Set(['click', 'dblclick', 'mouseup', 'mousedown', 'contextmenu', 'mousewheel', 'DOMMouseScroll', 'mouseover', 'mouseout', 'mousemove', 'selectstart', 'selectend', 'keydown', 'keypress', 'keyup', 'orientationchange', 'touchstart', 'touchmove', 'touchend', 'touchcancel', 'pointerdown', 'pointermove', 'pointerup', 'pointerleave', 'pointercancel', 'gesturestart', 'gesturechange', 'gestureend', 'focus', 'blur', 'change', 'reset', 'select', 'submit', 'focusin', 'focusout', 'load', 'unload', 'beforeunload', 'resize', 'move', 'DOMContentLoaded', 'readystatechange', 'error', 'abort', 'scroll']);\n  /**\n   * ------------------------------------------------------------------------\n   * Private methods\n   * ------------------------------------------------------------------------\n   */\n\n  function getUidEvent(element, uid) {\n    return uid && \"\".concat(uid, \"::\").concat(uidEvent++) || element.uidEvent || uidEvent++;\n  }\n  function getEvent(element) {\n    var uid = getUidEvent(element);\n    element.uidEvent = uid;\n    eventRegistry[uid] = eventRegistry[uid] || {};\n    return eventRegistry[uid];\n  }\n  function bootstrapHandler(element, fn) {\n    return function handler(event) {\n      event.delegateTarget = element;\n      if (handler.oneOff) {\n        EventHandler.off(element, event.type, fn);\n      }\n      return fn.apply(element, [event]);\n    };\n  }\n  function bootstrapDelegationHandler(element, selector, fn) {\n    return function handler(event) {\n      var domElements = element.querySelectorAll(selector);\n      for (var target = event.target; target && target !== this; target = target.parentNode) {\n        for (var i = domElements.length; i--;) {\n          if (domElements[i] === target) {\n            event.delegateTarget = target;\n            if (handler.oneOff) {\n              // eslint-disable-next-line unicorn/consistent-destructuring\n              EventHandler.off(element, event.type, selector, fn);\n            }\n            return fn.apply(target, [event]);\n          }\n        }\n      } // To please ESLint\n\n      return null;\n    };\n  }\n  function findHandler(events, handler) {\n    var delegationSelector = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    var uidEventList = Object.keys(events);\n    for (var i = 0, len = uidEventList.length; i < len; i++) {\n      var event = events[uidEventList[i]];\n      if (event.originalHandler === handler && event.delegationSelector === delegationSelector) {\n        return event;\n      }\n    }\n    return null;\n  }\n  function normalizeParams(originalTypeEvent, handler, delegationFn) {\n    var delegation = typeof handler === 'string';\n    var originalHandler = delegation ? delegationFn : handler;\n    var typeEvent = getTypeEvent(originalTypeEvent);\n    var isNative = nativeEvents.has(typeEvent);\n    if (!isNative) {\n      typeEvent = originalTypeEvent;\n    }\n    return [delegation, originalHandler, typeEvent];\n  }\n  function addHandler(element, originalTypeEvent, handler, delegationFn, oneOff) {\n    if (typeof originalTypeEvent !== 'string' || !element) {\n      return;\n    }\n    if (!handler) {\n      handler = delegationFn;\n      delegationFn = null;\n    } // in case of mouseenter or mouseleave wrap the handler within a function that checks for its DOM position\n    // this prevents the handler from being dispatched the same way as mouseover or mouseout does\n\n    if (customEventsRegex.test(originalTypeEvent)) {\n      var wrapFn = function wrapFn(fn) {\n        return function (event) {\n          if (!event.relatedTarget || event.relatedTarget !== event.delegateTarget && !event.delegateTarget.contains(event.relatedTarget)) {\n            return fn.call(this, event);\n          }\n        };\n      };\n      if (delegationFn) {\n        delegationFn = wrapFn(delegationFn);\n      } else {\n        handler = wrapFn(handler);\n      }\n    }\n    var _normalizeParams = normalizeParams(originalTypeEvent, handler, delegationFn),\n      _normalizeParams2 = _slicedToArray(_normalizeParams, 3),\n      delegation = _normalizeParams2[0],\n      originalHandler = _normalizeParams2[1],\n      typeEvent = _normalizeParams2[2];\n    var events = getEvent(element);\n    var handlers = events[typeEvent] || (events[typeEvent] = {});\n    var previousFn = findHandler(handlers, originalHandler, delegation ? handler : null);\n    if (previousFn) {\n      previousFn.oneOff = previousFn.oneOff && oneOff;\n      return;\n    }\n    var uid = getUidEvent(originalHandler, originalTypeEvent.replace(namespaceRegex, ''));\n    var fn = delegation ? bootstrapDelegationHandler(element, handler, delegationFn) : bootstrapHandler(element, handler);\n    fn.delegationSelector = delegation ? handler : null;\n    fn.originalHandler = originalHandler;\n    fn.oneOff = oneOff;\n    fn.uidEvent = uid;\n    handlers[uid] = fn;\n    element.addEventListener(typeEvent, fn, delegation);\n  }\n  function removeHandler(element, events, typeEvent, handler, delegationSelector) {\n    var fn = findHandler(events[typeEvent], handler, delegationSelector);\n    if (!fn) {\n      return;\n    }\n    element.removeEventListener(typeEvent, fn, Boolean(delegationSelector));\n    delete events[typeEvent][fn.uidEvent];\n  }\n  function removeNamespacedHandlers(element, events, typeEvent, namespace) {\n    var storeElementEvent = events[typeEvent] || {};\n    Object.keys(storeElementEvent).forEach(function (handlerKey) {\n      if (handlerKey.includes(namespace)) {\n        var event = storeElementEvent[handlerKey];\n        removeHandler(element, events, typeEvent, event.originalHandler, event.delegationSelector);\n      }\n    });\n  }\n  function getTypeEvent(event) {\n    // allow to get the native events from namespaced events ('click.bs.button' --> 'click')\n    event = event.replace(stripNameRegex, '');\n    return customEvents[event] || event;\n  }\n  var EventHandler = {\n    on: function on(element, event, handler, delegationFn) {\n      addHandler(element, event, handler, delegationFn, false);\n    },\n    one: function one(element, event, handler, delegationFn) {\n      addHandler(element, event, handler, delegationFn, true);\n    },\n    off: function off(element, originalTypeEvent, handler, delegationFn) {\n      if (typeof originalTypeEvent !== 'string' || !element) {\n        return;\n      }\n      var _normalizeParams3 = normalizeParams(originalTypeEvent, handler, delegationFn),\n        _normalizeParams4 = _slicedToArray(_normalizeParams3, 3),\n        delegation = _normalizeParams4[0],\n        originalHandler = _normalizeParams4[1],\n        typeEvent = _normalizeParams4[2];\n      var inNamespace = typeEvent !== originalTypeEvent;\n      var events = getEvent(element);\n      var isNamespace = originalTypeEvent.startsWith('.');\n      if (typeof originalHandler !== 'undefined') {\n        // Simplest case: handler is passed, remove that listener ONLY.\n        if (!events || !events[typeEvent]) {\n          return;\n        }\n        removeHandler(element, events, typeEvent, originalHandler, delegation ? handler : null);\n        return;\n      }\n      if (isNamespace) {\n        Object.keys(events).forEach(function (elementEvent) {\n          removeNamespacedHandlers(element, events, elementEvent, originalTypeEvent.slice(1));\n        });\n      }\n      var storeElementEvent = events[typeEvent] || {};\n      Object.keys(storeElementEvent).forEach(function (keyHandlers) {\n        var handlerKey = keyHandlers.replace(stripUidRegex, '');\n        if (!inNamespace || originalTypeEvent.includes(handlerKey)) {\n          var event = storeElementEvent[keyHandlers];\n          removeHandler(element, events, typeEvent, event.originalHandler, event.delegationSelector);\n        }\n      });\n    },\n    trigger: function trigger(element, event, args) {\n      if (typeof event !== 'string' || !element) {\n        return null;\n      }\n      var $ = getjQuery();\n      var typeEvent = getTypeEvent(event);\n      var inNamespace = event !== typeEvent;\n      var isNative = nativeEvents.has(typeEvent);\n      var jQueryEvent;\n      var bubbles = true;\n      var nativeDispatch = true;\n      var defaultPrevented = false;\n      var evt = null;\n      if (inNamespace && $) {\n        jQueryEvent = $.Event(event, args);\n        $(element).trigger(jQueryEvent);\n        bubbles = !jQueryEvent.isPropagationStopped();\n        nativeDispatch = !jQueryEvent.isImmediatePropagationStopped();\n        defaultPrevented = jQueryEvent.isDefaultPrevented();\n      }\n      if (isNative) {\n        evt = document.createEvent('HTMLEvents');\n        evt.initEvent(typeEvent, bubbles, true);\n      } else {\n        evt = new CustomEvent(event, {\n          bubbles: bubbles,\n          cancelable: true\n        });\n      } // merge custom information in our event\n\n      if (typeof args !== 'undefined') {\n        Object.keys(args).forEach(function (key) {\n          Object.defineProperty(evt, key, {\n            get: function get() {\n              return args[key];\n            }\n          });\n        });\n      }\n      if (defaultPrevented) {\n        evt.preventDefault();\n      }\n      if (nativeDispatch) {\n        element.dispatchEvent(evt);\n      }\n      if (evt.defaultPrevented && typeof jQueryEvent !== 'undefined') {\n        jQueryEvent.preventDefault();\n      }\n      return evt;\n    }\n  };\n\n  /**\n   * --------------------------------------------------------------------------\n   * Bootstrap (v5.0.2): dom/data.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */\n\n  /**\n   * ------------------------------------------------------------------------\n   * Constants\n   * ------------------------------------------------------------------------\n   */\n  var elementMap = new Map();\n  var Data = {\n    set: function set(element, key, instance) {\n      if (!elementMap.has(element)) {\n        elementMap.set(element, new Map());\n      }\n      var instanceMap = elementMap.get(element); // make it clear we only want one instance per element\n      // can be removed later when multiple key/instances are fine to be used\n\n      if (!instanceMap.has(key) && instanceMap.size !== 0) {\n        // eslint-disable-next-line no-console\n        console.error(\"Bootstrap doesn't allow more than one instance per element. Bound instance: \".concat(Array.from(instanceMap.keys())[0], \".\"));\n        return;\n      }\n      instanceMap.set(key, instance);\n    },\n    get: function get(element, key) {\n      if (elementMap.has(element)) {\n        return elementMap.get(element).get(key) || null;\n      }\n      return null;\n    },\n    remove: function remove(element, key) {\n      if (!elementMap.has(element)) {\n        return;\n      }\n      var instanceMap = elementMap.get(element);\n      instanceMap[\"delete\"](key); // free up element references if there are no instances left for an element\n\n      if (instanceMap.size === 0) {\n        elementMap[\"delete\"](element);\n      }\n    }\n  };\n\n  /**\n   * --------------------------------------------------------------------------\n   * Bootstrap (v5.0.2): base-component.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */\n  /**\n   * ------------------------------------------------------------------------\n   * Constants\n   * ------------------------------------------------------------------------\n   */\n\n  var VERSION = '5.0.2';\n  var BaseComponent = /*#__PURE__*/function () {\n    function BaseComponent(element) {\n      _classCallCheck(this, BaseComponent);\n      element = getElement(element);\n      if (!element) {\n        return;\n      }\n      this._element = element;\n      Data.set(this._element, this.constructor.DATA_KEY, this);\n    }\n    _createClass(BaseComponent, [{\n      key: \"dispose\",\n      value: function dispose() {\n        var _this = this;\n        Data.remove(this._element, this.constructor.DATA_KEY);\n        EventHandler.off(this._element, this.constructor.EVENT_KEY);\n        Object.getOwnPropertyNames(this).forEach(function (propertyName) {\n          _this[propertyName] = null;\n        });\n      }\n    }, {\n      key: \"_queueCallback\",\n      value: function _queueCallback(callback, element) {\n        var isAnimated = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n        executeAfterTransition(callback, element, isAnimated);\n      }\n      /** Static */\n    }], [{\n      key: \"getInstance\",\n      value: function getInstance(element) {\n        return Data.get(element, this.DATA_KEY);\n      }\n    }, {\n      key: \"getOrCreateInstance\",\n      value: function getOrCreateInstance(element) {\n        var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        return this.getInstance(element) || new this(element, _typeof(config) === 'object' ? config : null);\n      }\n    }, {\n      key: \"VERSION\",\n      get: function get() {\n        return VERSION;\n      }\n    }, {\n      key: \"NAME\",\n      get: function get() {\n        throw new Error('You have to implement the static method \"NAME\", for each component!');\n      }\n    }, {\n      key: \"DATA_KEY\",\n      get: function get() {\n        return \"bs.\".concat(this.NAME);\n      }\n    }, {\n      key: \"EVENT_KEY\",\n      get: function get() {\n        return \".\".concat(this.DATA_KEY);\n      }\n    }]);\n    return BaseComponent;\n  }();\n  /**\n   * --------------------------------------------------------------------------\n   * Bootstrap (v5.0.2): alert.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */\n  /**\n   * ------------------------------------------------------------------------\n   * Constants\n   * ------------------------------------------------------------------------\n   */\n  var NAME$c = 'alert';\n  var DATA_KEY$b = 'bs.alert';\n  var EVENT_KEY$b = \".\".concat(DATA_KEY$b);\n  var DATA_API_KEY$8 = '.data-api';\n  var SELECTOR_DISMISS = '[data-bs-dismiss=\"alert\"]';\n  var EVENT_CLOSE = \"close\".concat(EVENT_KEY$b);\n  var EVENT_CLOSED = \"closed\".concat(EVENT_KEY$b);\n  var EVENT_CLICK_DATA_API$7 = \"click\".concat(EVENT_KEY$b).concat(DATA_API_KEY$8);\n  var CLASS_NAME_ALERT = 'alert';\n  var CLASS_NAME_FADE$6 = 'fade';\n  var CLASS_NAME_SHOW$9 = 'show';\n  /**\n   * ------------------------------------------------------------------------\n   * Class Definition\n   * ------------------------------------------------------------------------\n   */\n  var Alert = /*#__PURE__*/function (_BaseComponent) {\n    _inherits(Alert, _BaseComponent);\n    var _super = _createSuper(Alert);\n    function Alert() {\n      _classCallCheck(this, Alert);\n      return _super.apply(this, arguments);\n    }\n    _createClass(Alert, [{\n      key: \"close\",\n      value:\n      // Public\n\n      function close(element) {\n        var rootElement = element ? this._getRootElement(element) : this._element;\n        var customEvent = this._triggerCloseEvent(rootElement);\n        if (customEvent === null || customEvent.defaultPrevented) {\n          return;\n        }\n        this._removeElement(rootElement);\n      } // Private\n    }, {\n      key: \"_getRootElement\",\n      value: function _getRootElement(element) {\n        return getElementFromSelector(element) || element.closest(\".\".concat(CLASS_NAME_ALERT));\n      }\n    }, {\n      key: \"_triggerCloseEvent\",\n      value: function _triggerCloseEvent(element) {\n        return EventHandler.trigger(element, EVENT_CLOSE);\n      }\n    }, {\n      key: \"_removeElement\",\n      value: function _removeElement(element) {\n        var _this2 = this;\n        element.classList.remove(CLASS_NAME_SHOW$9);\n        var isAnimated = element.classList.contains(CLASS_NAME_FADE$6);\n        this._queueCallback(function () {\n          return _this2._destroyElement(element);\n        }, element, isAnimated);\n      }\n    }, {\n      key: \"_destroyElement\",\n      value: function _destroyElement(element) {\n        element.remove();\n        EventHandler.trigger(element, EVENT_CLOSED);\n      } // Static\n    }], [{\n      key: \"NAME\",\n      get:\n      // Getters\n      function get() {\n        return NAME$c;\n      }\n    }, {\n      key: \"jQueryInterface\",\n      value: function jQueryInterface(config) {\n        return this.each(function () {\n          var data = Alert.getOrCreateInstance(this);\n          if (config === 'close') {\n            data[config](this);\n          }\n        });\n      }\n    }, {\n      key: \"handleDismiss\",\n      value: function handleDismiss(alertInstance) {\n        return function (event) {\n          if (event) {\n            event.preventDefault();\n          }\n          alertInstance.close(this);\n        };\n      }\n    }]);\n    return Alert;\n  }(BaseComponent);\n  /**\n   * ------------------------------------------------------------------------\n   * Data Api implementation\n   * ------------------------------------------------------------------------\n   */\n  EventHandler.on(document, EVENT_CLICK_DATA_API$7, SELECTOR_DISMISS, Alert.handleDismiss(new Alert()));\n  /**\n   * ------------------------------------------------------------------------\n   * jQuery\n   * ------------------------------------------------------------------------\n   * add .Alert to jQuery only if jQuery is present\n   */\n\n  defineJQueryPlugin(Alert);\n\n  /**\n   * --------------------------------------------------------------------------\n   * Bootstrap (v5.0.2): button.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */\n  /**\n   * ------------------------------------------------------------------------\n   * Constants\n   * ------------------------------------------------------------------------\n   */\n\n  var NAME$b = 'button';\n  var DATA_KEY$a = 'bs.button';\n  var EVENT_KEY$a = \".\".concat(DATA_KEY$a);\n  var DATA_API_KEY$7 = '.data-api';\n  var CLASS_NAME_ACTIVE$3 = 'active';\n  var SELECTOR_DATA_TOGGLE$5 = '[data-bs-toggle=\"button\"]';\n  var EVENT_CLICK_DATA_API$6 = \"click\".concat(EVENT_KEY$a).concat(DATA_API_KEY$7);\n  /**\n   * ------------------------------------------------------------------------\n   * Class Definition\n   * ------------------------------------------------------------------------\n   */\n  var Button = /*#__PURE__*/function (_BaseComponent2) {\n    _inherits(Button, _BaseComponent2);\n    var _super2 = _createSuper(Button);\n    function Button() {\n      _classCallCheck(this, Button);\n      return _super2.apply(this, arguments);\n    }\n    _createClass(Button, [{\n      key: \"toggle\",\n      value:\n      // Public\n\n      function toggle() {\n        // Toggle class and sync the `aria-pressed` attribute with the return value of the `.toggle()` method\n        this._element.setAttribute('aria-pressed', this._element.classList.toggle(CLASS_NAME_ACTIVE$3));\n      } // Static\n    }], [{\n      key: \"NAME\",\n      get:\n      // Getters\n      function get() {\n        return NAME$b;\n      }\n    }, {\n      key: \"jQueryInterface\",\n      value: function jQueryInterface(config) {\n        return this.each(function () {\n          var data = Button.getOrCreateInstance(this);\n          if (config === 'toggle') {\n            data[config]();\n          }\n        });\n      }\n    }]);\n    return Button;\n  }(BaseComponent);\n  /**\n   * ------------------------------------------------------------------------\n   * Data Api implementation\n   * ------------------------------------------------------------------------\n   */\n  EventHandler.on(document, EVENT_CLICK_DATA_API$6, SELECTOR_DATA_TOGGLE$5, function (event) {\n    event.preventDefault();\n    var button = event.target.closest(SELECTOR_DATA_TOGGLE$5);\n    var data = Button.getOrCreateInstance(button);\n    data.toggle();\n  });\n  /**\n   * ------------------------------------------------------------------------\n   * jQuery\n   * ------------------------------------------------------------------------\n   * add .Button to jQuery only if jQuery is present\n   */\n\n  defineJQueryPlugin(Button);\n\n  /**\n   * --------------------------------------------------------------------------\n   * Bootstrap (v5.0.2): dom/manipulator.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */\n  function normalizeData(val) {\n    if (val === 'true') {\n      return true;\n    }\n    if (val === 'false') {\n      return false;\n    }\n    if (val === Number(val).toString()) {\n      return Number(val);\n    }\n    if (val === '' || val === 'null') {\n      return null;\n    }\n    return val;\n  }\n  function normalizeDataKey(key) {\n    return key.replace(/[A-Z]/g, function (chr) {\n      return \"-\".concat(chr.toLowerCase());\n    });\n  }\n  var Manipulator = {\n    setDataAttribute: function setDataAttribute(element, key, value) {\n      element.setAttribute(\"data-bs-\".concat(normalizeDataKey(key)), value);\n    },\n    removeDataAttribute: function removeDataAttribute(element, key) {\n      element.removeAttribute(\"data-bs-\".concat(normalizeDataKey(key)));\n    },\n    getDataAttributes: function getDataAttributes(element) {\n      if (!element) {\n        return {};\n      }\n      var attributes = {};\n      Object.keys(element.dataset).filter(function (key) {\n        return key.startsWith('bs');\n      }).forEach(function (key) {\n        var pureKey = key.replace(/^bs/, '');\n        pureKey = pureKey.charAt(0).toLowerCase() + pureKey.slice(1, pureKey.length);\n        attributes[pureKey] = normalizeData(element.dataset[key]);\n      });\n      return attributes;\n    },\n    getDataAttribute: function getDataAttribute(element, key) {\n      return normalizeData(element.getAttribute(\"data-bs-\".concat(normalizeDataKey(key))));\n    },\n    offset: function offset(element) {\n      var rect = element.getBoundingClientRect();\n      return {\n        top: rect.top + document.body.scrollTop,\n        left: rect.left + document.body.scrollLeft\n      };\n    },\n    position: function position(element) {\n      return {\n        top: element.offsetTop,\n        left: element.offsetLeft\n      };\n    }\n  };\n\n  /**\n   * --------------------------------------------------------------------------\n   * Bootstrap (v5.0.2): carousel.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */\n  /**\n   * ------------------------------------------------------------------------\n   * Constants\n   * ------------------------------------------------------------------------\n   */\n\n  var NAME$a = 'carousel';\n  var DATA_KEY$9 = 'bs.carousel';\n  var EVENT_KEY$9 = \".\".concat(DATA_KEY$9);\n  var DATA_API_KEY$6 = '.data-api';\n  var ARROW_LEFT_KEY = 'ArrowLeft';\n  var ARROW_RIGHT_KEY = 'ArrowRight';\n  var TOUCHEVENT_COMPAT_WAIT = 500; // Time for mouse compat events to fire after touch\n\n  var SWIPE_THRESHOLD = 40;\n  var Default$9 = {\n    interval: 5000,\n    keyboard: true,\n    slide: false,\n    pause: 'hover',\n    wrap: true,\n    touch: true\n  };\n  var DefaultType$9 = {\n    interval: '(number|boolean)',\n    keyboard: 'boolean',\n    slide: '(boolean|string)',\n    pause: '(string|boolean)',\n    wrap: 'boolean',\n    touch: 'boolean'\n  };\n  var ORDER_NEXT = 'next';\n  var ORDER_PREV = 'prev';\n  var DIRECTION_LEFT = 'left';\n  var DIRECTION_RIGHT = 'right';\n  var KEY_TO_DIRECTION = (_KEY_TO_DIRECTION = {}, _defineProperty(_KEY_TO_DIRECTION, ARROW_LEFT_KEY, DIRECTION_RIGHT), _defineProperty(_KEY_TO_DIRECTION, ARROW_RIGHT_KEY, DIRECTION_LEFT), _KEY_TO_DIRECTION);\n  var EVENT_SLIDE = \"slide\".concat(EVENT_KEY$9);\n  var EVENT_SLID = \"slid\".concat(EVENT_KEY$9);\n  var EVENT_KEYDOWN = \"keydown\".concat(EVENT_KEY$9);\n  var EVENT_MOUSEENTER = \"mouseenter\".concat(EVENT_KEY$9);\n  var EVENT_MOUSELEAVE = \"mouseleave\".concat(EVENT_KEY$9);\n  var EVENT_TOUCHSTART = \"touchstart\".concat(EVENT_KEY$9);\n  var EVENT_TOUCHMOVE = \"touchmove\".concat(EVENT_KEY$9);\n  var EVENT_TOUCHEND = \"touchend\".concat(EVENT_KEY$9);\n  var EVENT_POINTERDOWN = \"pointerdown\".concat(EVENT_KEY$9);\n  var EVENT_POINTERUP = \"pointerup\".concat(EVENT_KEY$9);\n  var EVENT_DRAG_START = \"dragstart\".concat(EVENT_KEY$9);\n  var EVENT_LOAD_DATA_API$2 = \"load\".concat(EVENT_KEY$9).concat(DATA_API_KEY$6);\n  var EVENT_CLICK_DATA_API$5 = \"click\".concat(EVENT_KEY$9).concat(DATA_API_KEY$6);\n  var CLASS_NAME_CAROUSEL = 'carousel';\n  var CLASS_NAME_ACTIVE$2 = 'active';\n  var CLASS_NAME_SLIDE = 'slide';\n  var CLASS_NAME_END = 'carousel-item-end';\n  var CLASS_NAME_START = 'carousel-item-start';\n  var CLASS_NAME_NEXT = 'carousel-item-next';\n  var CLASS_NAME_PREV = 'carousel-item-prev';\n  var CLASS_NAME_POINTER_EVENT = 'pointer-event';\n  var SELECTOR_ACTIVE$1 = '.active';\n  var SELECTOR_ACTIVE_ITEM = '.active.carousel-item';\n  var SELECTOR_ITEM = '.carousel-item';\n  var SELECTOR_ITEM_IMG = '.carousel-item img';\n  var SELECTOR_NEXT_PREV = '.carousel-item-next, .carousel-item-prev';\n  var SELECTOR_INDICATORS = '.carousel-indicators';\n  var SELECTOR_INDICATOR = '[data-bs-target]';\n  var SELECTOR_DATA_SLIDE = '[data-bs-slide], [data-bs-slide-to]';\n  var SELECTOR_DATA_RIDE = '[data-bs-ride=\"carousel\"]';\n  var POINTER_TYPE_TOUCH = 'touch';\n  var POINTER_TYPE_PEN = 'pen';\n  /**\n   * ------------------------------------------------------------------------\n   * Class Definition\n   * ------------------------------------------------------------------------\n   */\n  var Carousel = /*#__PURE__*/function (_BaseComponent3) {\n    _inherits(Carousel, _BaseComponent3);\n    var _super3 = _createSuper(Carousel);\n    function Carousel(element, config) {\n      var _this3;\n      _classCallCheck(this, Carousel);\n      _this3 = _super3.call(this, element);\n      _this3._items = null;\n      _this3._interval = null;\n      _this3._activeElement = null;\n      _this3._isPaused = false;\n      _this3._isSliding = false;\n      _this3.touchTimeout = null;\n      _this3.touchStartX = 0;\n      _this3.touchDeltaX = 0;\n      _this3._config = _this3._getConfig(config);\n      _this3._indicatorsElement = SelectorEngine.findOne(SELECTOR_INDICATORS, _this3._element);\n      _this3._touchSupported = 'ontouchstart' in document.documentElement || navigator.maxTouchPoints > 0;\n      _this3._pointerEvent = Boolean(window.PointerEvent);\n      _this3._addEventListeners();\n      return _this3;\n    } // Getters\n    _createClass(Carousel, [{\n      key: \"next\",\n      value:\n      // Public\n\n      function next() {\n        this._slide(ORDER_NEXT);\n      }\n    }, {\n      key: \"nextWhenVisible\",\n      value: function nextWhenVisible() {\n        // Don't call next when the page isn't visible\n        // or the carousel or its parent isn't visible\n        if (!document.hidden && isVisible(this._element)) {\n          this.next();\n        }\n      }\n    }, {\n      key: \"prev\",\n      value: function prev() {\n        this._slide(ORDER_PREV);\n      }\n    }, {\n      key: \"pause\",\n      value: function pause(event) {\n        if (!event) {\n          this._isPaused = true;\n        }\n        if (SelectorEngine.findOne(SELECTOR_NEXT_PREV, this._element)) {\n          triggerTransitionEnd(this._element);\n          this.cycle(true);\n        }\n        clearInterval(this._interval);\n        this._interval = null;\n      }\n    }, {\n      key: \"cycle\",\n      value: function cycle(event) {\n        if (!event) {\n          this._isPaused = false;\n        }\n        if (this._interval) {\n          clearInterval(this._interval);\n          this._interval = null;\n        }\n        if (this._config && this._config.interval && !this._isPaused) {\n          this._updateInterval();\n          this._interval = setInterval((document.visibilityState ? this.nextWhenVisible : this.next).bind(this), this._config.interval);\n        }\n      }\n    }, {\n      key: \"to\",\n      value: function to(index) {\n        var _this4 = this;\n        this._activeElement = SelectorEngine.findOne(SELECTOR_ACTIVE_ITEM, this._element);\n        var activeIndex = this._getItemIndex(this._activeElement);\n        if (index > this._items.length - 1 || index < 0) {\n          return;\n        }\n        if (this._isSliding) {\n          EventHandler.one(this._element, EVENT_SLID, function () {\n            return _this4.to(index);\n          });\n          return;\n        }\n        if (activeIndex === index) {\n          this.pause();\n          this.cycle();\n          return;\n        }\n        var order = index > activeIndex ? ORDER_NEXT : ORDER_PREV;\n        this._slide(order, this._items[index]);\n      } // Private\n    }, {\n      key: \"_getConfig\",\n      value: function _getConfig(config) {\n        config = _objectSpread(_objectSpread(_objectSpread({}, Default$9), Manipulator.getDataAttributes(this._element)), _typeof(config) === 'object' ? config : {});\n        typeCheckConfig(NAME$a, config, DefaultType$9);\n        return config;\n      }\n    }, {\n      key: \"_handleSwipe\",\n      value: function _handleSwipe() {\n        var absDeltax = Math.abs(this.touchDeltaX);\n        if (absDeltax <= SWIPE_THRESHOLD) {\n          return;\n        }\n        var direction = absDeltax / this.touchDeltaX;\n        this.touchDeltaX = 0;\n        if (!direction) {\n          return;\n        }\n        this._slide(direction > 0 ? DIRECTION_RIGHT : DIRECTION_LEFT);\n      }\n    }, {\n      key: \"_addEventListeners\",\n      value: function _addEventListeners() {\n        var _this5 = this;\n        if (this._config.keyboard) {\n          EventHandler.on(this._element, EVENT_KEYDOWN, function (event) {\n            return _this5._keydown(event);\n          });\n        }\n        if (this._config.pause === 'hover') {\n          EventHandler.on(this._element, EVENT_MOUSEENTER, function (event) {\n            return _this5.pause(event);\n          });\n          EventHandler.on(this._element, EVENT_MOUSELEAVE, function (event) {\n            return _this5.cycle(event);\n          });\n        }\n        if (this._config.touch && this._touchSupported) {\n          this._addTouchEventListeners();\n        }\n      }\n    }, {\n      key: \"_addTouchEventListeners\",\n      value: function _addTouchEventListeners() {\n        var _this6 = this;\n        var start = function start(event) {\n          if (_this6._pointerEvent && (event.pointerType === POINTER_TYPE_PEN || event.pointerType === POINTER_TYPE_TOUCH)) {\n            _this6.touchStartX = event.clientX;\n          } else if (!_this6._pointerEvent) {\n            _this6.touchStartX = event.touches[0].clientX;\n          }\n        };\n        var move = function move(event) {\n          // ensure swiping with one touch and not pinching\n          _this6.touchDeltaX = event.touches && event.touches.length > 1 ? 0 : event.touches[0].clientX - _this6.touchStartX;\n        };\n        var end = function end(event) {\n          if (_this6._pointerEvent && (event.pointerType === POINTER_TYPE_PEN || event.pointerType === POINTER_TYPE_TOUCH)) {\n            _this6.touchDeltaX = event.clientX - _this6.touchStartX;\n          }\n          _this6._handleSwipe();\n          if (_this6._config.pause === 'hover') {\n            // If it's a touch-enabled device, mouseenter/leave are fired as\n            // part of the mouse compatibility events on first tap - the carousel\n            // would stop cycling until user tapped out of it;\n            // here, we listen for touchend, explicitly pause the carousel\n            // (as if it's the second time we tap on it, mouseenter compat event\n            // is NOT fired) and after a timeout (to allow for mouse compatibility\n            // events to fire) we explicitly restart cycling\n            _this6.pause();\n            if (_this6.touchTimeout) {\n              clearTimeout(_this6.touchTimeout);\n            }\n            _this6.touchTimeout = setTimeout(function (event) {\n              return _this6.cycle(event);\n            }, TOUCHEVENT_COMPAT_WAIT + _this6._config.interval);\n          }\n        };\n        SelectorEngine.find(SELECTOR_ITEM_IMG, this._element).forEach(function (itemImg) {\n          EventHandler.on(itemImg, EVENT_DRAG_START, function (e) {\n            return e.preventDefault();\n          });\n        });\n        if (this._pointerEvent) {\n          EventHandler.on(this._element, EVENT_POINTERDOWN, function (event) {\n            return start(event);\n          });\n          EventHandler.on(this._element, EVENT_POINTERUP, function (event) {\n            return end(event);\n          });\n          this._element.classList.add(CLASS_NAME_POINTER_EVENT);\n        } else {\n          EventHandler.on(this._element, EVENT_TOUCHSTART, function (event) {\n            return start(event);\n          });\n          EventHandler.on(this._element, EVENT_TOUCHMOVE, function (event) {\n            return move(event);\n          });\n          EventHandler.on(this._element, EVENT_TOUCHEND, function (event) {\n            return end(event);\n          });\n        }\n      }\n    }, {\n      key: \"_keydown\",\n      value: function _keydown(event) {\n        if (/input|textarea/i.test(event.target.tagName)) {\n          return;\n        }\n        var direction = KEY_TO_DIRECTION[event.key];\n        if (direction) {\n          event.preventDefault();\n          this._slide(direction);\n        }\n      }\n    }, {\n      key: \"_getItemIndex\",\n      value: function _getItemIndex(element) {\n        this._items = element && element.parentNode ? SelectorEngine.find(SELECTOR_ITEM, element.parentNode) : [];\n        return this._items.indexOf(element);\n      }\n    }, {\n      key: \"_getItemByOrder\",\n      value: function _getItemByOrder(order, activeElement) {\n        var isNext = order === ORDER_NEXT;\n        return getNextActiveElement(this._items, activeElement, isNext, this._config.wrap);\n      }\n    }, {\n      key: \"_triggerSlideEvent\",\n      value: function _triggerSlideEvent(relatedTarget, eventDirectionName) {\n        var targetIndex = this._getItemIndex(relatedTarget);\n        var fromIndex = this._getItemIndex(SelectorEngine.findOne(SELECTOR_ACTIVE_ITEM, this._element));\n        return EventHandler.trigger(this._element, EVENT_SLIDE, {\n          relatedTarget: relatedTarget,\n          direction: eventDirectionName,\n          from: fromIndex,\n          to: targetIndex\n        });\n      }\n    }, {\n      key: \"_setActiveIndicatorElement\",\n      value: function _setActiveIndicatorElement(element) {\n        if (this._indicatorsElement) {\n          var activeIndicator = SelectorEngine.findOne(SELECTOR_ACTIVE$1, this._indicatorsElement);\n          activeIndicator.classList.remove(CLASS_NAME_ACTIVE$2);\n          activeIndicator.removeAttribute('aria-current');\n          var indicators = SelectorEngine.find(SELECTOR_INDICATOR, this._indicatorsElement);\n          for (var i = 0; i < indicators.length; i++) {\n            if (Number.parseInt(indicators[i].getAttribute('data-bs-slide-to'), 10) === this._getItemIndex(element)) {\n              indicators[i].classList.add(CLASS_NAME_ACTIVE$2);\n              indicators[i].setAttribute('aria-current', 'true');\n              break;\n            }\n          }\n        }\n      }\n    }, {\n      key: \"_updateInterval\",\n      value: function _updateInterval() {\n        var element = this._activeElement || SelectorEngine.findOne(SELECTOR_ACTIVE_ITEM, this._element);\n        if (!element) {\n          return;\n        }\n        var elementInterval = Number.parseInt(element.getAttribute('data-bs-interval'), 10);\n        if (elementInterval) {\n          this._config.defaultInterval = this._config.defaultInterval || this._config.interval;\n          this._config.interval = elementInterval;\n        } else {\n          this._config.interval = this._config.defaultInterval || this._config.interval;\n        }\n      }\n    }, {\n      key: \"_slide\",\n      value: function _slide(directionOrOrder, element) {\n        var _this7 = this;\n        var order = this._directionToOrder(directionOrOrder);\n        var activeElement = SelectorEngine.findOne(SELECTOR_ACTIVE_ITEM, this._element);\n        var activeElementIndex = this._getItemIndex(activeElement);\n        var nextElement = element || this._getItemByOrder(order, activeElement);\n        var nextElementIndex = this._getItemIndex(nextElement);\n        var isCycling = Boolean(this._interval);\n        var isNext = order === ORDER_NEXT;\n        var directionalClassName = isNext ? CLASS_NAME_START : CLASS_NAME_END;\n        var orderClassName = isNext ? CLASS_NAME_NEXT : CLASS_NAME_PREV;\n        var eventDirectionName = this._orderToDirection(order);\n        if (nextElement && nextElement.classList.contains(CLASS_NAME_ACTIVE$2)) {\n          this._isSliding = false;\n          return;\n        }\n        if (this._isSliding) {\n          return;\n        }\n        var slideEvent = this._triggerSlideEvent(nextElement, eventDirectionName);\n        if (slideEvent.defaultPrevented) {\n          return;\n        }\n        if (!activeElement || !nextElement) {\n          // Some weirdness is happening, so we bail\n          return;\n        }\n        this._isSliding = true;\n        if (isCycling) {\n          this.pause();\n        }\n        this._setActiveIndicatorElement(nextElement);\n        this._activeElement = nextElement;\n        var triggerSlidEvent = function triggerSlidEvent() {\n          EventHandler.trigger(_this7._element, EVENT_SLID, {\n            relatedTarget: nextElement,\n            direction: eventDirectionName,\n            from: activeElementIndex,\n            to: nextElementIndex\n          });\n        };\n        if (this._element.classList.contains(CLASS_NAME_SLIDE)) {\n          nextElement.classList.add(orderClassName);\n          reflow(nextElement);\n          activeElement.classList.add(directionalClassName);\n          nextElement.classList.add(directionalClassName);\n          var completeCallBack = function completeCallBack() {\n            nextElement.classList.remove(directionalClassName, orderClassName);\n            nextElement.classList.add(CLASS_NAME_ACTIVE$2);\n            activeElement.classList.remove(CLASS_NAME_ACTIVE$2, orderClassName, directionalClassName);\n            _this7._isSliding = false;\n            setTimeout(triggerSlidEvent, 0);\n          };\n          this._queueCallback(completeCallBack, activeElement, true);\n        } else {\n          activeElement.classList.remove(CLASS_NAME_ACTIVE$2);\n          nextElement.classList.add(CLASS_NAME_ACTIVE$2);\n          this._isSliding = false;\n          triggerSlidEvent();\n        }\n        if (isCycling) {\n          this.cycle();\n        }\n      }\n    }, {\n      key: \"_directionToOrder\",\n      value: function _directionToOrder(direction) {\n        if (![DIRECTION_RIGHT, DIRECTION_LEFT].includes(direction)) {\n          return direction;\n        }\n        if (isRTL()) {\n          return direction === DIRECTION_LEFT ? ORDER_PREV : ORDER_NEXT;\n        }\n        return direction === DIRECTION_LEFT ? ORDER_NEXT : ORDER_PREV;\n      }\n    }, {\n      key: \"_orderToDirection\",\n      value: function _orderToDirection(order) {\n        if (![ORDER_NEXT, ORDER_PREV].includes(order)) {\n          return order;\n        }\n        if (isRTL()) {\n          return order === ORDER_PREV ? DIRECTION_LEFT : DIRECTION_RIGHT;\n        }\n        return order === ORDER_PREV ? DIRECTION_RIGHT : DIRECTION_LEFT;\n      } // Static\n    }], [{\n      key: \"Default\",\n      get: function get() {\n        return Default$9;\n      }\n    }, {\n      key: \"NAME\",\n      get: function get() {\n        return NAME$a;\n      }\n    }, {\n      key: \"carouselInterface\",\n      value: function carouselInterface(element, config) {\n        var data = Carousel.getOrCreateInstance(element, config);\n        var _config = data._config;\n        if (_typeof(config) === 'object') {\n          _config = _objectSpread(_objectSpread({}, _config), config);\n        }\n        var action = typeof config === 'string' ? config : _config.slide;\n        if (typeof config === 'number') {\n          data.to(config);\n        } else if (typeof action === 'string') {\n          if (typeof data[action] === 'undefined') {\n            throw new TypeError(\"No method named \\\"\".concat(action, \"\\\"\"));\n          }\n          data[action]();\n        } else if (_config.interval && _config.ride) {\n          data.pause();\n          data.cycle();\n        }\n      }\n    }, {\n      key: \"jQueryInterface\",\n      value: function jQueryInterface(config) {\n        return this.each(function () {\n          Carousel.carouselInterface(this, config);\n        });\n      }\n    }, {\n      key: \"dataApiClickHandler\",\n      value: function dataApiClickHandler(event) {\n        var target = getElementFromSelector(this);\n        if (!target || !target.classList.contains(CLASS_NAME_CAROUSEL)) {\n          return;\n        }\n        var config = _objectSpread(_objectSpread({}, Manipulator.getDataAttributes(target)), Manipulator.getDataAttributes(this));\n        var slideIndex = this.getAttribute('data-bs-slide-to');\n        if (slideIndex) {\n          config.interval = false;\n        }\n        Carousel.carouselInterface(target, config);\n        if (slideIndex) {\n          Carousel.getInstance(target).to(slideIndex);\n        }\n        event.preventDefault();\n      }\n    }]);\n    return Carousel;\n  }(BaseComponent);\n  /**\n   * ------------------------------------------------------------------------\n   * Data Api implementation\n   * ------------------------------------------------------------------------\n   */\n  EventHandler.on(document, EVENT_CLICK_DATA_API$5, SELECTOR_DATA_SLIDE, Carousel.dataApiClickHandler);\n  EventHandler.on(window, EVENT_LOAD_DATA_API$2, function () {\n    var carousels = SelectorEngine.find(SELECTOR_DATA_RIDE);\n    for (var i = 0, len = carousels.length; i < len; i++) {\n      Carousel.carouselInterface(carousels[i], Carousel.getInstance(carousels[i]));\n    }\n  });\n  /**\n   * ------------------------------------------------------------------------\n   * jQuery\n   * ------------------------------------------------------------------------\n   * add .Carousel to jQuery only if jQuery is present\n   */\n\n  defineJQueryPlugin(Carousel);\n\n  /**\n   * --------------------------------------------------------------------------\n   * Bootstrap (v5.0.2): collapse.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */\n  /**\n   * ------------------------------------------------------------------------\n   * Constants\n   * ------------------------------------------------------------------------\n   */\n\n  var NAME$9 = 'collapse';\n  var DATA_KEY$8 = 'bs.collapse';\n  var EVENT_KEY$8 = \".\".concat(DATA_KEY$8);\n  var DATA_API_KEY$5 = '.data-api';\n  var Default$8 = {\n    toggle: true,\n    parent: ''\n  };\n  var DefaultType$8 = {\n    toggle: 'boolean',\n    parent: '(string|element)'\n  };\n  var EVENT_SHOW$5 = \"show\".concat(EVENT_KEY$8);\n  var EVENT_SHOWN$5 = \"shown\".concat(EVENT_KEY$8);\n  var EVENT_HIDE$5 = \"hide\".concat(EVENT_KEY$8);\n  var EVENT_HIDDEN$5 = \"hidden\".concat(EVENT_KEY$8);\n  var EVENT_CLICK_DATA_API$4 = \"click\".concat(EVENT_KEY$8).concat(DATA_API_KEY$5);\n  var CLASS_NAME_SHOW$8 = 'show';\n  var CLASS_NAME_COLLAPSE = 'collapse';\n  var CLASS_NAME_COLLAPSING = 'collapsing';\n  var CLASS_NAME_COLLAPSED = 'collapsed';\n  var WIDTH = 'width';\n  var HEIGHT = 'height';\n  var SELECTOR_ACTIVES = '.show, .collapsing';\n  var SELECTOR_DATA_TOGGLE$4 = '[data-bs-toggle=\"collapse\"]';\n  /**\n   * ------------------------------------------------------------------------\n   * Class Definition\n   * ------------------------------------------------------------------------\n   */\n  var Collapse = /*#__PURE__*/function (_BaseComponent4) {\n    _inherits(Collapse, _BaseComponent4);\n    var _super4 = _createSuper(Collapse);\n    function Collapse(element, config) {\n      var _this8;\n      _classCallCheck(this, Collapse);\n      _this8 = _super4.call(this, element);\n      _this8._isTransitioning = false;\n      _this8._config = _this8._getConfig(config);\n      _this8._triggerArray = SelectorEngine.find(\"\".concat(SELECTOR_DATA_TOGGLE$4, \"[href=\\\"#\").concat(_this8._element.id, \"\\\"],\") + \"\".concat(SELECTOR_DATA_TOGGLE$4, \"[data-bs-target=\\\"#\").concat(_this8._element.id, \"\\\"]\"));\n      var toggleList = SelectorEngine.find(SELECTOR_DATA_TOGGLE$4);\n      for (var i = 0, len = toggleList.length; i < len; i++) {\n        var elem = toggleList[i];\n        var selector = getSelectorFromElement(elem);\n        var filterElement = SelectorEngine.find(selector).filter(function (foundElem) {\n          return foundElem === _this8._element;\n        });\n        if (selector !== null && filterElement.length) {\n          _this8._selector = selector;\n          _this8._triggerArray.push(elem);\n        }\n      }\n      _this8._parent = _this8._config.parent ? _this8._getParent() : null;\n      if (!_this8._config.parent) {\n        _this8._addAriaAndCollapsedClass(_this8._element, _this8._triggerArray);\n      }\n      if (_this8._config.toggle) {\n        _this8.toggle();\n      }\n      return _this8;\n    } // Getters\n    _createClass(Collapse, [{\n      key: \"toggle\",\n      value:\n      // Public\n\n      function toggle() {\n        if (this._element.classList.contains(CLASS_NAME_SHOW$8)) {\n          this.hide();\n        } else {\n          this.show();\n        }\n      }\n    }, {\n      key: \"show\",\n      value: function show() {\n        var _this9 = this;\n        if (this._isTransitioning || this._element.classList.contains(CLASS_NAME_SHOW$8)) {\n          return;\n        }\n        var actives;\n        var activesData;\n        if (this._parent) {\n          actives = SelectorEngine.find(SELECTOR_ACTIVES, this._parent).filter(function (elem) {\n            if (typeof _this9._config.parent === 'string') {\n              return elem.getAttribute('data-bs-parent') === _this9._config.parent;\n            }\n            return elem.classList.contains(CLASS_NAME_COLLAPSE);\n          });\n          if (actives.length === 0) {\n            actives = null;\n          }\n        }\n        var container = SelectorEngine.findOne(this._selector);\n        if (actives) {\n          var tempActiveData = actives.find(function (elem) {\n            return container !== elem;\n          });\n          activesData = tempActiveData ? Collapse.getInstance(tempActiveData) : null;\n          if (activesData && activesData._isTransitioning) {\n            return;\n          }\n        }\n        var startEvent = EventHandler.trigger(this._element, EVENT_SHOW$5);\n        if (startEvent.defaultPrevented) {\n          return;\n        }\n        if (actives) {\n          actives.forEach(function (elemActive) {\n            if (container !== elemActive) {\n              Collapse.collapseInterface(elemActive, 'hide');\n            }\n            if (!activesData) {\n              Data.set(elemActive, DATA_KEY$8, null);\n            }\n          });\n        }\n        var dimension = this._getDimension();\n        this._element.classList.remove(CLASS_NAME_COLLAPSE);\n        this._element.classList.add(CLASS_NAME_COLLAPSING);\n        this._element.style[dimension] = 0;\n        if (this._triggerArray.length) {\n          this._triggerArray.forEach(function (element) {\n            element.classList.remove(CLASS_NAME_COLLAPSED);\n            element.setAttribute('aria-expanded', true);\n          });\n        }\n        this.setTransitioning(true);\n        var complete = function complete() {\n          _this9._element.classList.remove(CLASS_NAME_COLLAPSING);\n          _this9._element.classList.add(CLASS_NAME_COLLAPSE, CLASS_NAME_SHOW$8);\n          _this9._element.style[dimension] = '';\n          _this9.setTransitioning(false);\n          EventHandler.trigger(_this9._element, EVENT_SHOWN$5);\n        };\n        var capitalizedDimension = dimension[0].toUpperCase() + dimension.slice(1);\n        var scrollSize = \"scroll\".concat(capitalizedDimension);\n        this._queueCallback(complete, this._element, true);\n        this._element.style[dimension] = \"\".concat(this._element[scrollSize], \"px\");\n      }\n    }, {\n      key: \"hide\",\n      value: function hide() {\n        var _this10 = this;\n        if (this._isTransitioning || !this._element.classList.contains(CLASS_NAME_SHOW$8)) {\n          return;\n        }\n        var startEvent = EventHandler.trigger(this._element, EVENT_HIDE$5);\n        if (startEvent.defaultPrevented) {\n          return;\n        }\n        var dimension = this._getDimension();\n        this._element.style[dimension] = \"\".concat(this._element.getBoundingClientRect()[dimension], \"px\");\n        reflow(this._element);\n        this._element.classList.add(CLASS_NAME_COLLAPSING);\n        this._element.classList.remove(CLASS_NAME_COLLAPSE, CLASS_NAME_SHOW$8);\n        var triggerArrayLength = this._triggerArray.length;\n        if (triggerArrayLength > 0) {\n          for (var i = 0; i < triggerArrayLength; i++) {\n            var trigger = this._triggerArray[i];\n            var elem = getElementFromSelector(trigger);\n            if (elem && !elem.classList.contains(CLASS_NAME_SHOW$8)) {\n              trigger.classList.add(CLASS_NAME_COLLAPSED);\n              trigger.setAttribute('aria-expanded', false);\n            }\n          }\n        }\n        this.setTransitioning(true);\n        var complete = function complete() {\n          _this10.setTransitioning(false);\n          _this10._element.classList.remove(CLASS_NAME_COLLAPSING);\n          _this10._element.classList.add(CLASS_NAME_COLLAPSE);\n          EventHandler.trigger(_this10._element, EVENT_HIDDEN$5);\n        };\n        this._element.style[dimension] = '';\n        this._queueCallback(complete, this._element, true);\n      }\n    }, {\n      key: \"setTransitioning\",\n      value: function setTransitioning(isTransitioning) {\n        this._isTransitioning = isTransitioning;\n      } // Private\n    }, {\n      key: \"_getConfig\",\n      value: function _getConfig(config) {\n        config = _objectSpread(_objectSpread({}, Default$8), config);\n        config.toggle = Boolean(config.toggle); // Coerce string values\n\n        typeCheckConfig(NAME$9, config, DefaultType$8);\n        return config;\n      }\n    }, {\n      key: \"_getDimension\",\n      value: function _getDimension() {\n        return this._element.classList.contains(WIDTH) ? WIDTH : HEIGHT;\n      }\n    }, {\n      key: \"_getParent\",\n      value: function _getParent() {\n        var _this11 = this;\n        var parent = this._config.parent;\n        parent = getElement(parent);\n        var selector = \"\".concat(SELECTOR_DATA_TOGGLE$4, \"[data-bs-parent=\\\"\").concat(parent, \"\\\"]\");\n        SelectorEngine.find(selector, parent).forEach(function (element) {\n          var selected = getElementFromSelector(element);\n          _this11._addAriaAndCollapsedClass(selected, [element]);\n        });\n        return parent;\n      }\n    }, {\n      key: \"_addAriaAndCollapsedClass\",\n      value: function _addAriaAndCollapsedClass(element, triggerArray) {\n        if (!element || !triggerArray.length) {\n          return;\n        }\n        var isOpen = element.classList.contains(CLASS_NAME_SHOW$8);\n        triggerArray.forEach(function (elem) {\n          if (isOpen) {\n            elem.classList.remove(CLASS_NAME_COLLAPSED);\n          } else {\n            elem.classList.add(CLASS_NAME_COLLAPSED);\n          }\n          elem.setAttribute('aria-expanded', isOpen);\n        });\n      } // Static\n    }], [{\n      key: \"Default\",\n      get: function get() {\n        return Default$8;\n      }\n    }, {\n      key: \"NAME\",\n      get: function get() {\n        return NAME$9;\n      }\n    }, {\n      key: \"collapseInterface\",\n      value: function collapseInterface(element, config) {\n        var data = Collapse.getInstance(element);\n        var _config = _objectSpread(_objectSpread(_objectSpread({}, Default$8), Manipulator.getDataAttributes(element)), _typeof(config) === 'object' && config ? config : {});\n        if (!data && _config.toggle && typeof config === 'string' && /show|hide/.test(config)) {\n          _config.toggle = false;\n        }\n        if (!data) {\n          data = new Collapse(element, _config);\n        }\n        if (typeof config === 'string') {\n          if (typeof data[config] === 'undefined') {\n            throw new TypeError(\"No method named \\\"\".concat(config, \"\\\"\"));\n          }\n          data[config]();\n        }\n      }\n    }, {\n      key: \"jQueryInterface\",\n      value: function jQueryInterface(config) {\n        return this.each(function () {\n          Collapse.collapseInterface(this, config);\n        });\n      }\n    }]);\n    return Collapse;\n  }(BaseComponent);\n  /**\n   * ------------------------------------------------------------------------\n   * Data Api implementation\n   * ------------------------------------------------------------------------\n   */\n  EventHandler.on(document, EVENT_CLICK_DATA_API$4, SELECTOR_DATA_TOGGLE$4, function (event) {\n    // preventDefault only for <a> elements (which change the URL) not inside the collapsible element\n    if (event.target.tagName === 'A' || event.delegateTarget && event.delegateTarget.tagName === 'A') {\n      event.preventDefault();\n    }\n    var triggerData = Manipulator.getDataAttributes(this);\n    var selector = getSelectorFromElement(this);\n    var selectorElements = SelectorEngine.find(selector);\n    selectorElements.forEach(function (element) {\n      var data = Collapse.getInstance(element);\n      var config;\n      if (data) {\n        // update parent attribute\n        if (data._parent === null && typeof triggerData.parent === 'string') {\n          data._config.parent = triggerData.parent;\n          data._parent = data._getParent();\n        }\n        config = 'toggle';\n      } else {\n        config = triggerData;\n      }\n      Collapse.collapseInterface(element, config);\n    });\n  });\n  /**\n   * ------------------------------------------------------------------------\n   * jQuery\n   * ------------------------------------------------------------------------\n   * add .Collapse to jQuery only if jQuery is present\n   */\n\n  defineJQueryPlugin(Collapse);\n  var top = 'top';\n  var bottom = 'bottom';\n  var right = 'right';\n  var left = 'left';\n  var auto = 'auto';\n  var basePlacements = [top, bottom, right, left];\n  var start = 'start';\n  var end = 'end';\n  var clippingParents = 'clippingParents';\n  var viewport = 'viewport';\n  var popper = 'popper';\n  var reference = 'reference';\n  var variationPlacements = /*#__PURE__*/basePlacements.reduce(function (acc, placement) {\n    return acc.concat([placement + \"-\" + start, placement + \"-\" + end]);\n  }, []);\n  var placements = /*#__PURE__*/[].concat(basePlacements, [auto]).reduce(function (acc, placement) {\n    return acc.concat([placement, placement + \"-\" + start, placement + \"-\" + end]);\n  }, []); // modifiers that need to read the DOM\n\n  var beforeRead = 'beforeRead';\n  var read = 'read';\n  var afterRead = 'afterRead'; // pure-logic modifiers\n\n  var beforeMain = 'beforeMain';\n  var main = 'main';\n  var afterMain = 'afterMain'; // modifier with the purpose to write to the DOM (or write into a framework state)\n\n  var beforeWrite = 'beforeWrite';\n  var write = 'write';\n  var afterWrite = 'afterWrite';\n  var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];\n  function getNodeName(element) {\n    return element ? (element.nodeName || '').toLowerCase() : null;\n  }\n  function getWindow(node) {\n    if (node == null) {\n      return window;\n    }\n    if (node.toString() !== '[object Window]') {\n      var ownerDocument = node.ownerDocument;\n      return ownerDocument ? ownerDocument.defaultView || window : window;\n    }\n    return node;\n  }\n  function isElement(node) {\n    var OwnElement = getWindow(node).Element;\n    return node instanceof OwnElement || node instanceof Element;\n  }\n  function isHTMLElement(node) {\n    var OwnElement = getWindow(node).HTMLElement;\n    return node instanceof OwnElement || node instanceof HTMLElement;\n  }\n  function isShadowRoot(node) {\n    // IE 11 has no ShadowRoot\n    if (typeof ShadowRoot === 'undefined') {\n      return false;\n    }\n    var OwnElement = getWindow(node).ShadowRoot;\n    return node instanceof OwnElement || node instanceof ShadowRoot;\n  }\n\n  // and applies them to the HTMLElements such as popper and arrow\n\n  function applyStyles(_ref) {\n    var state = _ref.state;\n    Object.keys(state.elements).forEach(function (name) {\n      var style = state.styles[name] || {};\n      var attributes = state.attributes[name] || {};\n      var element = state.elements[name]; // arrow is optional + virtual elements\n\n      if (!isHTMLElement(element) || !getNodeName(element)) {\n        return;\n      } // Flow doesn't support to extend this property, but it's the most\n      // effective way to apply styles to an HTMLElement\n      // $FlowFixMe[cannot-write]\n\n      Object.assign(element.style, style);\n      Object.keys(attributes).forEach(function (name) {\n        var value = attributes[name];\n        if (value === false) {\n          element.removeAttribute(name);\n        } else {\n          element.setAttribute(name, value === true ? '' : value);\n        }\n      });\n    });\n  }\n  function effect$2(_ref2) {\n    var state = _ref2.state;\n    var initialStyles = {\n      popper: {\n        position: state.options.strategy,\n        left: '0',\n        top: '0',\n        margin: '0'\n      },\n      arrow: {\n        position: 'absolute'\n      },\n      reference: {}\n    };\n    Object.assign(state.elements.popper.style, initialStyles.popper);\n    state.styles = initialStyles;\n    if (state.elements.arrow) {\n      Object.assign(state.elements.arrow.style, initialStyles.arrow);\n    }\n    return function () {\n      Object.keys(state.elements).forEach(function (name) {\n        var element = state.elements[name];\n        var attributes = state.attributes[name] || {};\n        var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]); // Set all values to an empty string to unset them\n\n        var style = styleProperties.reduce(function (style, property) {\n          style[property] = '';\n          return style;\n        }, {}); // arrow is optional + virtual elements\n\n        if (!isHTMLElement(element) || !getNodeName(element)) {\n          return;\n        }\n        Object.assign(element.style, style);\n        Object.keys(attributes).forEach(function (attribute) {\n          element.removeAttribute(attribute);\n        });\n      });\n    };\n  } // eslint-disable-next-line import/no-unused-modules\n\n  var applyStyles$1 = {\n    name: 'applyStyles',\n    enabled: true,\n    phase: 'write',\n    fn: applyStyles,\n    effect: effect$2,\n    requires: ['computeStyles']\n  };\n  function getBasePlacement(placement) {\n    return placement.split('-')[0];\n  }\n  function getBoundingClientRect(element) {\n    var rect = element.getBoundingClientRect();\n    return {\n      width: rect.width,\n      height: rect.height,\n      top: rect.top,\n      right: rect.right,\n      bottom: rect.bottom,\n      left: rect.left,\n      x: rect.left,\n      y: rect.top\n    };\n  }\n\n  // means it doesn't take into account transforms.\n\n  function getLayoutRect(element) {\n    var clientRect = getBoundingClientRect(element); // Use the clientRect sizes if it's not been transformed.\n    // Fixes https://github.com/popperjs/popper-core/issues/1223\n\n    var width = element.offsetWidth;\n    var height = element.offsetHeight;\n    if (Math.abs(clientRect.width - width) <= 1) {\n      width = clientRect.width;\n    }\n    if (Math.abs(clientRect.height - height) <= 1) {\n      height = clientRect.height;\n    }\n    return {\n      x: element.offsetLeft,\n      y: element.offsetTop,\n      width: width,\n      height: height\n    };\n  }\n  function contains(parent, child) {\n    var rootNode = child.getRootNode && child.getRootNode(); // First, attempt with faster native method\n\n    if (parent.contains(child)) {\n      return true;\n    } // then fallback to custom implementation with Shadow DOM support\n    else if (rootNode && isShadowRoot(rootNode)) {\n      var next = child;\n      do {\n        if (next && parent.isSameNode(next)) {\n          return true;\n        } // $FlowFixMe[prop-missing]: need a better way to handle this...\n\n        next = next.parentNode || next.host;\n      } while (next);\n    } // Give up, the result is false\n\n    return false;\n  }\n  function getComputedStyle$1(element) {\n    return getWindow(element).getComputedStyle(element);\n  }\n  function isTableElement(element) {\n    return ['table', 'td', 'th'].indexOf(getNodeName(element)) >= 0;\n  }\n  function getDocumentElement(element) {\n    // $FlowFixMe[incompatible-return]: assume body is always available\n    return ((isElement(element) ? element.ownerDocument :\n    // $FlowFixMe[prop-missing]\n    element.document) || window.document).documentElement;\n  }\n  function getParentNode(element) {\n    if (getNodeName(element) === 'html') {\n      return element;\n    }\n    return (\n      // this is a quicker (but less type safe) way to save quite some bytes from the bundle\n      // $FlowFixMe[incompatible-return]\n      // $FlowFixMe[prop-missing]\n      element.assignedSlot ||\n      // step into the shadow DOM of the parent of a slotted node\n      element.parentNode || (\n      // DOM Element detected\n      isShadowRoot(element) ? element.host : null) ||\n      // ShadowRoot detected\n      // $FlowFixMe[incompatible-call]: HTMLElement is a Node\n      getDocumentElement(element) // fallback\n    );\n  }\n\n  function getTrueOffsetParent(element) {\n    if (!isHTMLElement(element) ||\n    // https://github.com/popperjs/popper-core/issues/837\n    getComputedStyle$1(element).position === 'fixed') {\n      return null;\n    }\n    return element.offsetParent;\n  } // `.offsetParent` reports `null` for fixed elements, while absolute elements\n  // return the containing block\n\n  function getContainingBlock(element) {\n    var isFirefox = navigator.userAgent.toLowerCase().indexOf('firefox') !== -1;\n    var isIE = navigator.userAgent.indexOf('Trident') !== -1;\n    if (isIE && isHTMLElement(element)) {\n      // In IE 9, 10 and 11 fixed elements containing block is always established by the viewport\n      var elementCss = getComputedStyle$1(element);\n      if (elementCss.position === 'fixed') {\n        return null;\n      }\n    }\n    var currentNode = getParentNode(element);\n    while (isHTMLElement(currentNode) && ['html', 'body'].indexOf(getNodeName(currentNode)) < 0) {\n      var css = getComputedStyle$1(currentNode); // This is non-exhaustive but covers the most common CSS properties that\n      // create a containing block.\n      // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n\n      if (css.transform !== 'none' || css.perspective !== 'none' || css.contain === 'paint' || ['transform', 'perspective'].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === 'filter' || isFirefox && css.filter && css.filter !== 'none') {\n        return currentNode;\n      } else {\n        currentNode = currentNode.parentNode;\n      }\n    }\n    return null;\n  } // Gets the closest ancestor positioned element. Handles some edge cases,\n  // such as table ancestors and cross browser bugs.\n\n  function getOffsetParent(element) {\n    var window = getWindow(element);\n    var offsetParent = getTrueOffsetParent(element);\n    while (offsetParent && isTableElement(offsetParent) && getComputedStyle$1(offsetParent).position === 'static') {\n      offsetParent = getTrueOffsetParent(offsetParent);\n    }\n    if (offsetParent && (getNodeName(offsetParent) === 'html' || getNodeName(offsetParent) === 'body' && getComputedStyle$1(offsetParent).position === 'static')) {\n      return window;\n    }\n    return offsetParent || getContainingBlock(element) || window;\n  }\n  function getMainAxisFromPlacement(placement) {\n    return ['top', 'bottom'].indexOf(placement) >= 0 ? 'x' : 'y';\n  }\n  var max = Math.max;\n  var min = Math.min;\n  var round = Math.round;\n  function within(min$1, value, max$1) {\n    return max(min$1, min(value, max$1));\n  }\n  function getFreshSideObject() {\n    return {\n      top: 0,\n      right: 0,\n      bottom: 0,\n      left: 0\n    };\n  }\n  function mergePaddingObject(paddingObject) {\n    return Object.assign({}, getFreshSideObject(), paddingObject);\n  }\n  function expandToHashMap(value, keys) {\n    return keys.reduce(function (hashMap, key) {\n      hashMap[key] = value;\n      return hashMap;\n    }, {});\n  }\n  var toPaddingObject = function toPaddingObject(padding, state) {\n    padding = typeof padding === 'function' ? padding(Object.assign({}, state.rects, {\n      placement: state.placement\n    })) : padding;\n    return mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));\n  };\n  function arrow(_ref) {\n    var _state$modifiersData$;\n    var state = _ref.state,\n      name = _ref.name,\n      options = _ref.options;\n    var arrowElement = state.elements.arrow;\n    var popperOffsets = state.modifiersData.popperOffsets;\n    var basePlacement = getBasePlacement(state.placement);\n    var axis = getMainAxisFromPlacement(basePlacement);\n    var isVertical = [left, right].indexOf(basePlacement) >= 0;\n    var len = isVertical ? 'height' : 'width';\n    if (!arrowElement || !popperOffsets) {\n      return;\n    }\n    var paddingObject = toPaddingObject(options.padding, state);\n    var arrowRect = getLayoutRect(arrowElement);\n    var minProp = axis === 'y' ? top : left;\n    var maxProp = axis === 'y' ? bottom : right;\n    var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets[axis] - state.rects.popper[len];\n    var startDiff = popperOffsets[axis] - state.rects.reference[axis];\n    var arrowOffsetParent = getOffsetParent(arrowElement);\n    var clientSize = arrowOffsetParent ? axis === 'y' ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;\n    var centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn't overflow the popper if the center point is\n    // outside of the popper bounds\n\n    var min = paddingObject[minProp];\n    var max = clientSize - arrowRect[len] - paddingObject[maxProp];\n    var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;\n    var offset = within(min, center, max); // Prevents breaking syntax highlighting...\n\n    var axisProp = axis;\n    state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset, _state$modifiersData$.centerOffset = offset - center, _state$modifiersData$);\n  }\n  function effect$1(_ref2) {\n    var state = _ref2.state,\n      options = _ref2.options;\n    var _options$element = options.element,\n      arrowElement = _options$element === void 0 ? '[data-popper-arrow]' : _options$element;\n    if (arrowElement == null) {\n      return;\n    } // CSS selector\n\n    if (typeof arrowElement === 'string') {\n      arrowElement = state.elements.popper.querySelector(arrowElement);\n      if (!arrowElement) {\n        return;\n      }\n    }\n    if (!contains(state.elements.popper, arrowElement)) {\n      return;\n    }\n    state.elements.arrow = arrowElement;\n  } // eslint-disable-next-line import/no-unused-modules\n\n  var arrow$1 = {\n    name: 'arrow',\n    enabled: true,\n    phase: 'main',\n    fn: arrow,\n    effect: effect$1,\n    requires: ['popperOffsets'],\n    requiresIfExists: ['preventOverflow']\n  };\n  var unsetSides = {\n    top: 'auto',\n    right: 'auto',\n    bottom: 'auto',\n    left: 'auto'\n  }; // Round the offsets to the nearest suitable subpixel based on the DPR.\n  // Zooming can change the DPR, but it seems to report a value that will\n  // cleanly divide the values into the appropriate subpixels.\n\n  function roundOffsetsByDPR(_ref) {\n    var x = _ref.x,\n      y = _ref.y;\n    var win = window;\n    var dpr = win.devicePixelRatio || 1;\n    return {\n      x: round(round(x * dpr) / dpr) || 0,\n      y: round(round(y * dpr) / dpr) || 0\n    };\n  }\n  function mapToStyles(_ref2) {\n    var _Object$assign2;\n    var popper = _ref2.popper,\n      popperRect = _ref2.popperRect,\n      placement = _ref2.placement,\n      offsets = _ref2.offsets,\n      position = _ref2.position,\n      gpuAcceleration = _ref2.gpuAcceleration,\n      adaptive = _ref2.adaptive,\n      roundOffsets = _ref2.roundOffsets;\n    var _ref3 = roundOffsets === true ? roundOffsetsByDPR(offsets) : typeof roundOffsets === 'function' ? roundOffsets(offsets) : offsets,\n      _ref3$x = _ref3.x,\n      x = _ref3$x === void 0 ? 0 : _ref3$x,\n      _ref3$y = _ref3.y,\n      y = _ref3$y === void 0 ? 0 : _ref3$y;\n    var hasX = offsets.hasOwnProperty('x');\n    var hasY = offsets.hasOwnProperty('y');\n    var sideX = left;\n    var sideY = top;\n    var win = window;\n    if (adaptive) {\n      var offsetParent = getOffsetParent(popper);\n      var heightProp = 'clientHeight';\n      var widthProp = 'clientWidth';\n      if (offsetParent === getWindow(popper)) {\n        offsetParent = getDocumentElement(popper);\n        if (getComputedStyle$1(offsetParent).position !== 'static') {\n          heightProp = 'scrollHeight';\n          widthProp = 'scrollWidth';\n        }\n      } // $FlowFixMe[incompatible-cast]: force type refinement, we compare offsetParent with window above, but Flow doesn't detect it\n\n      offsetParent = offsetParent;\n      if (placement === top) {\n        sideY = bottom; // $FlowFixMe[prop-missing]\n\n        y -= offsetParent[heightProp] - popperRect.height;\n        y *= gpuAcceleration ? 1 : -1;\n      }\n      if (placement === left) {\n        sideX = right; // $FlowFixMe[prop-missing]\n\n        x -= offsetParent[widthProp] - popperRect.width;\n        x *= gpuAcceleration ? 1 : -1;\n      }\n    }\n    var commonStyles = Object.assign({\n      position: position\n    }, adaptive && unsetSides);\n    if (gpuAcceleration) {\n      var _Object$assign;\n      return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? '0' : '', _Object$assign[sideX] = hasX ? '0' : '', _Object$assign.transform = (win.devicePixelRatio || 1) < 2 ? \"translate(\" + x + \"px, \" + y + \"px)\" : \"translate3d(\" + x + \"px, \" + y + \"px, 0)\", _Object$assign));\n    }\n    return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + \"px\" : '', _Object$assign2[sideX] = hasX ? x + \"px\" : '', _Object$assign2.transform = '', _Object$assign2));\n  }\n  function computeStyles(_ref4) {\n    var state = _ref4.state,\n      options = _ref4.options;\n    var _options$gpuAccelerat = options.gpuAcceleration,\n      gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat,\n      _options$adaptive = options.adaptive,\n      adaptive = _options$adaptive === void 0 ? true : _options$adaptive,\n      _options$roundOffsets = options.roundOffsets,\n      roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;\n    var commonStyles = {\n      placement: getBasePlacement(state.placement),\n      popper: state.elements.popper,\n      popperRect: state.rects.popper,\n      gpuAcceleration: gpuAcceleration\n    };\n    if (state.modifiersData.popperOffsets != null) {\n      state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {\n        offsets: state.modifiersData.popperOffsets,\n        position: state.options.strategy,\n        adaptive: adaptive,\n        roundOffsets: roundOffsets\n      })));\n    }\n    if (state.modifiersData.arrow != null) {\n      state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {\n        offsets: state.modifiersData.arrow,\n        position: 'absolute',\n        adaptive: false,\n        roundOffsets: roundOffsets\n      })));\n    }\n    state.attributes.popper = Object.assign({}, state.attributes.popper, {\n      'data-popper-placement': state.placement\n    });\n  } // eslint-disable-next-line import/no-unused-modules\n\n  var computeStyles$1 = {\n    name: 'computeStyles',\n    enabled: true,\n    phase: 'beforeWrite',\n    fn: computeStyles,\n    data: {}\n  };\n  var passive = {\n    passive: true\n  };\n  function effect(_ref) {\n    var state = _ref.state,\n      instance = _ref.instance,\n      options = _ref.options;\n    var _options$scroll = options.scroll,\n      scroll = _options$scroll === void 0 ? true : _options$scroll,\n      _options$resize = options.resize,\n      resize = _options$resize === void 0 ? true : _options$resize;\n    var window = getWindow(state.elements.popper);\n    var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);\n    if (scroll) {\n      scrollParents.forEach(function (scrollParent) {\n        scrollParent.addEventListener('scroll', instance.update, passive);\n      });\n    }\n    if (resize) {\n      window.addEventListener('resize', instance.update, passive);\n    }\n    return function () {\n      if (scroll) {\n        scrollParents.forEach(function (scrollParent) {\n          scrollParent.removeEventListener('scroll', instance.update, passive);\n        });\n      }\n      if (resize) {\n        window.removeEventListener('resize', instance.update, passive);\n      }\n    };\n  } // eslint-disable-next-line import/no-unused-modules\n\n  var eventListeners = {\n    name: 'eventListeners',\n    enabled: true,\n    phase: 'write',\n    fn: function fn() {},\n    effect: effect,\n    data: {}\n  };\n  var hash$1 = {\n    left: 'right',\n    right: 'left',\n    bottom: 'top',\n    top: 'bottom'\n  };\n  function getOppositePlacement(placement) {\n    return placement.replace(/left|right|bottom|top/g, function (matched) {\n      return hash$1[matched];\n    });\n  }\n  var hash = {\n    start: 'end',\n    end: 'start'\n  };\n  function getOppositeVariationPlacement(placement) {\n    return placement.replace(/start|end/g, function (matched) {\n      return hash[matched];\n    });\n  }\n  function getWindowScroll(node) {\n    var win = getWindow(node);\n    var scrollLeft = win.pageXOffset;\n    var scrollTop = win.pageYOffset;\n    return {\n      scrollLeft: scrollLeft,\n      scrollTop: scrollTop\n    };\n  }\n  function getWindowScrollBarX(element) {\n    // If <html> has a CSS width greater than the viewport, then this will be\n    // incorrect for RTL.\n    // Popper 1 is broken in this case and never had a bug report so let's assume\n    // it's not an issue. I don't think anyone ever specifies width on <html>\n    // anyway.\n    // Browsers where the left scrollbar doesn't cause an issue report `0` for\n    // this (e.g. Edge 2019, IE11, Safari)\n    return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;\n  }\n  function getViewportRect(element) {\n    var win = getWindow(element);\n    var html = getDocumentElement(element);\n    var visualViewport = win.visualViewport;\n    var width = html.clientWidth;\n    var height = html.clientHeight;\n    var x = 0;\n    var y = 0; // NB: This isn't supported on iOS <= 12. If the keyboard is open, the popper\n    // can be obscured underneath it.\n    // Also, `html.clientHeight` adds the bottom bar height in Safari iOS, even\n    // if it isn't open, so if this isn't available, the popper will be detected\n    // to overflow the bottom of the screen too early.\n\n    if (visualViewport) {\n      width = visualViewport.width;\n      height = visualViewport.height; // Uses Layout Viewport (like Chrome; Safari does not currently)\n      // In Chrome, it returns a value very close to 0 (+/-) but contains rounding\n      // errors due to floating point numbers, so we need to check precision.\n      // Safari returns a number <= 0, usually < -1 when pinch-zoomed\n      // Feature detection fails in mobile emulation mode in Chrome.\n      // Math.abs(win.innerWidth / visualViewport.scale - visualViewport.width) <\n      // 0.001\n      // Fallback here: \"Not Safari\" userAgent\n\n      if (!/^((?!chrome|android).)*safari/i.test(navigator.userAgent)) {\n        x = visualViewport.offsetLeft;\n        y = visualViewport.offsetTop;\n      }\n    }\n    return {\n      width: width,\n      height: height,\n      x: x + getWindowScrollBarX(element),\n      y: y\n    };\n  }\n\n  // of the `<html>` and `<body>` rect bounds if horizontally scrollable\n\n  function getDocumentRect(element) {\n    var _element$ownerDocumen;\n    var html = getDocumentElement(element);\n    var winScroll = getWindowScroll(element);\n    var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;\n    var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);\n    var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);\n    var x = -winScroll.scrollLeft + getWindowScrollBarX(element);\n    var y = -winScroll.scrollTop;\n    if (getComputedStyle$1(body || html).direction === 'rtl') {\n      x += max(html.clientWidth, body ? body.clientWidth : 0) - width;\n    }\n    return {\n      width: width,\n      height: height,\n      x: x,\n      y: y\n    };\n  }\n  function isScrollParent(element) {\n    // Firefox wants us to check `-x` and `-y` variations as well\n    var _getComputedStyle = getComputedStyle$1(element),\n      overflow = _getComputedStyle.overflow,\n      overflowX = _getComputedStyle.overflowX,\n      overflowY = _getComputedStyle.overflowY;\n    return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);\n  }\n  function getScrollParent(node) {\n    if (['html', 'body', '#document'].indexOf(getNodeName(node)) >= 0) {\n      // $FlowFixMe[incompatible-return]: assume body is always available\n      return node.ownerDocument.body;\n    }\n    if (isHTMLElement(node) && isScrollParent(node)) {\n      return node;\n    }\n    return getScrollParent(getParentNode(node));\n  }\n\n  /*\n  given a DOM element, return the list of all scroll parents, up the list of ancesors\n  until we get to the top window object. This list is what we attach scroll listeners\n  to, because if any of these parent elements scroll, we'll need to re-calculate the\n  reference element's position.\n  */\n\n  function listScrollParents(element, list) {\n    var _element$ownerDocumen;\n    if (list === void 0) {\n      list = [];\n    }\n    var scrollParent = getScrollParent(element);\n    var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);\n    var win = getWindow(scrollParent);\n    var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;\n    var updatedList = list.concat(target);\n    return isBody ? updatedList :\n    // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here\n    updatedList.concat(listScrollParents(getParentNode(target)));\n  }\n  function rectToClientRect(rect) {\n    return Object.assign({}, rect, {\n      left: rect.x,\n      top: rect.y,\n      right: rect.x + rect.width,\n      bottom: rect.y + rect.height\n    });\n  }\n  function getInnerBoundingClientRect(element) {\n    var rect = getBoundingClientRect(element);\n    rect.top = rect.top + element.clientTop;\n    rect.left = rect.left + element.clientLeft;\n    rect.bottom = rect.top + element.clientHeight;\n    rect.right = rect.left + element.clientWidth;\n    rect.width = element.clientWidth;\n    rect.height = element.clientHeight;\n    rect.x = rect.left;\n    rect.y = rect.top;\n    return rect;\n  }\n  function getClientRectFromMixedType(element, clippingParent) {\n    return clippingParent === viewport ? rectToClientRect(getViewportRect(element)) : isHTMLElement(clippingParent) ? getInnerBoundingClientRect(clippingParent) : rectToClientRect(getDocumentRect(getDocumentElement(element)));\n  } // A \"clipping parent\" is an overflowable container with the characteristic of\n  // clipping (or hiding) overflowing elements with a position different from\n  // `initial`\n\n  function getClippingParents(element) {\n    var clippingParents = listScrollParents(getParentNode(element));\n    var canEscapeClipping = ['absolute', 'fixed'].indexOf(getComputedStyle$1(element).position) >= 0;\n    var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;\n    if (!isElement(clipperElement)) {\n      return [];\n    } // $FlowFixMe[incompatible-return]: https://github.com/facebook/flow/issues/1414\n\n    return clippingParents.filter(function (clippingParent) {\n      return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== 'body';\n    });\n  } // Gets the maximum area that the element is visible in due to any number of\n  // clipping parents\n\n  function getClippingRect(element, boundary, rootBoundary) {\n    var mainClippingParents = boundary === 'clippingParents' ? getClippingParents(element) : [].concat(boundary);\n    var clippingParents = [].concat(mainClippingParents, [rootBoundary]);\n    var firstClippingParent = clippingParents[0];\n    var clippingRect = clippingParents.reduce(function (accRect, clippingParent) {\n      var rect = getClientRectFromMixedType(element, clippingParent);\n      accRect.top = max(rect.top, accRect.top);\n      accRect.right = min(rect.right, accRect.right);\n      accRect.bottom = min(rect.bottom, accRect.bottom);\n      accRect.left = max(rect.left, accRect.left);\n      return accRect;\n    }, getClientRectFromMixedType(element, firstClippingParent));\n    clippingRect.width = clippingRect.right - clippingRect.left;\n    clippingRect.height = clippingRect.bottom - clippingRect.top;\n    clippingRect.x = clippingRect.left;\n    clippingRect.y = clippingRect.top;\n    return clippingRect;\n  }\n  function getVariation(placement) {\n    return placement.split('-')[1];\n  }\n  function computeOffsets(_ref) {\n    var reference = _ref.reference,\n      element = _ref.element,\n      placement = _ref.placement;\n    var basePlacement = placement ? getBasePlacement(placement) : null;\n    var variation = placement ? getVariation(placement) : null;\n    var commonX = reference.x + reference.width / 2 - element.width / 2;\n    var commonY = reference.y + reference.height / 2 - element.height / 2;\n    var offsets;\n    switch (basePlacement) {\n      case top:\n        offsets = {\n          x: commonX,\n          y: reference.y - element.height\n        };\n        break;\n      case bottom:\n        offsets = {\n          x: commonX,\n          y: reference.y + reference.height\n        };\n        break;\n      case right:\n        offsets = {\n          x: reference.x + reference.width,\n          y: commonY\n        };\n        break;\n      case left:\n        offsets = {\n          x: reference.x - element.width,\n          y: commonY\n        };\n        break;\n      default:\n        offsets = {\n          x: reference.x,\n          y: reference.y\n        };\n    }\n    var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;\n    if (mainAxis != null) {\n      var len = mainAxis === 'y' ? 'height' : 'width';\n      switch (variation) {\n        case start:\n          offsets[mainAxis] = offsets[mainAxis] - (reference[len] / 2 - element[len] / 2);\n          break;\n        case end:\n          offsets[mainAxis] = offsets[mainAxis] + (reference[len] / 2 - element[len] / 2);\n          break;\n      }\n    }\n    return offsets;\n  }\n  function detectOverflow(state, options) {\n    if (options === void 0) {\n      options = {};\n    }\n    var _options = options,\n      _options$placement = _options.placement,\n      placement = _options$placement === void 0 ? state.placement : _options$placement,\n      _options$boundary = _options.boundary,\n      boundary = _options$boundary === void 0 ? clippingParents : _options$boundary,\n      _options$rootBoundary = _options.rootBoundary,\n      rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary,\n      _options$elementConte = _options.elementContext,\n      elementContext = _options$elementConte === void 0 ? popper : _options$elementConte,\n      _options$altBoundary = _options.altBoundary,\n      altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary,\n      _options$padding = _options.padding,\n      padding = _options$padding === void 0 ? 0 : _options$padding;\n    var paddingObject = mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));\n    var altContext = elementContext === popper ? reference : popper;\n    var referenceElement = state.elements.reference;\n    var popperRect = state.rects.popper;\n    var element = state.elements[altBoundary ? altContext : elementContext];\n    var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary);\n    var referenceClientRect = getBoundingClientRect(referenceElement);\n    var popperOffsets = computeOffsets({\n      reference: referenceClientRect,\n      element: popperRect,\n      strategy: 'absolute',\n      placement: placement\n    });\n    var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets));\n    var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect; // positive = overflowing the clipping rect\n    // 0 or negative = within the clipping rect\n\n    var overflowOffsets = {\n      top: clippingClientRect.top - elementClientRect.top + paddingObject.top,\n      bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,\n      left: clippingClientRect.left - elementClientRect.left + paddingObject.left,\n      right: elementClientRect.right - clippingClientRect.right + paddingObject.right\n    };\n    var offsetData = state.modifiersData.offset; // Offsets can be applied only to the popper element\n\n    if (elementContext === popper && offsetData) {\n      var offset = offsetData[placement];\n      Object.keys(overflowOffsets).forEach(function (key) {\n        var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;\n        var axis = [top, bottom].indexOf(key) >= 0 ? 'y' : 'x';\n        overflowOffsets[key] += offset[axis] * multiply;\n      });\n    }\n    return overflowOffsets;\n  }\n  function computeAutoPlacement(state, options) {\n    if (options === void 0) {\n      options = {};\n    }\n    var _options = options,\n      placement = _options.placement,\n      boundary = _options.boundary,\n      rootBoundary = _options.rootBoundary,\n      padding = _options.padding,\n      flipVariations = _options.flipVariations,\n      _options$allowedAutoP = _options.allowedAutoPlacements,\n      allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;\n    var variation = getVariation(placement);\n    var placements$1 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function (placement) {\n      return getVariation(placement) === variation;\n    }) : basePlacements;\n    var allowedPlacements = placements$1.filter(function (placement) {\n      return allowedAutoPlacements.indexOf(placement) >= 0;\n    });\n    if (allowedPlacements.length === 0) {\n      allowedPlacements = placements$1;\n    } // $FlowFixMe[incompatible-type]: Flow seems to have problems with two array unions...\n\n    var overflows = allowedPlacements.reduce(function (acc, placement) {\n      acc[placement] = detectOverflow(state, {\n        placement: placement,\n        boundary: boundary,\n        rootBoundary: rootBoundary,\n        padding: padding\n      })[getBasePlacement(placement)];\n      return acc;\n    }, {});\n    return Object.keys(overflows).sort(function (a, b) {\n      return overflows[a] - overflows[b];\n    });\n  }\n  function getExpandedFallbackPlacements(placement) {\n    if (getBasePlacement(placement) === auto) {\n      return [];\n    }\n    var oppositePlacement = getOppositePlacement(placement);\n    return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];\n  }\n  function flip(_ref) {\n    var state = _ref.state,\n      options = _ref.options,\n      name = _ref.name;\n    if (state.modifiersData[name]._skip) {\n      return;\n    }\n    var _options$mainAxis = options.mainAxis,\n      checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,\n      _options$altAxis = options.altAxis,\n      checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis,\n      specifiedFallbackPlacements = options.fallbackPlacements,\n      padding = options.padding,\n      boundary = options.boundary,\n      rootBoundary = options.rootBoundary,\n      altBoundary = options.altBoundary,\n      _options$flipVariatio = options.flipVariations,\n      flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio,\n      allowedAutoPlacements = options.allowedAutoPlacements;\n    var preferredPlacement = state.options.placement;\n    var basePlacement = getBasePlacement(preferredPlacement);\n    var isBasePlacement = basePlacement === preferredPlacement;\n    var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));\n    var placements = [preferredPlacement].concat(fallbackPlacements).reduce(function (acc, placement) {\n      return acc.concat(getBasePlacement(placement) === auto ? computeAutoPlacement(state, {\n        placement: placement,\n        boundary: boundary,\n        rootBoundary: rootBoundary,\n        padding: padding,\n        flipVariations: flipVariations,\n        allowedAutoPlacements: allowedAutoPlacements\n      }) : placement);\n    }, []);\n    var referenceRect = state.rects.reference;\n    var popperRect = state.rects.popper;\n    var checksMap = new Map();\n    var makeFallbackChecks = true;\n    var firstFittingPlacement = placements[0];\n    for (var i = 0; i < placements.length; i++) {\n      var placement = placements[i];\n      var _basePlacement = getBasePlacement(placement);\n      var isStartVariation = getVariation(placement) === start;\n      var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;\n      var len = isVertical ? 'width' : 'height';\n      var overflow = detectOverflow(state, {\n        placement: placement,\n        boundary: boundary,\n        rootBoundary: rootBoundary,\n        altBoundary: altBoundary,\n        padding: padding\n      });\n      var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;\n      if (referenceRect[len] > popperRect[len]) {\n        mainVariationSide = getOppositePlacement(mainVariationSide);\n      }\n      var altVariationSide = getOppositePlacement(mainVariationSide);\n      var checks = [];\n      if (checkMainAxis) {\n        checks.push(overflow[_basePlacement] <= 0);\n      }\n      if (checkAltAxis) {\n        checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);\n      }\n      if (checks.every(function (check) {\n        return check;\n      })) {\n        firstFittingPlacement = placement;\n        makeFallbackChecks = false;\n        break;\n      }\n      checksMap.set(placement, checks);\n    }\n    if (makeFallbackChecks) {\n      // `2` may be desired in some cases – research later\n      var numberOfChecks = flipVariations ? 3 : 1;\n      var _loop = function _loop(_i) {\n        var fittingPlacement = placements.find(function (placement) {\n          var checks = checksMap.get(placement);\n          if (checks) {\n            return checks.slice(0, _i).every(function (check) {\n              return check;\n            });\n          }\n        });\n        if (fittingPlacement) {\n          firstFittingPlacement = fittingPlacement;\n          return \"break\";\n        }\n      };\n      for (var _i = numberOfChecks; _i > 0; _i--) {\n        var _ret = _loop(_i);\n        if (_ret === \"break\") break;\n      }\n    }\n    if (state.placement !== firstFittingPlacement) {\n      state.modifiersData[name]._skip = true;\n      state.placement = firstFittingPlacement;\n      state.reset = true;\n    }\n  } // eslint-disable-next-line import/no-unused-modules\n\n  var flip$1 = {\n    name: 'flip',\n    enabled: true,\n    phase: 'main',\n    fn: flip,\n    requiresIfExists: ['offset'],\n    data: {\n      _skip: false\n    }\n  };\n  function getSideOffsets(overflow, rect, preventedOffsets) {\n    if (preventedOffsets === void 0) {\n      preventedOffsets = {\n        x: 0,\n        y: 0\n      };\n    }\n    return {\n      top: overflow.top - rect.height - preventedOffsets.y,\n      right: overflow.right - rect.width + preventedOffsets.x,\n      bottom: overflow.bottom - rect.height + preventedOffsets.y,\n      left: overflow.left - rect.width - preventedOffsets.x\n    };\n  }\n  function isAnySideFullyClipped(overflow) {\n    return [top, right, bottom, left].some(function (side) {\n      return overflow[side] >= 0;\n    });\n  }\n  function hide(_ref) {\n    var state = _ref.state,\n      name = _ref.name;\n    var referenceRect = state.rects.reference;\n    var popperRect = state.rects.popper;\n    var preventedOffsets = state.modifiersData.preventOverflow;\n    var referenceOverflow = detectOverflow(state, {\n      elementContext: 'reference'\n    });\n    var popperAltOverflow = detectOverflow(state, {\n      altBoundary: true\n    });\n    var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);\n    var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);\n    var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);\n    var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);\n    state.modifiersData[name] = {\n      referenceClippingOffsets: referenceClippingOffsets,\n      popperEscapeOffsets: popperEscapeOffsets,\n      isReferenceHidden: isReferenceHidden,\n      hasPopperEscaped: hasPopperEscaped\n    };\n    state.attributes.popper = Object.assign({}, state.attributes.popper, {\n      'data-popper-reference-hidden': isReferenceHidden,\n      'data-popper-escaped': hasPopperEscaped\n    });\n  } // eslint-disable-next-line import/no-unused-modules\n\n  var hide$1 = {\n    name: 'hide',\n    enabled: true,\n    phase: 'main',\n    requiresIfExists: ['preventOverflow'],\n    fn: hide\n  };\n  function distanceAndSkiddingToXY(placement, rects, offset) {\n    var basePlacement = getBasePlacement(placement);\n    var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;\n    var _ref = typeof offset === 'function' ? offset(Object.assign({}, rects, {\n        placement: placement\n      })) : offset,\n      skidding = _ref[0],\n      distance = _ref[1];\n    skidding = skidding || 0;\n    distance = (distance || 0) * invertDistance;\n    return [left, right].indexOf(basePlacement) >= 0 ? {\n      x: distance,\n      y: skidding\n    } : {\n      x: skidding,\n      y: distance\n    };\n  }\n  function offset(_ref2) {\n    var state = _ref2.state,\n      options = _ref2.options,\n      name = _ref2.name;\n    var _options$offset = options.offset,\n      offset = _options$offset === void 0 ? [0, 0] : _options$offset;\n    var data = placements.reduce(function (acc, placement) {\n      acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset);\n      return acc;\n    }, {});\n    var _data$state$placement = data[state.placement],\n      x = _data$state$placement.x,\n      y = _data$state$placement.y;\n    if (state.modifiersData.popperOffsets != null) {\n      state.modifiersData.popperOffsets.x += x;\n      state.modifiersData.popperOffsets.y += y;\n    }\n    state.modifiersData[name] = data;\n  } // eslint-disable-next-line import/no-unused-modules\n\n  var offset$1 = {\n    name: 'offset',\n    enabled: true,\n    phase: 'main',\n    requires: ['popperOffsets'],\n    fn: offset\n  };\n  function popperOffsets(_ref) {\n    var state = _ref.state,\n      name = _ref.name;\n    // Offsets are the actual position the popper needs to have to be\n    // properly positioned near its reference element\n    // This is the most basic placement, and will be adjusted by\n    // the modifiers in the next step\n    state.modifiersData[name] = computeOffsets({\n      reference: state.rects.reference,\n      element: state.rects.popper,\n      strategy: 'absolute',\n      placement: state.placement\n    });\n  } // eslint-disable-next-line import/no-unused-modules\n\n  var popperOffsets$1 = {\n    name: 'popperOffsets',\n    enabled: true,\n    phase: 'read',\n    fn: popperOffsets,\n    data: {}\n  };\n  function getAltAxis(axis) {\n    return axis === 'x' ? 'y' : 'x';\n  }\n  function preventOverflow(_ref) {\n    var state = _ref.state,\n      options = _ref.options,\n      name = _ref.name;\n    var _options$mainAxis = options.mainAxis,\n      checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,\n      _options$altAxis = options.altAxis,\n      checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis,\n      boundary = options.boundary,\n      rootBoundary = options.rootBoundary,\n      altBoundary = options.altBoundary,\n      padding = options.padding,\n      _options$tether = options.tether,\n      tether = _options$tether === void 0 ? true : _options$tether,\n      _options$tetherOffset = options.tetherOffset,\n      tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;\n    var overflow = detectOverflow(state, {\n      boundary: boundary,\n      rootBoundary: rootBoundary,\n      padding: padding,\n      altBoundary: altBoundary\n    });\n    var basePlacement = getBasePlacement(state.placement);\n    var variation = getVariation(state.placement);\n    var isBasePlacement = !variation;\n    var mainAxis = getMainAxisFromPlacement(basePlacement);\n    var altAxis = getAltAxis(mainAxis);\n    var popperOffsets = state.modifiersData.popperOffsets;\n    var referenceRect = state.rects.reference;\n    var popperRect = state.rects.popper;\n    var tetherOffsetValue = typeof tetherOffset === 'function' ? tetherOffset(Object.assign({}, state.rects, {\n      placement: state.placement\n    })) : tetherOffset;\n    var data = {\n      x: 0,\n      y: 0\n    };\n    if (!popperOffsets) {\n      return;\n    }\n    if (checkMainAxis || checkAltAxis) {\n      var mainSide = mainAxis === 'y' ? top : left;\n      var altSide = mainAxis === 'y' ? bottom : right;\n      var len = mainAxis === 'y' ? 'height' : 'width';\n      var offset = popperOffsets[mainAxis];\n      var min$1 = popperOffsets[mainAxis] + overflow[mainSide];\n      var max$1 = popperOffsets[mainAxis] - overflow[altSide];\n      var additive = tether ? -popperRect[len] / 2 : 0;\n      var minLen = variation === start ? referenceRect[len] : popperRect[len];\n      var maxLen = variation === start ? -popperRect[len] : -referenceRect[len]; // We need to include the arrow in the calculation so the arrow doesn't go\n      // outside the reference bounds\n\n      var arrowElement = state.elements.arrow;\n      var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {\n        width: 0,\n        height: 0\n      };\n      var arrowPaddingObject = state.modifiersData['arrow#persistent'] ? state.modifiersData['arrow#persistent'].padding : getFreshSideObject();\n      var arrowPaddingMin = arrowPaddingObject[mainSide];\n      var arrowPaddingMax = arrowPaddingObject[altSide]; // If the reference length is smaller than the arrow length, we don't want\n      // to include its full size in the calculation. If the reference is small\n      // and near the edge of a boundary, the popper can overflow even if the\n      // reference is not overflowing as well (e.g. virtual elements with no\n      // width or height)\n\n      var arrowLen = within(0, referenceRect[len], arrowRect[len]);\n      var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - tetherOffsetValue : minLen - arrowLen - arrowPaddingMin - tetherOffsetValue;\n      var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + tetherOffsetValue : maxLen + arrowLen + arrowPaddingMax + tetherOffsetValue;\n      var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);\n      var clientOffset = arrowOffsetParent ? mainAxis === 'y' ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;\n      var offsetModifierValue = state.modifiersData.offset ? state.modifiersData.offset[state.placement][mainAxis] : 0;\n      var tetherMin = popperOffsets[mainAxis] + minOffset - offsetModifierValue - clientOffset;\n      var tetherMax = popperOffsets[mainAxis] + maxOffset - offsetModifierValue;\n      if (checkMainAxis) {\n        var preventedOffset = within(tether ? min(min$1, tetherMin) : min$1, offset, tether ? max(max$1, tetherMax) : max$1);\n        popperOffsets[mainAxis] = preventedOffset;\n        data[mainAxis] = preventedOffset - offset;\n      }\n      if (checkAltAxis) {\n        var _mainSide = mainAxis === 'x' ? top : left;\n        var _altSide = mainAxis === 'x' ? bottom : right;\n        var _offset = popperOffsets[altAxis];\n        var _min = _offset + overflow[_mainSide];\n        var _max = _offset - overflow[_altSide];\n        var _preventedOffset = within(tether ? min(_min, tetherMin) : _min, _offset, tether ? max(_max, tetherMax) : _max);\n        popperOffsets[altAxis] = _preventedOffset;\n        data[altAxis] = _preventedOffset - _offset;\n      }\n    }\n    state.modifiersData[name] = data;\n  } // eslint-disable-next-line import/no-unused-modules\n\n  var preventOverflow$1 = {\n    name: 'preventOverflow',\n    enabled: true,\n    phase: 'main',\n    fn: preventOverflow,\n    requiresIfExists: ['offset']\n  };\n  function getHTMLElementScroll(element) {\n    return {\n      scrollLeft: element.scrollLeft,\n      scrollTop: element.scrollTop\n    };\n  }\n  function getNodeScroll(node) {\n    if (node === getWindow(node) || !isHTMLElement(node)) {\n      return getWindowScroll(node);\n    } else {\n      return getHTMLElementScroll(node);\n    }\n  }\n\n  // Composite means it takes into account transforms as well as layout.\n\n  function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {\n    if (isFixed === void 0) {\n      isFixed = false;\n    }\n    var documentElement = getDocumentElement(offsetParent);\n    var rect = getBoundingClientRect(elementOrVirtualElement);\n    var isOffsetParentAnElement = isHTMLElement(offsetParent);\n    var scroll = {\n      scrollLeft: 0,\n      scrollTop: 0\n    };\n    var offsets = {\n      x: 0,\n      y: 0\n    };\n    if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n      if (getNodeName(offsetParent) !== 'body' ||\n      // https://github.com/popperjs/popper-core/issues/1078\n      isScrollParent(documentElement)) {\n        scroll = getNodeScroll(offsetParent);\n      }\n      if (isHTMLElement(offsetParent)) {\n        offsets = getBoundingClientRect(offsetParent);\n        offsets.x += offsetParent.clientLeft;\n        offsets.y += offsetParent.clientTop;\n      } else if (documentElement) {\n        offsets.x = getWindowScrollBarX(documentElement);\n      }\n    }\n    return {\n      x: rect.left + scroll.scrollLeft - offsets.x,\n      y: rect.top + scroll.scrollTop - offsets.y,\n      width: rect.width,\n      height: rect.height\n    };\n  }\n  function order(modifiers) {\n    var map = new Map();\n    var visited = new Set();\n    var result = [];\n    modifiers.forEach(function (modifier) {\n      map.set(modifier.name, modifier);\n    }); // On visiting object, check for its dependencies and visit them recursively\n\n    function sort(modifier) {\n      visited.add(modifier.name);\n      var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);\n      requires.forEach(function (dep) {\n        if (!visited.has(dep)) {\n          var depModifier = map.get(dep);\n          if (depModifier) {\n            sort(depModifier);\n          }\n        }\n      });\n      result.push(modifier);\n    }\n    modifiers.forEach(function (modifier) {\n      if (!visited.has(modifier.name)) {\n        // check for visited object\n        sort(modifier);\n      }\n    });\n    return result;\n  }\n  function orderModifiers(modifiers) {\n    // order based on dependencies\n    var orderedModifiers = order(modifiers); // order based on phase\n\n    return modifierPhases.reduce(function (acc, phase) {\n      return acc.concat(orderedModifiers.filter(function (modifier) {\n        return modifier.phase === phase;\n      }));\n    }, []);\n  }\n  function debounce(fn) {\n    var pending;\n    return function () {\n      if (!pending) {\n        pending = new Promise(function (resolve) {\n          Promise.resolve().then(function () {\n            pending = undefined;\n            resolve(fn());\n          });\n        });\n      }\n      return pending;\n    };\n  }\n  function mergeByName(modifiers) {\n    var merged = modifiers.reduce(function (merged, current) {\n      var existing = merged[current.name];\n      merged[current.name] = existing ? Object.assign({}, existing, current, {\n        options: Object.assign({}, existing.options, current.options),\n        data: Object.assign({}, existing.data, current.data)\n      }) : current;\n      return merged;\n    }, {}); // IE11 does not support Object.values\n\n    return Object.keys(merged).map(function (key) {\n      return merged[key];\n    });\n  }\n  var DEFAULT_OPTIONS = {\n    placement: 'bottom',\n    modifiers: [],\n    strategy: 'absolute'\n  };\n  function areValidElements() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    return !args.some(function (element) {\n      return !(element && typeof element.getBoundingClientRect === 'function');\n    });\n  }\n  function popperGenerator(generatorOptions) {\n    if (generatorOptions === void 0) {\n      generatorOptions = {};\n    }\n    var _generatorOptions = generatorOptions,\n      _generatorOptions$def = _generatorOptions.defaultModifiers,\n      defaultModifiers = _generatorOptions$def === void 0 ? [] : _generatorOptions$def,\n      _generatorOptions$def2 = _generatorOptions.defaultOptions,\n      defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;\n    return function createPopper(reference, popper, options) {\n      if (options === void 0) {\n        options = defaultOptions;\n      }\n      var state = {\n        placement: 'bottom',\n        orderedModifiers: [],\n        options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),\n        modifiersData: {},\n        elements: {\n          reference: reference,\n          popper: popper\n        },\n        attributes: {},\n        styles: {}\n      };\n      var effectCleanupFns = [];\n      var isDestroyed = false;\n      var instance = {\n        state: state,\n        setOptions: function setOptions(options) {\n          cleanupModifierEffects();\n          state.options = Object.assign({}, defaultOptions, state.options, options);\n          state.scrollParents = {\n            reference: isElement(reference) ? listScrollParents(reference) : reference.contextElement ? listScrollParents(reference.contextElement) : [],\n            popper: listScrollParents(popper)\n          }; // Orders the modifiers based on their dependencies and `phase`\n          // properties\n\n          var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers, state.options.modifiers))); // Strip out disabled modifiers\n\n          state.orderedModifiers = orderedModifiers.filter(function (m) {\n            return m.enabled;\n          }); // Validate the provided modifiers so that the consumer will get warned\n\n          runModifierEffects();\n          return instance.update();\n        },\n        // Sync update – it will always be executed, even if not necessary. This\n        // is useful for low frequency updates where sync behavior simplifies the\n        // logic.\n        // For high frequency updates (e.g. `resize` and `scroll` events), always\n        // prefer the async Popper#update method\n        forceUpdate: function forceUpdate() {\n          if (isDestroyed) {\n            return;\n          }\n          var _state$elements = state.elements,\n            reference = _state$elements.reference,\n            popper = _state$elements.popper; // Don't proceed if `reference` or `popper` are not valid elements\n          // anymore\n\n          if (!areValidElements(reference, popper)) {\n            return;\n          } // Store the reference and popper rects to be read by modifiers\n\n          state.rects = {\n            reference: getCompositeRect(reference, getOffsetParent(popper), state.options.strategy === 'fixed'),\n            popper: getLayoutRect(popper)\n          }; // Modifiers have the ability to reset the current update cycle. The\n          // most common use case for this is the `flip` modifier changing the\n          // placement, which then needs to re-run all the modifiers, because the\n          // logic was previously ran for the previous placement and is therefore\n          // stale/incorrect\n\n          state.reset = false;\n          state.placement = state.options.placement; // On each update cycle, the `modifiersData` property for each modifier\n          // is filled with the initial data specified by the modifier. This means\n          // it doesn't persist and is fresh on each update.\n          // To ensure persistent data, use `${name}#persistent`\n\n          state.orderedModifiers.forEach(function (modifier) {\n            return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);\n          });\n          for (var index = 0; index < state.orderedModifiers.length; index++) {\n            if (state.reset === true) {\n              state.reset = false;\n              index = -1;\n              continue;\n            }\n            var _state$orderedModifie = state.orderedModifiers[index],\n              fn = _state$orderedModifie.fn,\n              _state$orderedModifie2 = _state$orderedModifie.options,\n              _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2,\n              name = _state$orderedModifie.name;\n            if (typeof fn === 'function') {\n              state = fn({\n                state: state,\n                options: _options,\n                name: name,\n                instance: instance\n              }) || state;\n            }\n          }\n        },\n        // Async and optimistically optimized update – it will not be executed if\n        // not necessary (debounced to run at most once-per-tick)\n        update: debounce(function () {\n          return new Promise(function (resolve) {\n            instance.forceUpdate();\n            resolve(state);\n          });\n        }),\n        destroy: function destroy() {\n          cleanupModifierEffects();\n          isDestroyed = true;\n        }\n      };\n      if (!areValidElements(reference, popper)) {\n        return instance;\n      }\n      instance.setOptions(options).then(function (state) {\n        if (!isDestroyed && options.onFirstUpdate) {\n          options.onFirstUpdate(state);\n        }\n      }); // Modifiers have the ability to execute arbitrary code before the first\n      // update cycle runs. They will be executed in the same order as the update\n      // cycle. This is useful when a modifier adds some persistent data that\n      // other modifiers need to use, but the modifier is run after the dependent\n      // one.\n\n      function runModifierEffects() {\n        state.orderedModifiers.forEach(function (_ref3) {\n          var name = _ref3.name,\n            _ref3$options = _ref3.options,\n            options = _ref3$options === void 0 ? {} : _ref3$options,\n            effect = _ref3.effect;\n          if (typeof effect === 'function') {\n            var cleanupFn = effect({\n              state: state,\n              name: name,\n              instance: instance,\n              options: options\n            });\n            var noopFn = function noopFn() {};\n            effectCleanupFns.push(cleanupFn || noopFn);\n          }\n        });\n      }\n      function cleanupModifierEffects() {\n        effectCleanupFns.forEach(function (fn) {\n          return fn();\n        });\n        effectCleanupFns = [];\n      }\n      return instance;\n    };\n  }\n  var createPopper$2 = /*#__PURE__*/popperGenerator(); // eslint-disable-next-line import/no-unused-modules\n\n  var defaultModifiers$1 = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1];\n  var createPopper$1 = /*#__PURE__*/popperGenerator({\n    defaultModifiers: defaultModifiers$1\n  }); // eslint-disable-next-line import/no-unused-modules\n\n  var defaultModifiers = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1, offset$1, flip$1, preventOverflow$1, arrow$1, hide$1];\n  var createPopper = /*#__PURE__*/popperGenerator({\n    defaultModifiers: defaultModifiers\n  }); // eslint-disable-next-line import/no-unused-modules\n\n  var Popper = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    popperGenerator: popperGenerator,\n    detectOverflow: detectOverflow,\n    createPopperBase: createPopper$2,\n    createPopper: createPopper,\n    createPopperLite: createPopper$1,\n    top: top,\n    bottom: bottom,\n    right: right,\n    left: left,\n    auto: auto,\n    basePlacements: basePlacements,\n    start: start,\n    end: end,\n    clippingParents: clippingParents,\n    viewport: viewport,\n    popper: popper,\n    reference: reference,\n    variationPlacements: variationPlacements,\n    placements: placements,\n    beforeRead: beforeRead,\n    read: read,\n    afterRead: afterRead,\n    beforeMain: beforeMain,\n    main: main,\n    afterMain: afterMain,\n    beforeWrite: beforeWrite,\n    write: write,\n    afterWrite: afterWrite,\n    modifierPhases: modifierPhases,\n    applyStyles: applyStyles$1,\n    arrow: arrow$1,\n    computeStyles: computeStyles$1,\n    eventListeners: eventListeners,\n    flip: flip$1,\n    hide: hide$1,\n    offset: offset$1,\n    popperOffsets: popperOffsets$1,\n    preventOverflow: preventOverflow$1\n  });\n\n  /**\n   * --------------------------------------------------------------------------\n   * Bootstrap (v5.0.2): dropdown.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */\n  /**\n   * ------------------------------------------------------------------------\n   * Constants\n   * ------------------------------------------------------------------------\n   */\n\n  var NAME$8 = 'dropdown';\n  var DATA_KEY$7 = 'bs.dropdown';\n  var EVENT_KEY$7 = \".\".concat(DATA_KEY$7);\n  var DATA_API_KEY$4 = '.data-api';\n  var ESCAPE_KEY$2 = 'Escape';\n  var SPACE_KEY = 'Space';\n  var TAB_KEY = 'Tab';\n  var ARROW_UP_KEY = 'ArrowUp';\n  var ARROW_DOWN_KEY = 'ArrowDown';\n  var RIGHT_MOUSE_BUTTON = 2; // MouseEvent.button value for the secondary button, usually the right button\n\n  var REGEXP_KEYDOWN = new RegExp(\"\".concat(ARROW_UP_KEY, \"|\").concat(ARROW_DOWN_KEY, \"|\").concat(ESCAPE_KEY$2));\n  var EVENT_HIDE$4 = \"hide\".concat(EVENT_KEY$7);\n  var EVENT_HIDDEN$4 = \"hidden\".concat(EVENT_KEY$7);\n  var EVENT_SHOW$4 = \"show\".concat(EVENT_KEY$7);\n  var EVENT_SHOWN$4 = \"shown\".concat(EVENT_KEY$7);\n  var EVENT_CLICK = \"click\".concat(EVENT_KEY$7);\n  var EVENT_CLICK_DATA_API$3 = \"click\".concat(EVENT_KEY$7).concat(DATA_API_KEY$4);\n  var EVENT_KEYDOWN_DATA_API = \"keydown\".concat(EVENT_KEY$7).concat(DATA_API_KEY$4);\n  var EVENT_KEYUP_DATA_API = \"keyup\".concat(EVENT_KEY$7).concat(DATA_API_KEY$4);\n  var CLASS_NAME_SHOW$7 = 'show';\n  var CLASS_NAME_DROPUP = 'dropup';\n  var CLASS_NAME_DROPEND = 'dropend';\n  var CLASS_NAME_DROPSTART = 'dropstart';\n  var CLASS_NAME_NAVBAR = 'navbar';\n  var SELECTOR_DATA_TOGGLE$3 = '[data-bs-toggle=\"dropdown\"]';\n  var SELECTOR_MENU = '.dropdown-menu';\n  var SELECTOR_NAVBAR_NAV = '.navbar-nav';\n  var SELECTOR_VISIBLE_ITEMS = '.dropdown-menu .dropdown-item:not(.disabled):not(:disabled)';\n  var PLACEMENT_TOP = isRTL() ? 'top-end' : 'top-start';\n  var PLACEMENT_TOPEND = isRTL() ? 'top-start' : 'top-end';\n  var PLACEMENT_BOTTOM = isRTL() ? 'bottom-end' : 'bottom-start';\n  var PLACEMENT_BOTTOMEND = isRTL() ? 'bottom-start' : 'bottom-end';\n  var PLACEMENT_RIGHT = isRTL() ? 'left-start' : 'right-start';\n  var PLACEMENT_LEFT = isRTL() ? 'right-start' : 'left-start';\n  var Default$7 = {\n    offset: [0, 2],\n    boundary: 'clippingParents',\n    reference: 'toggle',\n    display: 'dynamic',\n    popperConfig: null,\n    autoClose: true\n  };\n  var DefaultType$7 = {\n    offset: '(array|string|function)',\n    boundary: '(string|element)',\n    reference: '(string|element|object)',\n    display: 'string',\n    popperConfig: '(null|object|function)',\n    autoClose: '(boolean|string)'\n  };\n  /**\n   * ------------------------------------------------------------------------\n   * Class Definition\n   * ------------------------------------------------------------------------\n   */\n  var Dropdown = /*#__PURE__*/function (_BaseComponent5) {\n    _inherits(Dropdown, _BaseComponent5);\n    var _super5 = _createSuper(Dropdown);\n    function Dropdown(element, config) {\n      var _this12;\n      _classCallCheck(this, Dropdown);\n      _this12 = _super5.call(this, element);\n      _this12._popper = null;\n      _this12._config = _this12._getConfig(config);\n      _this12._menu = _this12._getMenuElement();\n      _this12._inNavbar = _this12._detectNavbar();\n      _this12._addEventListeners();\n      return _this12;\n    } // Getters\n    _createClass(Dropdown, [{\n      key: \"toggle\",\n      value:\n      // Public\n\n      function toggle() {\n        if (isDisabled(this._element)) {\n          return;\n        }\n        var isActive = this._element.classList.contains(CLASS_NAME_SHOW$7);\n        if (isActive) {\n          this.hide();\n          return;\n        }\n        this.show();\n      }\n    }, {\n      key: \"show\",\n      value: function show() {\n        if (isDisabled(this._element) || this._menu.classList.contains(CLASS_NAME_SHOW$7)) {\n          return;\n        }\n        var parent = Dropdown.getParentFromElement(this._element);\n        var relatedTarget = {\n          relatedTarget: this._element\n        };\n        var showEvent = EventHandler.trigger(this._element, EVENT_SHOW$4, relatedTarget);\n        if (showEvent.defaultPrevented) {\n          return;\n        } // Totally disable Popper for Dropdowns in Navbar\n\n        if (this._inNavbar) {\n          Manipulator.setDataAttribute(this._menu, 'popper', 'none');\n        } else {\n          if (typeof Popper === 'undefined') {\n            throw new TypeError('Bootstrap\\'s dropdowns require Popper (https://popper.js.org)');\n          }\n          var referenceElement = this._element;\n          if (this._config.reference === 'parent') {\n            referenceElement = parent;\n          } else if (isElement$1(this._config.reference)) {\n            referenceElement = getElement(this._config.reference);\n          } else if (_typeof(this._config.reference) === 'object') {\n            referenceElement = this._config.reference;\n          }\n          var popperConfig = this._getPopperConfig();\n          var isDisplayStatic = popperConfig.modifiers.find(function (modifier) {\n            return modifier.name === 'applyStyles' && modifier.enabled === false;\n          });\n          this._popper = createPopper(referenceElement, this._menu, popperConfig);\n          if (isDisplayStatic) {\n            Manipulator.setDataAttribute(this._menu, 'popper', 'static');\n          }\n        } // If this is a touch-enabled device we add extra\n        // empty mouseover listeners to the body's immediate children;\n        // only needed because of broken event delegation on iOS\n        // https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html\n\n        if ('ontouchstart' in document.documentElement && !parent.closest(SELECTOR_NAVBAR_NAV)) {\n          var _ref8;\n          (_ref8 = []).concat.apply(_ref8, _toConsumableArray(document.body.children)).forEach(function (elem) {\n            return EventHandler.on(elem, 'mouseover', noop);\n          });\n        }\n        this._element.focus();\n        this._element.setAttribute('aria-expanded', true);\n        this._menu.classList.toggle(CLASS_NAME_SHOW$7);\n        this._element.classList.toggle(CLASS_NAME_SHOW$7);\n        EventHandler.trigger(this._element, EVENT_SHOWN$4, relatedTarget);\n      }\n    }, {\n      key: \"hide\",\n      value: function hide() {\n        if (isDisabled(this._element) || !this._menu.classList.contains(CLASS_NAME_SHOW$7)) {\n          return;\n        }\n        var relatedTarget = {\n          relatedTarget: this._element\n        };\n        this._completeHide(relatedTarget);\n      }\n    }, {\n      key: \"dispose\",\n      value: function dispose() {\n        if (this._popper) {\n          this._popper.destroy();\n        }\n        _get(_getPrototypeOf(Dropdown.prototype), \"dispose\", this).call(this);\n      }\n    }, {\n      key: \"update\",\n      value: function update() {\n        this._inNavbar = this._detectNavbar();\n        if (this._popper) {\n          this._popper.update();\n        }\n      } // Private\n    }, {\n      key: \"_addEventListeners\",\n      value: function _addEventListeners() {\n        var _this13 = this;\n        EventHandler.on(this._element, EVENT_CLICK, function (event) {\n          event.preventDefault();\n          _this13.toggle();\n        });\n      }\n    }, {\n      key: \"_completeHide\",\n      value: function _completeHide(relatedTarget) {\n        var hideEvent = EventHandler.trigger(this._element, EVENT_HIDE$4, relatedTarget);\n        if (hideEvent.defaultPrevented) {\n          return;\n        } // If this is a touch-enabled device we remove the extra\n        // empty mouseover listeners we added for iOS support\n\n        if ('ontouchstart' in document.documentElement) {\n          var _ref9;\n          (_ref9 = []).concat.apply(_ref9, _toConsumableArray(document.body.children)).forEach(function (elem) {\n            return EventHandler.off(elem, 'mouseover', noop);\n          });\n        }\n        if (this._popper) {\n          this._popper.destroy();\n        }\n        this._menu.classList.remove(CLASS_NAME_SHOW$7);\n        this._element.classList.remove(CLASS_NAME_SHOW$7);\n        this._element.setAttribute('aria-expanded', 'false');\n        Manipulator.removeDataAttribute(this._menu, 'popper');\n        EventHandler.trigger(this._element, EVENT_HIDDEN$4, relatedTarget);\n      }\n    }, {\n      key: \"_getConfig\",\n      value: function _getConfig(config) {\n        config = _objectSpread(_objectSpread(_objectSpread({}, this.constructor.Default), Manipulator.getDataAttributes(this._element)), config);\n        typeCheckConfig(NAME$8, config, this.constructor.DefaultType);\n        if (_typeof(config.reference) === 'object' && !isElement$1(config.reference) && typeof config.reference.getBoundingClientRect !== 'function') {\n          // Popper virtual elements require a getBoundingClientRect method\n          throw new TypeError(\"\".concat(NAME$8.toUpperCase(), \": Option \\\"reference\\\" provided type \\\"object\\\" without a required \\\"getBoundingClientRect\\\" method.\"));\n        }\n        return config;\n      }\n    }, {\n      key: \"_getMenuElement\",\n      value: function _getMenuElement() {\n        return SelectorEngine.next(this._element, SELECTOR_MENU)[0];\n      }\n    }, {\n      key: \"_getPlacement\",\n      value: function _getPlacement() {\n        var parentDropdown = this._element.parentNode;\n        if (parentDropdown.classList.contains(CLASS_NAME_DROPEND)) {\n          return PLACEMENT_RIGHT;\n        }\n        if (parentDropdown.classList.contains(CLASS_NAME_DROPSTART)) {\n          return PLACEMENT_LEFT;\n        } // We need to trim the value because custom properties can also include spaces\n\n        var isEnd = getComputedStyle(this._menu).getPropertyValue('--bs-position').trim() === 'end';\n        if (parentDropdown.classList.contains(CLASS_NAME_DROPUP)) {\n          return isEnd ? PLACEMENT_TOPEND : PLACEMENT_TOP;\n        }\n        return isEnd ? PLACEMENT_BOTTOMEND : PLACEMENT_BOTTOM;\n      }\n    }, {\n      key: \"_detectNavbar\",\n      value: function _detectNavbar() {\n        return this._element.closest(\".\".concat(CLASS_NAME_NAVBAR)) !== null;\n      }\n    }, {\n      key: \"_getOffset\",\n      value: function _getOffset() {\n        var _this14 = this;\n        var offset = this._config.offset;\n        if (typeof offset === 'string') {\n          return offset.split(',').map(function (val) {\n            return Number.parseInt(val, 10);\n          });\n        }\n        if (typeof offset === 'function') {\n          return function (popperData) {\n            return offset(popperData, _this14._element);\n          };\n        }\n        return offset;\n      }\n    }, {\n      key: \"_getPopperConfig\",\n      value: function _getPopperConfig() {\n        var defaultBsPopperConfig = {\n          placement: this._getPlacement(),\n          modifiers: [{\n            name: 'preventOverflow',\n            options: {\n              boundary: this._config.boundary\n            }\n          }, {\n            name: 'offset',\n            options: {\n              offset: this._getOffset()\n            }\n          }]\n        }; // Disable Popper if we have a static display\n\n        if (this._config.display === 'static') {\n          defaultBsPopperConfig.modifiers = [{\n            name: 'applyStyles',\n            enabled: false\n          }];\n        }\n        return _objectSpread(_objectSpread({}, defaultBsPopperConfig), typeof this._config.popperConfig === 'function' ? this._config.popperConfig(defaultBsPopperConfig) : this._config.popperConfig);\n      }\n    }, {\n      key: \"_selectMenuItem\",\n      value: function _selectMenuItem(_ref10) {\n        var key = _ref10.key,\n          target = _ref10.target;\n        var items = SelectorEngine.find(SELECTOR_VISIBLE_ITEMS, this._menu).filter(isVisible);\n        if (!items.length) {\n          return;\n        } // if target isn't included in items (e.g. when expanding the dropdown)\n        // allow cycling to get the last item in case key equals ARROW_UP_KEY\n\n        getNextActiveElement(items, target, key === ARROW_DOWN_KEY, !items.includes(target)).focus();\n      } // Static\n    }], [{\n      key: \"Default\",\n      get: function get() {\n        return Default$7;\n      }\n    }, {\n      key: \"DefaultType\",\n      get: function get() {\n        return DefaultType$7;\n      }\n    }, {\n      key: \"NAME\",\n      get: function get() {\n        return NAME$8;\n      }\n    }, {\n      key: \"dropdownInterface\",\n      value: function dropdownInterface(element, config) {\n        var data = Dropdown.getOrCreateInstance(element, config);\n        if (typeof config === 'string') {\n          if (typeof data[config] === 'undefined') {\n            throw new TypeError(\"No method named \\\"\".concat(config, \"\\\"\"));\n          }\n          data[config]();\n        }\n      }\n    }, {\n      key: \"jQueryInterface\",\n      value: function jQueryInterface(config) {\n        return this.each(function () {\n          Dropdown.dropdownInterface(this, config);\n        });\n      }\n    }, {\n      key: \"clearMenus\",\n      value: function clearMenus(event) {\n        if (event && (event.button === RIGHT_MOUSE_BUTTON || event.type === 'keyup' && event.key !== TAB_KEY)) {\n          return;\n        }\n        var toggles = SelectorEngine.find(SELECTOR_DATA_TOGGLE$3);\n        for (var i = 0, len = toggles.length; i < len; i++) {\n          var context = Dropdown.getInstance(toggles[i]);\n          if (!context || context._config.autoClose === false) {\n            continue;\n          }\n          if (!context._element.classList.contains(CLASS_NAME_SHOW$7)) {\n            continue;\n          }\n          var relatedTarget = {\n            relatedTarget: context._element\n          };\n          if (event) {\n            var composedPath = event.composedPath();\n            var isMenuTarget = composedPath.includes(context._menu);\n            if (composedPath.includes(context._element) || context._config.autoClose === 'inside' && !isMenuTarget || context._config.autoClose === 'outside' && isMenuTarget) {\n              continue;\n            } // Tab navigation through the dropdown menu or events from contained inputs shouldn't close the menu\n\n            if (context._menu.contains(event.target) && (event.type === 'keyup' && event.key === TAB_KEY || /input|select|option|textarea|form/i.test(event.target.tagName))) {\n              continue;\n            }\n            if (event.type === 'click') {\n              relatedTarget.clickEvent = event;\n            }\n          }\n          context._completeHide(relatedTarget);\n        }\n      }\n    }, {\n      key: \"getParentFromElement\",\n      value: function getParentFromElement(element) {\n        return getElementFromSelector(element) || element.parentNode;\n      }\n    }, {\n      key: \"dataApiKeydownHandler\",\n      value: function dataApiKeydownHandler(event) {\n        var _this15 = this;\n        // If not input/textarea:\n        //  - And not a key in REGEXP_KEYDOWN => not a dropdown command\n        // If input/textarea:\n        //  - If space key => not a dropdown command\n        //  - If key is other than escape\n        //    - If key is not up or down => not a dropdown command\n        //    - If trigger inside the menu => not a dropdown command\n        if (/input|textarea/i.test(event.target.tagName) ? event.key === SPACE_KEY || event.key !== ESCAPE_KEY$2 && (event.key !== ARROW_DOWN_KEY && event.key !== ARROW_UP_KEY || event.target.closest(SELECTOR_MENU)) : !REGEXP_KEYDOWN.test(event.key)) {\n          return;\n        }\n        var isActive = this.classList.contains(CLASS_NAME_SHOW$7);\n        if (!isActive && event.key === ESCAPE_KEY$2) {\n          return;\n        }\n        event.preventDefault();\n        event.stopPropagation();\n        if (isDisabled(this)) {\n          return;\n        }\n        var getToggleButton = function getToggleButton() {\n          return _this15.matches(SELECTOR_DATA_TOGGLE$3) ? _this15 : SelectorEngine.prev(_this15, SELECTOR_DATA_TOGGLE$3)[0];\n        };\n        if (event.key === ESCAPE_KEY$2) {\n          getToggleButton().focus();\n          Dropdown.clearMenus();\n          return;\n        }\n        if (event.key === ARROW_UP_KEY || event.key === ARROW_DOWN_KEY) {\n          if (!isActive) {\n            getToggleButton().click();\n          }\n          Dropdown.getInstance(getToggleButton())._selectMenuItem(event);\n          return;\n        }\n        if (!isActive || event.key === SPACE_KEY) {\n          Dropdown.clearMenus();\n        }\n      }\n    }]);\n    return Dropdown;\n  }(BaseComponent);\n  /**\n   * ------------------------------------------------------------------------\n   * Data Api implementation\n   * ------------------------------------------------------------------------\n   */\n  EventHandler.on(document, EVENT_KEYDOWN_DATA_API, SELECTOR_DATA_TOGGLE$3, Dropdown.dataApiKeydownHandler);\n  EventHandler.on(document, EVENT_KEYDOWN_DATA_API, SELECTOR_MENU, Dropdown.dataApiKeydownHandler);\n  EventHandler.on(document, EVENT_CLICK_DATA_API$3, Dropdown.clearMenus);\n  EventHandler.on(document, EVENT_KEYUP_DATA_API, Dropdown.clearMenus);\n  EventHandler.on(document, EVENT_CLICK_DATA_API$3, SELECTOR_DATA_TOGGLE$3, function (event) {\n    event.preventDefault();\n    Dropdown.dropdownInterface(this);\n  });\n  /**\n   * ------------------------------------------------------------------------\n   * jQuery\n   * ------------------------------------------------------------------------\n   * add .Dropdown to jQuery only if jQuery is present\n   */\n\n  defineJQueryPlugin(Dropdown);\n\n  /**\n   * --------------------------------------------------------------------------\n   * Bootstrap (v5.0.2): util/scrollBar.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */\n  var SELECTOR_FIXED_CONTENT = '.fixed-top, .fixed-bottom, .is-fixed, .sticky-top';\n  var SELECTOR_STICKY_CONTENT = '.sticky-top';\n  var ScrollBarHelper = /*#__PURE__*/function () {\n    function ScrollBarHelper() {\n      _classCallCheck(this, ScrollBarHelper);\n      this._element = document.body;\n    }\n    _createClass(ScrollBarHelper, [{\n      key: \"getWidth\",\n      value: function getWidth() {\n        // https://developer.mozilla.org/en-US/docs/Web/API/Window/innerWidth#usage_notes\n        var documentWidth = document.documentElement.clientWidth;\n        return Math.abs(window.innerWidth - documentWidth);\n      }\n    }, {\n      key: \"hide\",\n      value: function hide() {\n        var width = this.getWidth();\n        this._disableOverFlow(); // give padding to element to balance the hidden scrollbar width\n\n        this._setElementAttributes(this._element, 'paddingRight', function (calculatedValue) {\n          return calculatedValue + width;\n        }); // trick: We adjust positive paddingRight and negative marginRight to sticky-top elements to keep showing fullwidth\n\n        this._setElementAttributes(SELECTOR_FIXED_CONTENT, 'paddingRight', function (calculatedValue) {\n          return calculatedValue + width;\n        });\n        this._setElementAttributes(SELECTOR_STICKY_CONTENT, 'marginRight', function (calculatedValue) {\n          return calculatedValue - width;\n        });\n      }\n    }, {\n      key: \"_disableOverFlow\",\n      value: function _disableOverFlow() {\n        this._saveInitialAttribute(this._element, 'overflow');\n        this._element.style.overflow = 'hidden';\n      }\n    }, {\n      key: \"_setElementAttributes\",\n      value: function _setElementAttributes(selector, styleProp, callback) {\n        var _this16 = this;\n        var scrollbarWidth = this.getWidth();\n        var manipulationCallBack = function manipulationCallBack(element) {\n          if (element !== _this16._element && window.innerWidth > element.clientWidth + scrollbarWidth) {\n            return;\n          }\n          _this16._saveInitialAttribute(element, styleProp);\n          var calculatedValue = window.getComputedStyle(element)[styleProp];\n          element.style[styleProp] = \"\".concat(callback(Number.parseFloat(calculatedValue)), \"px\");\n        };\n        this._applyManipulationCallback(selector, manipulationCallBack);\n      }\n    }, {\n      key: \"reset\",\n      value: function reset() {\n        this._resetElementAttributes(this._element, 'overflow');\n        this._resetElementAttributes(this._element, 'paddingRight');\n        this._resetElementAttributes(SELECTOR_FIXED_CONTENT, 'paddingRight');\n        this._resetElementAttributes(SELECTOR_STICKY_CONTENT, 'marginRight');\n      }\n    }, {\n      key: \"_saveInitialAttribute\",\n      value: function _saveInitialAttribute(element, styleProp) {\n        var actualValue = element.style[styleProp];\n        if (actualValue) {\n          Manipulator.setDataAttribute(element, styleProp, actualValue);\n        }\n      }\n    }, {\n      key: \"_resetElementAttributes\",\n      value: function _resetElementAttributes(selector, styleProp) {\n        var manipulationCallBack = function manipulationCallBack(element) {\n          var value = Manipulator.getDataAttribute(element, styleProp);\n          if (typeof value === 'undefined') {\n            element.style.removeProperty(styleProp);\n          } else {\n            Manipulator.removeDataAttribute(element, styleProp);\n            element.style[styleProp] = value;\n          }\n        };\n        this._applyManipulationCallback(selector, manipulationCallBack);\n      }\n    }, {\n      key: \"_applyManipulationCallback\",\n      value: function _applyManipulationCallback(selector, callBack) {\n        if (isElement$1(selector)) {\n          callBack(selector);\n        } else {\n          SelectorEngine.find(selector, this._element).forEach(callBack);\n        }\n      }\n    }, {\n      key: \"isOverflowing\",\n      value: function isOverflowing() {\n        return this.getWidth() > 0;\n      }\n    }]);\n    return ScrollBarHelper;\n  }();\n  /**\n   * --------------------------------------------------------------------------\n   * Bootstrap (v5.0.2): util/backdrop.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n   * --------------------------------------------------------------------------\n   */\n  var Default$6 = {\n    isVisible: true,\n    // if false, we use the backdrop helper without adding any element to the dom\n    isAnimated: false,\n    rootElement: 'body',\n    // give the choice to place backdrop under different elements\n    clickCallback: null\n  };\n  var DefaultType$6 = {\n    isVisible: 'boolean',\n    isAnimated: 'boolean',\n    rootElement: '(element|string)',\n    clickCallback: '(function|null)'\n  };\n  var NAME$7 = 'backdrop';\n  var CLASS_NAME_BACKDROP = 'modal-backdrop';\n  var CLASS_NAME_FADE$5 = 'fade';\n  var CLASS_NAME_SHOW$6 = 'show';\n  var EVENT_MOUSEDOWN = \"mousedown.bs.\".concat(NAME$7);\n  var Backdrop = /*#__PURE__*/function () {\n    function Backdrop(config) {\n      _classCallCheck(this, Backdrop);\n      this._config = this._getConfig(config);\n      this._isAppended = false;\n      this._element = null;\n    }\n    _createClass(Backdrop, [{\n      key: \"show\",\n      value: function show(callback) {\n        if (!this._config.isVisible) {\n          execute(callback);\n          return;\n        }\n        this._append();\n        if (this._config.isAnimated) {\n          reflow(this._getElement());\n        }\n        this._getElement().classList.add(CLASS_NAME_SHOW$6);\n        this._emulateAnimation(function () {\n          execute(callback);\n        });\n      }\n    }, {\n      key: \"hide\",\n      value: function hide(callback) {\n        var _this17 = this;\n        if (!this._config.isVisible) {\n          execute(callback);\n          return;\n        }\n        this._getElement().classList.remove(CLASS_NAME_SHOW$6);\n        this._emulateAnimation(function () {\n          _this17.dispose();\n          execute(callback);\n        });\n      } // Private\n    }, {\n      key: \"_getElement\",\n      value: function _getElement() {\n        if (!this._element) {\n          var backdrop = document.createElement('div');\n          backdrop.className = CLASS_NAME_BACKDROP;\n          if (this._config.isAnimated) {\n            backdrop.classList.add(CLASS_NAME_FADE$5);\n          }\n          this._element = backdrop;\n        }\n        return this._element;\n      }\n    }, {\n      key: \"_getConfig\",\n      value: function _getConfig(config) {\n        config = _objectSpread(_objectSpread({}, Default$6), _typeof(config) === 'object' ? config : {}); // use getElement() with the default \"body\" to get a fresh Element on each instantiation\n\n        config.rootElement = getElement(config.rootElement);\n        typeCheckConfig(NAME$7, config, DefaultType$6);\n        return config;\n      }\n    }, {\n      key: \"_append\",\n      value: function _append() {\n        var _this18 = this;\n        if (this._isAppended) {\n          return;\n        }\n        this._config.rootElement.appendChild(this._getElement());\n        EventHandler.on(this._getElement(), EVENT_MOUSEDOWN, function () {\n          execute(_this18._config.clickCallback);\n        });\n        this._isAppended = true;\n      }\n    }, {\n      key: \"dispose\",\n      value: function dispose() {\n        if (!this._isAppended) {\n          return;\n        }\n        EventHandler.off(this._element, EVENT_MOUSEDOWN);\n        this._element.remove();\n        this._isAppended = false;\n      }\n    }, {\n      key: \"_emulateAnimation\",\n      value: function _emulateAnimation(callback) {\n        executeAfterTransition(callback, this._getElement(), this._config.isAnimated);\n      }\n    }]);\n    return Backdrop;\n  }();\n  /**\n   * --------------------------------------------------------------------------\n   * Bootstrap (v5.0.2): modal.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */\n  /**\n   * ------------------------------------------------------------------------\n   * Constants\n   * ------------------------------------------------------------------------\n   */\n  var NAME$6 = 'modal';\n  var DATA_KEY$6 = 'bs.modal';\n  var EVENT_KEY$6 = \".\".concat(DATA_KEY$6);\n  var DATA_API_KEY$3 = '.data-api';\n  var ESCAPE_KEY$1 = 'Escape';\n  var Default$5 = {\n    backdrop: true,\n    keyboard: true,\n    focus: true\n  };\n  var DefaultType$5 = {\n    backdrop: '(boolean|string)',\n    keyboard: 'boolean',\n    focus: 'boolean'\n  };\n  var EVENT_HIDE$3 = \"hide\".concat(EVENT_KEY$6);\n  var EVENT_HIDE_PREVENTED = \"hidePrevented\".concat(EVENT_KEY$6);\n  var EVENT_HIDDEN$3 = \"hidden\".concat(EVENT_KEY$6);\n  var EVENT_SHOW$3 = \"show\".concat(EVENT_KEY$6);\n  var EVENT_SHOWN$3 = \"shown\".concat(EVENT_KEY$6);\n  var EVENT_FOCUSIN$2 = \"focusin\".concat(EVENT_KEY$6);\n  var EVENT_RESIZE = \"resize\".concat(EVENT_KEY$6);\n  var EVENT_CLICK_DISMISS$2 = \"click.dismiss\".concat(EVENT_KEY$6);\n  var EVENT_KEYDOWN_DISMISS$1 = \"keydown.dismiss\".concat(EVENT_KEY$6);\n  var EVENT_MOUSEUP_DISMISS = \"mouseup.dismiss\".concat(EVENT_KEY$6);\n  var EVENT_MOUSEDOWN_DISMISS = \"mousedown.dismiss\".concat(EVENT_KEY$6);\n  var EVENT_CLICK_DATA_API$2 = \"click\".concat(EVENT_KEY$6).concat(DATA_API_KEY$3);\n  var CLASS_NAME_OPEN = 'modal-open';\n  var CLASS_NAME_FADE$4 = 'fade';\n  var CLASS_NAME_SHOW$5 = 'show';\n  var CLASS_NAME_STATIC = 'modal-static';\n  var SELECTOR_DIALOG = '.modal-dialog';\n  var SELECTOR_MODAL_BODY = '.modal-body';\n  var SELECTOR_DATA_TOGGLE$2 = '[data-bs-toggle=\"modal\"]';\n  var SELECTOR_DATA_DISMISS$2 = '[data-bs-dismiss=\"modal\"]';\n  /**\n   * ------------------------------------------------------------------------\n   * Class Definition\n   * ------------------------------------------------------------------------\n   */\n  var Modal = /*#__PURE__*/function (_BaseComponent6) {\n    _inherits(Modal, _BaseComponent6);\n    var _super6 = _createSuper(Modal);\n    function Modal(element, config) {\n      var _this19;\n      _classCallCheck(this, Modal);\n      _this19 = _super6.call(this, element);\n      _this19._config = _this19._getConfig(config);\n      _this19._dialog = SelectorEngine.findOne(SELECTOR_DIALOG, _this19._element);\n      _this19._backdrop = _this19._initializeBackDrop();\n      _this19._isShown = false;\n      _this19._ignoreBackdropClick = false;\n      _this19._isTransitioning = false;\n      _this19._scrollBar = new ScrollBarHelper();\n      return _this19;\n    } // Getters\n    _createClass(Modal, [{\n      key: \"toggle\",\n      value:\n      // Public\n\n      function toggle(relatedTarget) {\n        return this._isShown ? this.hide() : this.show(relatedTarget);\n      }\n    }, {\n      key: \"show\",\n      value: function show(relatedTarget) {\n        var _this20 = this;\n        if (this._isShown || this._isTransitioning) {\n          return;\n        }\n        var showEvent = EventHandler.trigger(this._element, EVENT_SHOW$3, {\n          relatedTarget: relatedTarget\n        });\n        if (showEvent.defaultPrevented) {\n          return;\n        }\n        this._isShown = true;\n        if (this._isAnimated()) {\n          this._isTransitioning = true;\n        }\n        this._scrollBar.hide();\n        document.body.classList.add(CLASS_NAME_OPEN);\n        this._adjustDialog();\n        this._setEscapeEvent();\n        this._setResizeEvent();\n        EventHandler.on(this._element, EVENT_CLICK_DISMISS$2, SELECTOR_DATA_DISMISS$2, function (event) {\n          return _this20.hide(event);\n        });\n        EventHandler.on(this._dialog, EVENT_MOUSEDOWN_DISMISS, function () {\n          EventHandler.one(_this20._element, EVENT_MOUSEUP_DISMISS, function (event) {\n            if (event.target === _this20._element) {\n              _this20._ignoreBackdropClick = true;\n            }\n          });\n        });\n        this._showBackdrop(function () {\n          return _this20._showElement(relatedTarget);\n        });\n      }\n    }, {\n      key: \"hide\",\n      value: function hide(event) {\n        var _this21 = this;\n        if (event && ['A', 'AREA'].includes(event.target.tagName)) {\n          event.preventDefault();\n        }\n        if (!this._isShown || this._isTransitioning) {\n          return;\n        }\n        var hideEvent = EventHandler.trigger(this._element, EVENT_HIDE$3);\n        if (hideEvent.defaultPrevented) {\n          return;\n        }\n        this._isShown = false;\n        var isAnimated = this._isAnimated();\n        if (isAnimated) {\n          this._isTransitioning = true;\n        }\n        this._setEscapeEvent();\n        this._setResizeEvent();\n        EventHandler.off(document, EVENT_FOCUSIN$2);\n        this._element.classList.remove(CLASS_NAME_SHOW$5);\n        EventHandler.off(this._element, EVENT_CLICK_DISMISS$2);\n        EventHandler.off(this._dialog, EVENT_MOUSEDOWN_DISMISS);\n        this._queueCallback(function () {\n          return _this21._hideModal();\n        }, this._element, isAnimated);\n      }\n    }, {\n      key: \"dispose\",\n      value: function dispose() {\n        [window, this._dialog].forEach(function (htmlElement) {\n          return EventHandler.off(htmlElement, EVENT_KEY$6);\n        });\n        this._backdrop.dispose();\n        _get(_getPrototypeOf(Modal.prototype), \"dispose\", this).call(this);\n        /**\n         * `document` has 2 events `EVENT_FOCUSIN` and `EVENT_CLICK_DATA_API`\n         * Do not move `document` in `htmlElements` array\n         * It will remove `EVENT_CLICK_DATA_API` event that should remain\n         */\n\n        EventHandler.off(document, EVENT_FOCUSIN$2);\n      }\n    }, {\n      key: \"handleUpdate\",\n      value: function handleUpdate() {\n        this._adjustDialog();\n      } // Private\n    }, {\n      key: \"_initializeBackDrop\",\n      value: function _initializeBackDrop() {\n        return new Backdrop({\n          isVisible: Boolean(this._config.backdrop),\n          // 'static' option will be translated to true, and booleans will keep their value\n          isAnimated: this._isAnimated()\n        });\n      }\n    }, {\n      key: \"_getConfig\",\n      value: function _getConfig(config) {\n        config = _objectSpread(_objectSpread(_objectSpread({}, Default$5), Manipulator.getDataAttributes(this._element)), _typeof(config) === 'object' ? config : {});\n        typeCheckConfig(NAME$6, config, DefaultType$5);\n        return config;\n      }\n    }, {\n      key: \"_showElement\",\n      value: function _showElement(relatedTarget) {\n        var _this22 = this;\n        var isAnimated = this._isAnimated();\n        var modalBody = SelectorEngine.findOne(SELECTOR_MODAL_BODY, this._dialog);\n        if (!this._element.parentNode || this._element.parentNode.nodeType !== Node.ELEMENT_NODE) {\n          // Don't move modal's DOM position\n          document.body.appendChild(this._element);\n        }\n        this._element.style.display = 'block';\n        this._element.removeAttribute('aria-hidden');\n        this._element.setAttribute('aria-modal', true);\n        this._element.setAttribute('role', 'dialog');\n        this._element.scrollTop = 0;\n        if (modalBody) {\n          modalBody.scrollTop = 0;\n        }\n        if (isAnimated) {\n          reflow(this._element);\n        }\n        this._element.classList.add(CLASS_NAME_SHOW$5);\n        if (this._config.focus) {\n          this._enforceFocus();\n        }\n        var transitionComplete = function transitionComplete() {\n          if (_this22._config.focus) {\n            _this22._element.focus();\n          }\n          _this22._isTransitioning = false;\n          EventHandler.trigger(_this22._element, EVENT_SHOWN$3, {\n            relatedTarget: relatedTarget\n          });\n        };\n        this._queueCallback(transitionComplete, this._dialog, isAnimated);\n      }\n    }, {\n      key: \"_enforceFocus\",\n      value: function _enforceFocus() {\n        var _this23 = this;\n        EventHandler.off(document, EVENT_FOCUSIN$2); // guard against infinite focus loop\n\n        EventHandler.on(document, EVENT_FOCUSIN$2, function (event) {\n          if (document !== event.target && _this23._element !== event.target && !_this23._element.contains(event.target)) {\n            _this23._element.focus();\n          }\n        });\n      }\n    }, {\n      key: \"_setEscapeEvent\",\n      value: function _setEscapeEvent() {\n        var _this24 = this;\n        if (this._isShown) {\n          EventHandler.on(this._element, EVENT_KEYDOWN_DISMISS$1, function (event) {\n            if (_this24._config.keyboard && event.key === ESCAPE_KEY$1) {\n              event.preventDefault();\n              _this24.hide();\n            } else if (!_this24._config.keyboard && event.key === ESCAPE_KEY$1) {\n              _this24._triggerBackdropTransition();\n            }\n          });\n        } else {\n          EventHandler.off(this._element, EVENT_KEYDOWN_DISMISS$1);\n        }\n      }\n    }, {\n      key: \"_setResizeEvent\",\n      value: function _setResizeEvent() {\n        var _this25 = this;\n        if (this._isShown) {\n          EventHandler.on(window, EVENT_RESIZE, function () {\n            return _this25._adjustDialog();\n          });\n        } else {\n          EventHandler.off(window, EVENT_RESIZE);\n        }\n      }\n    }, {\n      key: \"_hideModal\",\n      value: function _hideModal() {\n        var _this26 = this;\n        this._element.style.display = 'none';\n        this._element.setAttribute('aria-hidden', true);\n        this._element.removeAttribute('aria-modal');\n        this._element.removeAttribute('role');\n        this._isTransitioning = false;\n        this._backdrop.hide(function () {\n          document.body.classList.remove(CLASS_NAME_OPEN);\n          _this26._resetAdjustments();\n          _this26._scrollBar.reset();\n          EventHandler.trigger(_this26._element, EVENT_HIDDEN$3);\n        });\n      }\n    }, {\n      key: \"_showBackdrop\",\n      value: function _showBackdrop(callback) {\n        var _this27 = this;\n        EventHandler.on(this._element, EVENT_CLICK_DISMISS$2, function (event) {\n          if (_this27._ignoreBackdropClick) {\n            _this27._ignoreBackdropClick = false;\n            return;\n          }\n          if (event.target !== event.currentTarget) {\n            return;\n          }\n          if (_this27._config.backdrop === true) {\n            _this27.hide();\n          } else if (_this27._config.backdrop === 'static') {\n            _this27._triggerBackdropTransition();\n          }\n        });\n        this._backdrop.show(callback);\n      }\n    }, {\n      key: \"_isAnimated\",\n      value: function _isAnimated() {\n        return this._element.classList.contains(CLASS_NAME_FADE$4);\n      }\n    }, {\n      key: \"_triggerBackdropTransition\",\n      value: function _triggerBackdropTransition() {\n        var _this28 = this;\n        var hideEvent = EventHandler.trigger(this._element, EVENT_HIDE_PREVENTED);\n        if (hideEvent.defaultPrevented) {\n          return;\n        }\n        var _this$_element = this._element,\n          classList = _this$_element.classList,\n          scrollHeight = _this$_element.scrollHeight,\n          style = _this$_element.style;\n        var isModalOverflowing = scrollHeight > document.documentElement.clientHeight; // return if the following background transition hasn't yet completed\n\n        if (!isModalOverflowing && style.overflowY === 'hidden' || classList.contains(CLASS_NAME_STATIC)) {\n          return;\n        }\n        if (!isModalOverflowing) {\n          style.overflowY = 'hidden';\n        }\n        classList.add(CLASS_NAME_STATIC);\n        this._queueCallback(function () {\n          classList.remove(CLASS_NAME_STATIC);\n          if (!isModalOverflowing) {\n            _this28._queueCallback(function () {\n              style.overflowY = '';\n            }, _this28._dialog);\n          }\n        }, this._dialog);\n        this._element.focus();\n      } // ----------------------------------------------------------------------\n      // the following methods are used to handle overflowing modals\n      // ----------------------------------------------------------------------\n    }, {\n      key: \"_adjustDialog\",\n      value: function _adjustDialog() {\n        var isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;\n        var scrollbarWidth = this._scrollBar.getWidth();\n        var isBodyOverflowing = scrollbarWidth > 0;\n        if (!isBodyOverflowing && isModalOverflowing && !isRTL() || isBodyOverflowing && !isModalOverflowing && isRTL()) {\n          this._element.style.paddingLeft = \"\".concat(scrollbarWidth, \"px\");\n        }\n        if (isBodyOverflowing && !isModalOverflowing && !isRTL() || !isBodyOverflowing && isModalOverflowing && isRTL()) {\n          this._element.style.paddingRight = \"\".concat(scrollbarWidth, \"px\");\n        }\n      }\n    }, {\n      key: \"_resetAdjustments\",\n      value: function _resetAdjustments() {\n        this._element.style.paddingLeft = '';\n        this._element.style.paddingRight = '';\n      } // Static\n    }], [{\n      key: \"Default\",\n      get: function get() {\n        return Default$5;\n      }\n    }, {\n      key: \"NAME\",\n      get: function get() {\n        return NAME$6;\n      }\n    }, {\n      key: \"jQueryInterface\",\n      value: function jQueryInterface(config, relatedTarget) {\n        return this.each(function () {\n          var data = Modal.getOrCreateInstance(this, config);\n          if (typeof config !== 'string') {\n            return;\n          }\n          if (typeof data[config] === 'undefined') {\n            throw new TypeError(\"No method named \\\"\".concat(config, \"\\\"\"));\n          }\n          data[config](relatedTarget);\n        });\n      }\n    }]);\n    return Modal;\n  }(BaseComponent);\n  /**\n   * ------------------------------------------------------------------------\n   * Data Api implementation\n   * ------------------------------------------------------------------------\n   */\n  EventHandler.on(document, EVENT_CLICK_DATA_API$2, SELECTOR_DATA_TOGGLE$2, function (event) {\n    var _this29 = this;\n    var target = getElementFromSelector(this);\n    if (['A', 'AREA'].includes(this.tagName)) {\n      event.preventDefault();\n    }\n    EventHandler.one(target, EVENT_SHOW$3, function (showEvent) {\n      if (showEvent.defaultPrevented) {\n        // only register focus restorer if modal will actually get shown\n        return;\n      }\n      EventHandler.one(target, EVENT_HIDDEN$3, function () {\n        if (isVisible(_this29)) {\n          _this29.focus();\n        }\n      });\n    });\n    var data = Modal.getOrCreateInstance(target);\n    data.toggle(this);\n  });\n  /**\n   * ------------------------------------------------------------------------\n   * jQuery\n   * ------------------------------------------------------------------------\n   * add .Modal to jQuery only if jQuery is present\n   */\n\n  defineJQueryPlugin(Modal);\n\n  /**\n   * --------------------------------------------------------------------------\n   * Bootstrap (v5.0.2): offcanvas.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n   * --------------------------------------------------------------------------\n   */\n  /**\n   * ------------------------------------------------------------------------\n   * Constants\n   * ------------------------------------------------------------------------\n   */\n\n  var NAME$5 = 'offcanvas';\n  var DATA_KEY$5 = 'bs.offcanvas';\n  var EVENT_KEY$5 = \".\".concat(DATA_KEY$5);\n  var DATA_API_KEY$2 = '.data-api';\n  var EVENT_LOAD_DATA_API$1 = \"load\".concat(EVENT_KEY$5).concat(DATA_API_KEY$2);\n  var ESCAPE_KEY = 'Escape';\n  var Default$4 = {\n    backdrop: true,\n    keyboard: true,\n    scroll: false\n  };\n  var DefaultType$4 = {\n    backdrop: 'boolean',\n    keyboard: 'boolean',\n    scroll: 'boolean'\n  };\n  var CLASS_NAME_SHOW$4 = 'show';\n  var OPEN_SELECTOR = '.offcanvas.show';\n  var EVENT_SHOW$2 = \"show\".concat(EVENT_KEY$5);\n  var EVENT_SHOWN$2 = \"shown\".concat(EVENT_KEY$5);\n  var EVENT_HIDE$2 = \"hide\".concat(EVENT_KEY$5);\n  var EVENT_HIDDEN$2 = \"hidden\".concat(EVENT_KEY$5);\n  var EVENT_FOCUSIN$1 = \"focusin\".concat(EVENT_KEY$5);\n  var EVENT_CLICK_DATA_API$1 = \"click\".concat(EVENT_KEY$5).concat(DATA_API_KEY$2);\n  var EVENT_CLICK_DISMISS$1 = \"click.dismiss\".concat(EVENT_KEY$5);\n  var EVENT_KEYDOWN_DISMISS = \"keydown.dismiss\".concat(EVENT_KEY$5);\n  var SELECTOR_DATA_DISMISS$1 = '[data-bs-dismiss=\"offcanvas\"]';\n  var SELECTOR_DATA_TOGGLE$1 = '[data-bs-toggle=\"offcanvas\"]';\n  /**\n   * ------------------------------------------------------------------------\n   * Class Definition\n   * ------------------------------------------------------------------------\n   */\n  var Offcanvas = /*#__PURE__*/function (_BaseComponent7) {\n    _inherits(Offcanvas, _BaseComponent7);\n    var _super7 = _createSuper(Offcanvas);\n    function Offcanvas(element, config) {\n      var _this30;\n      _classCallCheck(this, Offcanvas);\n      _this30 = _super7.call(this, element);\n      _this30._config = _this30._getConfig(config);\n      _this30._isShown = false;\n      _this30._backdrop = _this30._initializeBackDrop();\n      _this30._addEventListeners();\n      return _this30;\n    } // Getters\n    _createClass(Offcanvas, [{\n      key: \"toggle\",\n      value:\n      // Public\n\n      function toggle(relatedTarget) {\n        return this._isShown ? this.hide() : this.show(relatedTarget);\n      }\n    }, {\n      key: \"show\",\n      value: function show(relatedTarget) {\n        var _this31 = this;\n        if (this._isShown) {\n          return;\n        }\n        var showEvent = EventHandler.trigger(this._element, EVENT_SHOW$2, {\n          relatedTarget: relatedTarget\n        });\n        if (showEvent.defaultPrevented) {\n          return;\n        }\n        this._isShown = true;\n        this._element.style.visibility = 'visible';\n        this._backdrop.show();\n        if (!this._config.scroll) {\n          new ScrollBarHelper().hide();\n          this._enforceFocusOnElement(this._element);\n        }\n        this._element.removeAttribute('aria-hidden');\n        this._element.setAttribute('aria-modal', true);\n        this._element.setAttribute('role', 'dialog');\n        this._element.classList.add(CLASS_NAME_SHOW$4);\n        var completeCallBack = function completeCallBack() {\n          EventHandler.trigger(_this31._element, EVENT_SHOWN$2, {\n            relatedTarget: relatedTarget\n          });\n        };\n        this._queueCallback(completeCallBack, this._element, true);\n      }\n    }, {\n      key: \"hide\",\n      value: function hide() {\n        var _this32 = this;\n        if (!this._isShown) {\n          return;\n        }\n        var hideEvent = EventHandler.trigger(this._element, EVENT_HIDE$2);\n        if (hideEvent.defaultPrevented) {\n          return;\n        }\n        EventHandler.off(document, EVENT_FOCUSIN$1);\n        this._element.blur();\n        this._isShown = false;\n        this._element.classList.remove(CLASS_NAME_SHOW$4);\n        this._backdrop.hide();\n        var completeCallback = function completeCallback() {\n          _this32._element.setAttribute('aria-hidden', true);\n          _this32._element.removeAttribute('aria-modal');\n          _this32._element.removeAttribute('role');\n          _this32._element.style.visibility = 'hidden';\n          if (!_this32._config.scroll) {\n            new ScrollBarHelper().reset();\n          }\n          EventHandler.trigger(_this32._element, EVENT_HIDDEN$2);\n        };\n        this._queueCallback(completeCallback, this._element, true);\n      }\n    }, {\n      key: \"dispose\",\n      value: function dispose() {\n        this._backdrop.dispose();\n        _get(_getPrototypeOf(Offcanvas.prototype), \"dispose\", this).call(this);\n        EventHandler.off(document, EVENT_FOCUSIN$1);\n      } // Private\n    }, {\n      key: \"_getConfig\",\n      value: function _getConfig(config) {\n        config = _objectSpread(_objectSpread(_objectSpread({}, Default$4), Manipulator.getDataAttributes(this._element)), _typeof(config) === 'object' ? config : {});\n        typeCheckConfig(NAME$5, config, DefaultType$4);\n        return config;\n      }\n    }, {\n      key: \"_initializeBackDrop\",\n      value: function _initializeBackDrop() {\n        var _this33 = this;\n        return new Backdrop({\n          isVisible: this._config.backdrop,\n          isAnimated: true,\n          rootElement: this._element.parentNode,\n          clickCallback: function clickCallback() {\n            return _this33.hide();\n          }\n        });\n      }\n    }, {\n      key: \"_enforceFocusOnElement\",\n      value: function _enforceFocusOnElement(element) {\n        EventHandler.off(document, EVENT_FOCUSIN$1); // guard against infinite focus loop\n\n        EventHandler.on(document, EVENT_FOCUSIN$1, function (event) {\n          if (document !== event.target && element !== event.target && !element.contains(event.target)) {\n            element.focus();\n          }\n        });\n        element.focus();\n      }\n    }, {\n      key: \"_addEventListeners\",\n      value: function _addEventListeners() {\n        var _this34 = this;\n        EventHandler.on(this._element, EVENT_CLICK_DISMISS$1, SELECTOR_DATA_DISMISS$1, function () {\n          return _this34.hide();\n        });\n        EventHandler.on(this._element, EVENT_KEYDOWN_DISMISS, function (event) {\n          if (_this34._config.keyboard && event.key === ESCAPE_KEY) {\n            _this34.hide();\n          }\n        });\n      } // Static\n    }], [{\n      key: \"NAME\",\n      get: function get() {\n        return NAME$5;\n      }\n    }, {\n      key: \"Default\",\n      get: function get() {\n        return Default$4;\n      }\n    }, {\n      key: \"jQueryInterface\",\n      value: function jQueryInterface(config) {\n        return this.each(function () {\n          var data = Offcanvas.getOrCreateInstance(this, config);\n          if (typeof config !== 'string') {\n            return;\n          }\n          if (data[config] === undefined || config.startsWith('_') || config === 'constructor') {\n            throw new TypeError(\"No method named \\\"\".concat(config, \"\\\"\"));\n          }\n          data[config](this);\n        });\n      }\n    }]);\n    return Offcanvas;\n  }(BaseComponent);\n  /**\n   * ------------------------------------------------------------------------\n   * Data Api implementation\n   * ------------------------------------------------------------------------\n   */\n  EventHandler.on(document, EVENT_CLICK_DATA_API$1, SELECTOR_DATA_TOGGLE$1, function (event) {\n    var _this35 = this;\n    var target = getElementFromSelector(this);\n    if (['A', 'AREA'].includes(this.tagName)) {\n      event.preventDefault();\n    }\n    if (isDisabled(this)) {\n      return;\n    }\n    EventHandler.one(target, EVENT_HIDDEN$2, function () {\n      // focus on trigger when it is closed\n      if (isVisible(_this35)) {\n        _this35.focus();\n      }\n    }); // avoid conflict when clicking a toggler of an offcanvas, while another is open\n\n    var allReadyOpen = SelectorEngine.findOne(OPEN_SELECTOR);\n    if (allReadyOpen && allReadyOpen !== target) {\n      Offcanvas.getInstance(allReadyOpen).hide();\n    }\n    var data = Offcanvas.getOrCreateInstance(target);\n    data.toggle(this);\n  });\n  EventHandler.on(window, EVENT_LOAD_DATA_API$1, function () {\n    return SelectorEngine.find(OPEN_SELECTOR).forEach(function (el) {\n      return Offcanvas.getOrCreateInstance(el).show();\n    });\n  });\n  /**\n   * ------------------------------------------------------------------------\n   * jQuery\n   * ------------------------------------------------------------------------\n   */\n\n  defineJQueryPlugin(Offcanvas);\n\n  /**\n   * --------------------------------------------------------------------------\n   * Bootstrap (v5.0.2): util/sanitizer.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */\n  var uriAttrs = new Set(['background', 'cite', 'href', 'itemtype', 'longdesc', 'poster', 'src', 'xlink:href']);\n  var ARIA_ATTRIBUTE_PATTERN = /^aria-[\\w-]*$/i;\n  /**\n   * A pattern that recognizes a commonly useful subset of URLs that are safe.\n   *\n   * Shoutout to Angular 7 https://github.com/angular/angular/blob/7.2.4/packages/core/src/sanitization/url_sanitizer.ts\n   */\n\n  var SAFE_URL_PATTERN = /^(?:(?:https?|mailto|ftp|tel|file):|[^#&/:?]*(?:[#/?]|$))/i;\n  /**\n   * A pattern that matches safe data URLs. Only matches image, video and audio types.\n   *\n   * Shoutout to Angular 7 https://github.com/angular/angular/blob/7.2.4/packages/core/src/sanitization/url_sanitizer.ts\n   */\n\n  var DATA_URL_PATTERN = /^data:(?:image\\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\\/(?:mpeg|mp4|ogg|webm)|audio\\/(?:mp3|oga|ogg|opus));base64,[\\d+/a-z]+=*$/i;\n  var allowedAttribute = function allowedAttribute(attr, allowedAttributeList) {\n    var attrName = attr.nodeName.toLowerCase();\n    if (allowedAttributeList.includes(attrName)) {\n      if (uriAttrs.has(attrName)) {\n        return Boolean(SAFE_URL_PATTERN.test(attr.nodeValue) || DATA_URL_PATTERN.test(attr.nodeValue));\n      }\n      return true;\n    }\n    var regExp = allowedAttributeList.filter(function (attrRegex) {\n      return attrRegex instanceof RegExp;\n    }); // Check if a regular expression validates the attribute.\n\n    for (var i = 0, len = regExp.length; i < len; i++) {\n      if (regExp[i].test(attrName)) {\n        return true;\n      }\n    }\n    return false;\n  };\n  var DefaultAllowlist = {\n    // Global attributes allowed on any supplied element below.\n    '*': ['class', 'dir', 'id', 'lang', 'role', ARIA_ATTRIBUTE_PATTERN],\n    a: ['target', 'href', 'title', 'rel'],\n    area: [],\n    b: [],\n    br: [],\n    col: [],\n    code: [],\n    div: [],\n    em: [],\n    hr: [],\n    h1: [],\n    h2: [],\n    h3: [],\n    h4: [],\n    h5: [],\n    h6: [],\n    i: [],\n    img: ['src', 'srcset', 'alt', 'title', 'width', 'height'],\n    li: [],\n    ol: [],\n    p: [],\n    pre: [],\n    s: [],\n    small: [],\n    span: [],\n    sub: [],\n    sup: [],\n    strong: [],\n    u: [],\n    ul: []\n  };\n  function sanitizeHtml(unsafeHtml, allowList, sanitizeFn) {\n    var _ref11;\n    if (!unsafeHtml.length) {\n      return unsafeHtml;\n    }\n    if (sanitizeFn && typeof sanitizeFn === 'function') {\n      return sanitizeFn(unsafeHtml);\n    }\n    var domParser = new window.DOMParser();\n    var createdDocument = domParser.parseFromString(unsafeHtml, 'text/html');\n    var allowlistKeys = Object.keys(allowList);\n    var elements = (_ref11 = []).concat.apply(_ref11, _toConsumableArray(createdDocument.body.querySelectorAll('*')));\n    var _loop2 = function _loop2() {\n      var _ref12;\n      var el = elements[i];\n      var elName = el.nodeName.toLowerCase();\n      if (!allowlistKeys.includes(elName)) {\n        el.remove();\n        return 1; // continue\n      }\n      var attributeList = (_ref12 = []).concat.apply(_ref12, _toConsumableArray(el.attributes));\n      var allowedAttributes = [].concat(allowList['*'] || [], allowList[elName] || []);\n      attributeList.forEach(function (attr) {\n        if (!allowedAttribute(attr, allowedAttributes)) {\n          el.removeAttribute(attr.nodeName);\n        }\n      });\n    };\n    for (var i = 0, len = elements.length; i < len; i++) {\n      if (_loop2()) continue;\n    }\n    return createdDocument.body.innerHTML;\n  }\n\n  /**\n   * --------------------------------------------------------------------------\n   * Bootstrap (v5.0.2): tooltip.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */\n  /**\n   * ------------------------------------------------------------------------\n   * Constants\n   * ------------------------------------------------------------------------\n   */\n\n  var NAME$4 = 'tooltip';\n  var DATA_KEY$4 = 'bs.tooltip';\n  var EVENT_KEY$4 = \".\".concat(DATA_KEY$4);\n  var CLASS_PREFIX$1 = 'bs-tooltip';\n  var BSCLS_PREFIX_REGEX$1 = new RegExp(\"(^|\\\\s)\".concat(CLASS_PREFIX$1, \"\\\\S+\"), 'g');\n  var DISALLOWED_ATTRIBUTES = new Set(['sanitize', 'allowList', 'sanitizeFn']);\n  var DefaultType$3 = {\n    animation: 'boolean',\n    template: 'string',\n    title: '(string|element|function)',\n    trigger: 'string',\n    delay: '(number|object)',\n    html: 'boolean',\n    selector: '(string|boolean)',\n    placement: '(string|function)',\n    offset: '(array|string|function)',\n    container: '(string|element|boolean)',\n    fallbackPlacements: 'array',\n    boundary: '(string|element)',\n    customClass: '(string|function)',\n    sanitize: 'boolean',\n    sanitizeFn: '(null|function)',\n    allowList: 'object',\n    popperConfig: '(null|object|function)'\n  };\n  var AttachmentMap = {\n    AUTO: 'auto',\n    TOP: 'top',\n    RIGHT: isRTL() ? 'left' : 'right',\n    BOTTOM: 'bottom',\n    LEFT: isRTL() ? 'right' : 'left'\n  };\n  var Default$3 = {\n    animation: true,\n    template: '<div class=\"tooltip\" role=\"tooltip\">' + '<div class=\"tooltip-arrow\"></div>' + '<div class=\"tooltip-inner\"></div>' + '</div>',\n    trigger: 'hover focus',\n    title: '',\n    delay: 0,\n    html: false,\n    selector: false,\n    placement: 'top',\n    offset: [0, 0],\n    container: false,\n    fallbackPlacements: ['top', 'right', 'bottom', 'left'],\n    boundary: 'clippingParents',\n    customClass: '',\n    sanitize: true,\n    sanitizeFn: null,\n    allowList: DefaultAllowlist,\n    popperConfig: null\n  };\n  var Event$2 = {\n    HIDE: \"hide\".concat(EVENT_KEY$4),\n    HIDDEN: \"hidden\".concat(EVENT_KEY$4),\n    SHOW: \"show\".concat(EVENT_KEY$4),\n    SHOWN: \"shown\".concat(EVENT_KEY$4),\n    INSERTED: \"inserted\".concat(EVENT_KEY$4),\n    CLICK: \"click\".concat(EVENT_KEY$4),\n    FOCUSIN: \"focusin\".concat(EVENT_KEY$4),\n    FOCUSOUT: \"focusout\".concat(EVENT_KEY$4),\n    MOUSEENTER: \"mouseenter\".concat(EVENT_KEY$4),\n    MOUSELEAVE: \"mouseleave\".concat(EVENT_KEY$4)\n  };\n  var CLASS_NAME_FADE$3 = 'fade';\n  var CLASS_NAME_MODAL = 'modal';\n  var CLASS_NAME_SHOW$3 = 'show';\n  var HOVER_STATE_SHOW = 'show';\n  var HOVER_STATE_OUT = 'out';\n  var SELECTOR_TOOLTIP_INNER = '.tooltip-inner';\n  var TRIGGER_HOVER = 'hover';\n  var TRIGGER_FOCUS = 'focus';\n  var TRIGGER_CLICK = 'click';\n  var TRIGGER_MANUAL = 'manual';\n  /**\n   * ------------------------------------------------------------------------\n   * Class Definition\n   * ------------------------------------------------------------------------\n   */\n  var Tooltip = /*#__PURE__*/function (_BaseComponent8) {\n    _inherits(Tooltip, _BaseComponent8);\n    var _super8 = _createSuper(Tooltip);\n    function Tooltip(element, config) {\n      var _this36;\n      _classCallCheck(this, Tooltip);\n      if (typeof Popper === 'undefined') {\n        throw new TypeError('Bootstrap\\'s tooltips require Popper (https://popper.js.org)');\n      }\n      _this36 = _super8.call(this, element); // private\n\n      _this36._isEnabled = true;\n      _this36._timeout = 0;\n      _this36._hoverState = '';\n      _this36._activeTrigger = {};\n      _this36._popper = null; // Protected\n\n      _this36._config = _this36._getConfig(config);\n      _this36.tip = null;\n      _this36._setListeners();\n      return _this36;\n    } // Getters\n    _createClass(Tooltip, [{\n      key: \"enable\",\n      value:\n      // Public\n\n      function enable() {\n        this._isEnabled = true;\n      }\n    }, {\n      key: \"disable\",\n      value: function disable() {\n        this._isEnabled = false;\n      }\n    }, {\n      key: \"toggleEnabled\",\n      value: function toggleEnabled() {\n        this._isEnabled = !this._isEnabled;\n      }\n    }, {\n      key: \"toggle\",\n      value: function toggle(event) {\n        if (!this._isEnabled) {\n          return;\n        }\n        if (event) {\n          var context = this._initializeOnDelegatedTarget(event);\n          context._activeTrigger.click = !context._activeTrigger.click;\n          if (context._isWithActiveTrigger()) {\n            context._enter(null, context);\n          } else {\n            context._leave(null, context);\n          }\n        } else {\n          if (this.getTipElement().classList.contains(CLASS_NAME_SHOW$3)) {\n            this._leave(null, this);\n            return;\n          }\n          this._enter(null, this);\n        }\n      }\n    }, {\n      key: \"dispose\",\n      value: function dispose() {\n        clearTimeout(this._timeout);\n        EventHandler.off(this._element.closest(\".\".concat(CLASS_NAME_MODAL)), 'hide.bs.modal', this._hideModalHandler);\n        if (this.tip) {\n          this.tip.remove();\n        }\n        if (this._popper) {\n          this._popper.destroy();\n        }\n        _get(_getPrototypeOf(Tooltip.prototype), \"dispose\", this).call(this);\n      }\n    }, {\n      key: \"show\",\n      value: function show() {\n        var _this37 = this;\n        if (this._element.style.display === 'none') {\n          throw new Error('Please use show on visible elements');\n        }\n        if (!(this.isWithContent() && this._isEnabled)) {\n          return;\n        }\n        var showEvent = EventHandler.trigger(this._element, this.constructor.Event.SHOW);\n        var shadowRoot = findShadowRoot(this._element);\n        var isInTheDom = shadowRoot === null ? this._element.ownerDocument.documentElement.contains(this._element) : shadowRoot.contains(this._element);\n        if (showEvent.defaultPrevented || !isInTheDom) {\n          return;\n        }\n        var tip = this.getTipElement();\n        var tipId = getUID(this.constructor.NAME);\n        tip.setAttribute('id', tipId);\n        this._element.setAttribute('aria-describedby', tipId);\n        this.setContent();\n        if (this._config.animation) {\n          tip.classList.add(CLASS_NAME_FADE$3);\n        }\n        var placement = typeof this._config.placement === 'function' ? this._config.placement.call(this, tip, this._element) : this._config.placement;\n        var attachment = this._getAttachment(placement);\n        this._addAttachmentClass(attachment);\n        var container = this._config.container;\n        Data.set(tip, this.constructor.DATA_KEY, this);\n        if (!this._element.ownerDocument.documentElement.contains(this.tip)) {\n          container.appendChild(tip);\n          EventHandler.trigger(this._element, this.constructor.Event.INSERTED);\n        }\n        if (this._popper) {\n          this._popper.update();\n        } else {\n          this._popper = createPopper(this._element, tip, this._getPopperConfig(attachment));\n        }\n        tip.classList.add(CLASS_NAME_SHOW$3);\n        var customClass = typeof this._config.customClass === 'function' ? this._config.customClass() : this._config.customClass;\n        if (customClass) {\n          var _tip$classList;\n          (_tip$classList = tip.classList).add.apply(_tip$classList, _toConsumableArray(customClass.split(' ')));\n        } // If this is a touch-enabled device we add extra\n        // empty mouseover listeners to the body's immediate children;\n        // only needed because of broken event delegation on iOS\n        // https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html\n\n        if ('ontouchstart' in document.documentElement) {\n          var _ref13;\n          (_ref13 = []).concat.apply(_ref13, _toConsumableArray(document.body.children)).forEach(function (element) {\n            EventHandler.on(element, 'mouseover', noop);\n          });\n        }\n        var complete = function complete() {\n          var prevHoverState = _this37._hoverState;\n          _this37._hoverState = null;\n          EventHandler.trigger(_this37._element, _this37.constructor.Event.SHOWN);\n          if (prevHoverState === HOVER_STATE_OUT) {\n            _this37._leave(null, _this37);\n          }\n        };\n        var isAnimated = this.tip.classList.contains(CLASS_NAME_FADE$3);\n        this._queueCallback(complete, this.tip, isAnimated);\n      }\n    }, {\n      key: \"hide\",\n      value: function hide() {\n        var _this38 = this;\n        if (!this._popper) {\n          return;\n        }\n        var tip = this.getTipElement();\n        var complete = function complete() {\n          if (_this38._isWithActiveTrigger()) {\n            return;\n          }\n          if (_this38._hoverState !== HOVER_STATE_SHOW) {\n            tip.remove();\n          }\n          _this38._cleanTipClass();\n          _this38._element.removeAttribute('aria-describedby');\n          EventHandler.trigger(_this38._element, _this38.constructor.Event.HIDDEN);\n          if (_this38._popper) {\n            _this38._popper.destroy();\n            _this38._popper = null;\n          }\n        };\n        var hideEvent = EventHandler.trigger(this._element, this.constructor.Event.HIDE);\n        if (hideEvent.defaultPrevented) {\n          return;\n        }\n        tip.classList.remove(CLASS_NAME_SHOW$3); // If this is a touch-enabled device we remove the extra\n        // empty mouseover listeners we added for iOS support\n\n        if ('ontouchstart' in document.documentElement) {\n          var _ref14;\n          (_ref14 = []).concat.apply(_ref14, _toConsumableArray(document.body.children)).forEach(function (element) {\n            return EventHandler.off(element, 'mouseover', noop);\n          });\n        }\n        this._activeTrigger[TRIGGER_CLICK] = false;\n        this._activeTrigger[TRIGGER_FOCUS] = false;\n        this._activeTrigger[TRIGGER_HOVER] = false;\n        var isAnimated = this.tip.classList.contains(CLASS_NAME_FADE$3);\n        this._queueCallback(complete, this.tip, isAnimated);\n        this._hoverState = '';\n      }\n    }, {\n      key: \"update\",\n      value: function update() {\n        if (this._popper !== null) {\n          this._popper.update();\n        }\n      } // Protected\n    }, {\n      key: \"isWithContent\",\n      value: function isWithContent() {\n        return Boolean(this.getTitle());\n      }\n    }, {\n      key: \"getTipElement\",\n      value: function getTipElement() {\n        if (this.tip) {\n          return this.tip;\n        }\n        var element = document.createElement('div');\n        element.innerHTML = this._config.template;\n        this.tip = element.children[0];\n        return this.tip;\n      }\n    }, {\n      key: \"setContent\",\n      value: function setContent() {\n        var tip = this.getTipElement();\n        this.setElementContent(SelectorEngine.findOne(SELECTOR_TOOLTIP_INNER, tip), this.getTitle());\n        tip.classList.remove(CLASS_NAME_FADE$3, CLASS_NAME_SHOW$3);\n      }\n    }, {\n      key: \"setElementContent\",\n      value: function setElementContent(element, content) {\n        if (element === null) {\n          return;\n        }\n        if (isElement$1(content)) {\n          content = getElement(content); // content is a DOM node or a jQuery\n\n          if (this._config.html) {\n            if (content.parentNode !== element) {\n              element.innerHTML = '';\n              element.appendChild(content);\n            }\n          } else {\n            element.textContent = content.textContent;\n          }\n          return;\n        }\n        if (this._config.html) {\n          if (this._config.sanitize) {\n            content = sanitizeHtml(content, this._config.allowList, this._config.sanitizeFn);\n          }\n          element.innerHTML = content;\n        } else {\n          element.textContent = content;\n        }\n      }\n    }, {\n      key: \"getTitle\",\n      value: function getTitle() {\n        var title = this._element.getAttribute('data-bs-original-title');\n        if (!title) {\n          title = typeof this._config.title === 'function' ? this._config.title.call(this._element) : this._config.title;\n        }\n        return title;\n      }\n    }, {\n      key: \"updateAttachment\",\n      value: function updateAttachment(attachment) {\n        if (attachment === 'right') {\n          return 'end';\n        }\n        if (attachment === 'left') {\n          return 'start';\n        }\n        return attachment;\n      } // Private\n    }, {\n      key: \"_initializeOnDelegatedTarget\",\n      value: function _initializeOnDelegatedTarget(event, context) {\n        var dataKey = this.constructor.DATA_KEY;\n        context = context || Data.get(event.delegateTarget, dataKey);\n        if (!context) {\n          context = new this.constructor(event.delegateTarget, this._getDelegateConfig());\n          Data.set(event.delegateTarget, dataKey, context);\n        }\n        return context;\n      }\n    }, {\n      key: \"_getOffset\",\n      value: function _getOffset() {\n        var _this39 = this;\n        var offset = this._config.offset;\n        if (typeof offset === 'string') {\n          return offset.split(',').map(function (val) {\n            return Number.parseInt(val, 10);\n          });\n        }\n        if (typeof offset === 'function') {\n          return function (popperData) {\n            return offset(popperData, _this39._element);\n          };\n        }\n        return offset;\n      }\n    }, {\n      key: \"_getPopperConfig\",\n      value: function _getPopperConfig(attachment) {\n        var _this40 = this;\n        var defaultBsPopperConfig = {\n          placement: attachment,\n          modifiers: [{\n            name: 'flip',\n            options: {\n              fallbackPlacements: this._config.fallbackPlacements\n            }\n          }, {\n            name: 'offset',\n            options: {\n              offset: this._getOffset()\n            }\n          }, {\n            name: 'preventOverflow',\n            options: {\n              boundary: this._config.boundary\n            }\n          }, {\n            name: 'arrow',\n            options: {\n              element: \".\".concat(this.constructor.NAME, \"-arrow\")\n            }\n          }, {\n            name: 'onChange',\n            enabled: true,\n            phase: 'afterWrite',\n            fn: function fn(data) {\n              return _this40._handlePopperPlacementChange(data);\n            }\n          }],\n          onFirstUpdate: function onFirstUpdate(data) {\n            if (data.options.placement !== data.placement) {\n              _this40._handlePopperPlacementChange(data);\n            }\n          }\n        };\n        return _objectSpread(_objectSpread({}, defaultBsPopperConfig), typeof this._config.popperConfig === 'function' ? this._config.popperConfig(defaultBsPopperConfig) : this._config.popperConfig);\n      }\n    }, {\n      key: \"_addAttachmentClass\",\n      value: function _addAttachmentClass(attachment) {\n        this.getTipElement().classList.add(\"\".concat(CLASS_PREFIX$1, \"-\").concat(this.updateAttachment(attachment)));\n      }\n    }, {\n      key: \"_getAttachment\",\n      value: function _getAttachment(placement) {\n        return AttachmentMap[placement.toUpperCase()];\n      }\n    }, {\n      key: \"_setListeners\",\n      value: function _setListeners() {\n        var _this41 = this;\n        var triggers = this._config.trigger.split(' ');\n        triggers.forEach(function (trigger) {\n          if (trigger === 'click') {\n            EventHandler.on(_this41._element, _this41.constructor.Event.CLICK, _this41._config.selector, function (event) {\n              return _this41.toggle(event);\n            });\n          } else if (trigger !== TRIGGER_MANUAL) {\n            var eventIn = trigger === TRIGGER_HOVER ? _this41.constructor.Event.MOUSEENTER : _this41.constructor.Event.FOCUSIN;\n            var eventOut = trigger === TRIGGER_HOVER ? _this41.constructor.Event.MOUSELEAVE : _this41.constructor.Event.FOCUSOUT;\n            EventHandler.on(_this41._element, eventIn, _this41._config.selector, function (event) {\n              return _this41._enter(event);\n            });\n            EventHandler.on(_this41._element, eventOut, _this41._config.selector, function (event) {\n              return _this41._leave(event);\n            });\n          }\n        });\n        this._hideModalHandler = function () {\n          if (_this41._element) {\n            _this41.hide();\n          }\n        };\n        EventHandler.on(this._element.closest(\".\".concat(CLASS_NAME_MODAL)), 'hide.bs.modal', this._hideModalHandler);\n        if (this._config.selector) {\n          this._config = _objectSpread(_objectSpread({}, this._config), {}, {\n            trigger: 'manual',\n            selector: ''\n          });\n        } else {\n          this._fixTitle();\n        }\n      }\n    }, {\n      key: \"_fixTitle\",\n      value: function _fixTitle() {\n        var title = this._element.getAttribute('title');\n        var originalTitleType = _typeof(this._element.getAttribute('data-bs-original-title'));\n        if (title || originalTitleType !== 'string') {\n          this._element.setAttribute('data-bs-original-title', title || '');\n          if (title && !this._element.getAttribute('aria-label') && !this._element.textContent) {\n            this._element.setAttribute('aria-label', title);\n          }\n          this._element.setAttribute('title', '');\n        }\n      }\n    }, {\n      key: \"_enter\",\n      value: function _enter(event, context) {\n        context = this._initializeOnDelegatedTarget(event, context);\n        if (event) {\n          context._activeTrigger[event.type === 'focusin' ? TRIGGER_FOCUS : TRIGGER_HOVER] = true;\n        }\n        if (context.getTipElement().classList.contains(CLASS_NAME_SHOW$3) || context._hoverState === HOVER_STATE_SHOW) {\n          context._hoverState = HOVER_STATE_SHOW;\n          return;\n        }\n        clearTimeout(context._timeout);\n        context._hoverState = HOVER_STATE_SHOW;\n        if (!context._config.delay || !context._config.delay.show) {\n          context.show();\n          return;\n        }\n        context._timeout = setTimeout(function () {\n          if (context._hoverState === HOVER_STATE_SHOW) {\n            context.show();\n          }\n        }, context._config.delay.show);\n      }\n    }, {\n      key: \"_leave\",\n      value: function _leave(event, context) {\n        context = this._initializeOnDelegatedTarget(event, context);\n        if (event) {\n          context._activeTrigger[event.type === 'focusout' ? TRIGGER_FOCUS : TRIGGER_HOVER] = context._element.contains(event.relatedTarget);\n        }\n        if (context._isWithActiveTrigger()) {\n          return;\n        }\n        clearTimeout(context._timeout);\n        context._hoverState = HOVER_STATE_OUT;\n        if (!context._config.delay || !context._config.delay.hide) {\n          context.hide();\n          return;\n        }\n        context._timeout = setTimeout(function () {\n          if (context._hoverState === HOVER_STATE_OUT) {\n            context.hide();\n          }\n        }, context._config.delay.hide);\n      }\n    }, {\n      key: \"_isWithActiveTrigger\",\n      value: function _isWithActiveTrigger() {\n        for (var trigger in this._activeTrigger) {\n          if (this._activeTrigger[trigger]) {\n            return true;\n          }\n        }\n        return false;\n      }\n    }, {\n      key: \"_getConfig\",\n      value: function _getConfig(config) {\n        var dataAttributes = Manipulator.getDataAttributes(this._element);\n        Object.keys(dataAttributes).forEach(function (dataAttr) {\n          if (DISALLOWED_ATTRIBUTES.has(dataAttr)) {\n            delete dataAttributes[dataAttr];\n          }\n        });\n        config = _objectSpread(_objectSpread(_objectSpread({}, this.constructor.Default), dataAttributes), _typeof(config) === 'object' && config ? config : {});\n        config.container = config.container === false ? document.body : getElement(config.container);\n        if (typeof config.delay === 'number') {\n          config.delay = {\n            show: config.delay,\n            hide: config.delay\n          };\n        }\n        if (typeof config.title === 'number') {\n          config.title = config.title.toString();\n        }\n        if (typeof config.content === 'number') {\n          config.content = config.content.toString();\n        }\n        typeCheckConfig(NAME$4, config, this.constructor.DefaultType);\n        if (config.sanitize) {\n          config.template = sanitizeHtml(config.template, config.allowList, config.sanitizeFn);\n        }\n        return config;\n      }\n    }, {\n      key: \"_getDelegateConfig\",\n      value: function _getDelegateConfig() {\n        var config = {};\n        if (this._config) {\n          for (var key in this._config) {\n            if (this.constructor.Default[key] !== this._config[key]) {\n              config[key] = this._config[key];\n            }\n          }\n        }\n        return config;\n      }\n    }, {\n      key: \"_cleanTipClass\",\n      value: function _cleanTipClass() {\n        var tip = this.getTipElement();\n        var tabClass = tip.getAttribute('class').match(BSCLS_PREFIX_REGEX$1);\n        if (tabClass !== null && tabClass.length > 0) {\n          tabClass.map(function (token) {\n            return token.trim();\n          }).forEach(function (tClass) {\n            return tip.classList.remove(tClass);\n          });\n        }\n      }\n    }, {\n      key: \"_handlePopperPlacementChange\",\n      value: function _handlePopperPlacementChange(popperData) {\n        var state = popperData.state;\n        if (!state) {\n          return;\n        }\n        this.tip = state.elements.popper;\n        this._cleanTipClass();\n        this._addAttachmentClass(this._getAttachment(state.placement));\n      } // Static\n    }], [{\n      key: \"Default\",\n      get: function get() {\n        return Default$3;\n      }\n    }, {\n      key: \"NAME\",\n      get: function get() {\n        return NAME$4;\n      }\n    }, {\n      key: \"Event\",\n      get: function get() {\n        return Event$2;\n      }\n    }, {\n      key: \"DefaultType\",\n      get: function get() {\n        return DefaultType$3;\n      }\n    }, {\n      key: \"jQueryInterface\",\n      value: function jQueryInterface(config) {\n        return this.each(function () {\n          var data = Tooltip.getOrCreateInstance(this, config);\n          if (typeof config === 'string') {\n            if (typeof data[config] === 'undefined') {\n              throw new TypeError(\"No method named \\\"\".concat(config, \"\\\"\"));\n            }\n            data[config]();\n          }\n        });\n      }\n    }]);\n    return Tooltip;\n  }(BaseComponent);\n  /**\n   * ------------------------------------------------------------------------\n   * jQuery\n   * ------------------------------------------------------------------------\n   * add .Tooltip to jQuery only if jQuery is present\n   */\n  defineJQueryPlugin(Tooltip);\n\n  /**\n   * --------------------------------------------------------------------------\n   * Bootstrap (v5.0.2): popover.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */\n  /**\n   * ------------------------------------------------------------------------\n   * Constants\n   * ------------------------------------------------------------------------\n   */\n\n  var NAME$3 = 'popover';\n  var DATA_KEY$3 = 'bs.popover';\n  var EVENT_KEY$3 = \".\".concat(DATA_KEY$3);\n  var CLASS_PREFIX = 'bs-popover';\n  var BSCLS_PREFIX_REGEX = new RegExp(\"(^|\\\\s)\".concat(CLASS_PREFIX, \"\\\\S+\"), 'g');\n  var Default$2 = _objectSpread(_objectSpread({}, Tooltip.Default), {}, {\n    placement: 'right',\n    offset: [0, 8],\n    trigger: 'click',\n    content: '',\n    template: '<div class=\"popover\" role=\"tooltip\">' + '<div class=\"popover-arrow\"></div>' + '<h3 class=\"popover-header\"></h3>' + '<div class=\"popover-body\"></div>' + '</div>'\n  });\n  var DefaultType$2 = _objectSpread(_objectSpread({}, Tooltip.DefaultType), {}, {\n    content: '(string|element|function)'\n  });\n  var Event$1 = {\n    HIDE: \"hide\".concat(EVENT_KEY$3),\n    HIDDEN: \"hidden\".concat(EVENT_KEY$3),\n    SHOW: \"show\".concat(EVENT_KEY$3),\n    SHOWN: \"shown\".concat(EVENT_KEY$3),\n    INSERTED: \"inserted\".concat(EVENT_KEY$3),\n    CLICK: \"click\".concat(EVENT_KEY$3),\n    FOCUSIN: \"focusin\".concat(EVENT_KEY$3),\n    FOCUSOUT: \"focusout\".concat(EVENT_KEY$3),\n    MOUSEENTER: \"mouseenter\".concat(EVENT_KEY$3),\n    MOUSELEAVE: \"mouseleave\".concat(EVENT_KEY$3)\n  };\n  var CLASS_NAME_FADE$2 = 'fade';\n  var CLASS_NAME_SHOW$2 = 'show';\n  var SELECTOR_TITLE = '.popover-header';\n  var SELECTOR_CONTENT = '.popover-body';\n  /**\n   * ------------------------------------------------------------------------\n   * Class Definition\n   * ------------------------------------------------------------------------\n   */\n  var Popover = /*#__PURE__*/function (_Tooltip) {\n    _inherits(Popover, _Tooltip);\n    var _super9 = _createSuper(Popover);\n    function Popover() {\n      _classCallCheck(this, Popover);\n      return _super9.apply(this, arguments);\n    }\n    _createClass(Popover, [{\n      key: \"isWithContent\",\n      value:\n      // Overrides\n\n      function isWithContent() {\n        return this.getTitle() || this._getContent();\n      }\n    }, {\n      key: \"getTipElement\",\n      value: function getTipElement() {\n        if (this.tip) {\n          return this.tip;\n        }\n        this.tip = _get(_getPrototypeOf(Popover.prototype), \"getTipElement\", this).call(this);\n        if (!this.getTitle()) {\n          SelectorEngine.findOne(SELECTOR_TITLE, this.tip).remove();\n        }\n        if (!this._getContent()) {\n          SelectorEngine.findOne(SELECTOR_CONTENT, this.tip).remove();\n        }\n        return this.tip;\n      }\n    }, {\n      key: \"setContent\",\n      value: function setContent() {\n        var tip = this.getTipElement(); // we use append for html objects to maintain js events\n\n        this.setElementContent(SelectorEngine.findOne(SELECTOR_TITLE, tip), this.getTitle());\n        var content = this._getContent();\n        if (typeof content === 'function') {\n          content = content.call(this._element);\n        }\n        this.setElementContent(SelectorEngine.findOne(SELECTOR_CONTENT, tip), content);\n        tip.classList.remove(CLASS_NAME_FADE$2, CLASS_NAME_SHOW$2);\n      } // Private\n    }, {\n      key: \"_addAttachmentClass\",\n      value: function _addAttachmentClass(attachment) {\n        this.getTipElement().classList.add(\"\".concat(CLASS_PREFIX, \"-\").concat(this.updateAttachment(attachment)));\n      }\n    }, {\n      key: \"_getContent\",\n      value: function _getContent() {\n        return this._element.getAttribute('data-bs-content') || this._config.content;\n      }\n    }, {\n      key: \"_cleanTipClass\",\n      value: function _cleanTipClass() {\n        var tip = this.getTipElement();\n        var tabClass = tip.getAttribute('class').match(BSCLS_PREFIX_REGEX);\n        if (tabClass !== null && tabClass.length > 0) {\n          tabClass.map(function (token) {\n            return token.trim();\n          }).forEach(function (tClass) {\n            return tip.classList.remove(tClass);\n          });\n        }\n      } // Static\n    }], [{\n      key: \"Default\",\n      get:\n      // Getters\n      function get() {\n        return Default$2;\n      }\n    }, {\n      key: \"NAME\",\n      get: function get() {\n        return NAME$3;\n      }\n    }, {\n      key: \"Event\",\n      get: function get() {\n        return Event$1;\n      }\n    }, {\n      key: \"DefaultType\",\n      get: function get() {\n        return DefaultType$2;\n      }\n    }, {\n      key: \"jQueryInterface\",\n      value: function jQueryInterface(config) {\n        return this.each(function () {\n          var data = Popover.getOrCreateInstance(this, config);\n          if (typeof config === 'string') {\n            if (typeof data[config] === 'undefined') {\n              throw new TypeError(\"No method named \\\"\".concat(config, \"\\\"\"));\n            }\n            data[config]();\n          }\n        });\n      }\n    }]);\n    return Popover;\n  }(Tooltip);\n  /**\n   * ------------------------------------------------------------------------\n   * jQuery\n   * ------------------------------------------------------------------------\n   * add .Popover to jQuery only if jQuery is present\n   */\n  defineJQueryPlugin(Popover);\n\n  /**\n   * --------------------------------------------------------------------------\n   * Bootstrap (v5.0.2): scrollspy.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */\n  /**\n   * ------------------------------------------------------------------------\n   * Constants\n   * ------------------------------------------------------------------------\n   */\n\n  var NAME$2 = 'scrollspy';\n  var DATA_KEY$2 = 'bs.scrollspy';\n  var EVENT_KEY$2 = \".\".concat(DATA_KEY$2);\n  var DATA_API_KEY$1 = '.data-api';\n  var Default$1 = {\n    offset: 10,\n    method: 'auto',\n    target: ''\n  };\n  var DefaultType$1 = {\n    offset: 'number',\n    method: 'string',\n    target: '(string|element)'\n  };\n  var EVENT_ACTIVATE = \"activate\".concat(EVENT_KEY$2);\n  var EVENT_SCROLL = \"scroll\".concat(EVENT_KEY$2);\n  var EVENT_LOAD_DATA_API = \"load\".concat(EVENT_KEY$2).concat(DATA_API_KEY$1);\n  var CLASS_NAME_DROPDOWN_ITEM = 'dropdown-item';\n  var CLASS_NAME_ACTIVE$1 = 'active';\n  var SELECTOR_DATA_SPY = '[data-bs-spy=\"scroll\"]';\n  var SELECTOR_NAV_LIST_GROUP$1 = '.nav, .list-group';\n  var SELECTOR_NAV_LINKS = '.nav-link';\n  var SELECTOR_NAV_ITEMS = '.nav-item';\n  var SELECTOR_LIST_ITEMS = '.list-group-item';\n  var SELECTOR_DROPDOWN$1 = '.dropdown';\n  var SELECTOR_DROPDOWN_TOGGLE$1 = '.dropdown-toggle';\n  var METHOD_OFFSET = 'offset';\n  var METHOD_POSITION = 'position';\n  /**\n   * ------------------------------------------------------------------------\n   * Class Definition\n   * ------------------------------------------------------------------------\n   */\n  var ScrollSpy = /*#__PURE__*/function (_BaseComponent9) {\n    _inherits(ScrollSpy, _BaseComponent9);\n    var _super10 = _createSuper(ScrollSpy);\n    function ScrollSpy(element, config) {\n      var _this42;\n      _classCallCheck(this, ScrollSpy);\n      _this42 = _super10.call(this, element);\n      _this42._scrollElement = _this42._element.tagName === 'BODY' ? window : _this42._element;\n      _this42._config = _this42._getConfig(config);\n      _this42._selector = \"\".concat(_this42._config.target, \" \").concat(SELECTOR_NAV_LINKS, \", \").concat(_this42._config.target, \" \").concat(SELECTOR_LIST_ITEMS, \", \").concat(_this42._config.target, \" .\").concat(CLASS_NAME_DROPDOWN_ITEM);\n      _this42._offsets = [];\n      _this42._targets = [];\n      _this42._activeTarget = null;\n      _this42._scrollHeight = 0;\n      EventHandler.on(_this42._scrollElement, EVENT_SCROLL, function () {\n        return _this42._process();\n      });\n      _this42.refresh();\n      _this42._process();\n      return _this42;\n    } // Getters\n    _createClass(ScrollSpy, [{\n      key: \"refresh\",\n      value:\n      // Public\n\n      function refresh() {\n        var _this43 = this;\n        var autoMethod = this._scrollElement === this._scrollElement.window ? METHOD_OFFSET : METHOD_POSITION;\n        var offsetMethod = this._config.method === 'auto' ? autoMethod : this._config.method;\n        var offsetBase = offsetMethod === METHOD_POSITION ? this._getScrollTop() : 0;\n        this._offsets = [];\n        this._targets = [];\n        this._scrollHeight = this._getScrollHeight();\n        var targets = SelectorEngine.find(this._selector);\n        targets.map(function (element) {\n          var targetSelector = getSelectorFromElement(element);\n          var target = targetSelector ? SelectorEngine.findOne(targetSelector) : null;\n          if (target) {\n            var targetBCR = target.getBoundingClientRect();\n            if (targetBCR.width || targetBCR.height) {\n              return [Manipulator[offsetMethod](target).top + offsetBase, targetSelector];\n            }\n          }\n          return null;\n        }).filter(function (item) {\n          return item;\n        }).sort(function (a, b) {\n          return a[0] - b[0];\n        }).forEach(function (item) {\n          _this43._offsets.push(item[0]);\n          _this43._targets.push(item[1]);\n        });\n      }\n    }, {\n      key: \"dispose\",\n      value: function dispose() {\n        EventHandler.off(this._scrollElement, EVENT_KEY$2);\n        _get(_getPrototypeOf(ScrollSpy.prototype), \"dispose\", this).call(this);\n      } // Private\n    }, {\n      key: \"_getConfig\",\n      value: function _getConfig(config) {\n        config = _objectSpread(_objectSpread(_objectSpread({}, Default$1), Manipulator.getDataAttributes(this._element)), _typeof(config) === 'object' && config ? config : {});\n        if (typeof config.target !== 'string' && isElement$1(config.target)) {\n          var id = config.target.id;\n          if (!id) {\n            id = getUID(NAME$2);\n            config.target.id = id;\n          }\n          config.target = \"#\".concat(id);\n        }\n        typeCheckConfig(NAME$2, config, DefaultType$1);\n        return config;\n      }\n    }, {\n      key: \"_getScrollTop\",\n      value: function _getScrollTop() {\n        return this._scrollElement === window ? this._scrollElement.pageYOffset : this._scrollElement.scrollTop;\n      }\n    }, {\n      key: \"_getScrollHeight\",\n      value: function _getScrollHeight() {\n        return this._scrollElement.scrollHeight || Math.max(document.body.scrollHeight, document.documentElement.scrollHeight);\n      }\n    }, {\n      key: \"_getOffsetHeight\",\n      value: function _getOffsetHeight() {\n        return this._scrollElement === window ? window.innerHeight : this._scrollElement.getBoundingClientRect().height;\n      }\n    }, {\n      key: \"_process\",\n      value: function _process() {\n        var scrollTop = this._getScrollTop() + this._config.offset;\n        var scrollHeight = this._getScrollHeight();\n        var maxScroll = this._config.offset + scrollHeight - this._getOffsetHeight();\n        if (this._scrollHeight !== scrollHeight) {\n          this.refresh();\n        }\n        if (scrollTop >= maxScroll) {\n          var target = this._targets[this._targets.length - 1];\n          if (this._activeTarget !== target) {\n            this._activate(target);\n          }\n          return;\n        }\n        if (this._activeTarget && scrollTop < this._offsets[0] && this._offsets[0] > 0) {\n          this._activeTarget = null;\n          this._clear();\n          return;\n        }\n        for (var i = this._offsets.length; i--;) {\n          var isActiveTarget = this._activeTarget !== this._targets[i] && scrollTop >= this._offsets[i] && (typeof this._offsets[i + 1] === 'undefined' || scrollTop < this._offsets[i + 1]);\n          if (isActiveTarget) {\n            this._activate(this._targets[i]);\n          }\n        }\n      }\n    }, {\n      key: \"_activate\",\n      value: function _activate(target) {\n        this._activeTarget = target;\n        this._clear();\n        var queries = this._selector.split(',').map(function (selector) {\n          return \"\".concat(selector, \"[data-bs-target=\\\"\").concat(target, \"\\\"],\").concat(selector, \"[href=\\\"\").concat(target, \"\\\"]\");\n        });\n        var link = SelectorEngine.findOne(queries.join(','));\n        if (link.classList.contains(CLASS_NAME_DROPDOWN_ITEM)) {\n          SelectorEngine.findOne(SELECTOR_DROPDOWN_TOGGLE$1, link.closest(SELECTOR_DROPDOWN$1)).classList.add(CLASS_NAME_ACTIVE$1);\n          link.classList.add(CLASS_NAME_ACTIVE$1);\n        } else {\n          // Set triggered link as active\n          link.classList.add(CLASS_NAME_ACTIVE$1);\n          SelectorEngine.parents(link, SELECTOR_NAV_LIST_GROUP$1).forEach(function (listGroup) {\n            // Set triggered links parents as active\n            // With both <ul> and <nav> markup a parent is the previous sibling of any nav ancestor\n            SelectorEngine.prev(listGroup, \"\".concat(SELECTOR_NAV_LINKS, \", \").concat(SELECTOR_LIST_ITEMS)).forEach(function (item) {\n              return item.classList.add(CLASS_NAME_ACTIVE$1);\n            }); // Handle special case when .nav-link is inside .nav-item\n\n            SelectorEngine.prev(listGroup, SELECTOR_NAV_ITEMS).forEach(function (navItem) {\n              SelectorEngine.children(navItem, SELECTOR_NAV_LINKS).forEach(function (item) {\n                return item.classList.add(CLASS_NAME_ACTIVE$1);\n              });\n            });\n          });\n        }\n        EventHandler.trigger(this._scrollElement, EVENT_ACTIVATE, {\n          relatedTarget: target\n        });\n      }\n    }, {\n      key: \"_clear\",\n      value: function _clear() {\n        SelectorEngine.find(this._selector).filter(function (node) {\n          return node.classList.contains(CLASS_NAME_ACTIVE$1);\n        }).forEach(function (node) {\n          return node.classList.remove(CLASS_NAME_ACTIVE$1);\n        });\n      } // Static\n    }], [{\n      key: \"Default\",\n      get: function get() {\n        return Default$1;\n      }\n    }, {\n      key: \"NAME\",\n      get: function get() {\n        return NAME$2;\n      }\n    }, {\n      key: \"jQueryInterface\",\n      value: function jQueryInterface(config) {\n        return this.each(function () {\n          var data = ScrollSpy.getOrCreateInstance(this, config);\n          if (typeof config !== 'string') {\n            return;\n          }\n          if (typeof data[config] === 'undefined') {\n            throw new TypeError(\"No method named \\\"\".concat(config, \"\\\"\"));\n          }\n          data[config]();\n        });\n      }\n    }]);\n    return ScrollSpy;\n  }(BaseComponent);\n  /**\n   * ------------------------------------------------------------------------\n   * Data Api implementation\n   * ------------------------------------------------------------------------\n   */\n  EventHandler.on(window, EVENT_LOAD_DATA_API, function () {\n    SelectorEngine.find(SELECTOR_DATA_SPY).forEach(function (spy) {\n      return new ScrollSpy(spy);\n    });\n  });\n  /**\n   * ------------------------------------------------------------------------\n   * jQuery\n   * ------------------------------------------------------------------------\n   * add .ScrollSpy to jQuery only if jQuery is present\n   */\n\n  defineJQueryPlugin(ScrollSpy);\n\n  /**\n   * --------------------------------------------------------------------------\n   * Bootstrap (v5.0.2): tab.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */\n  /**\n   * ------------------------------------------------------------------------\n   * Constants\n   * ------------------------------------------------------------------------\n   */\n\n  var NAME$1 = 'tab';\n  var DATA_KEY$1 = 'bs.tab';\n  var EVENT_KEY$1 = \".\".concat(DATA_KEY$1);\n  var DATA_API_KEY = '.data-api';\n  var EVENT_HIDE$1 = \"hide\".concat(EVENT_KEY$1);\n  var EVENT_HIDDEN$1 = \"hidden\".concat(EVENT_KEY$1);\n  var EVENT_SHOW$1 = \"show\".concat(EVENT_KEY$1);\n  var EVENT_SHOWN$1 = \"shown\".concat(EVENT_KEY$1);\n  var EVENT_CLICK_DATA_API = \"click\".concat(EVENT_KEY$1).concat(DATA_API_KEY);\n  var CLASS_NAME_DROPDOWN_MENU = 'dropdown-menu';\n  var CLASS_NAME_ACTIVE = 'active';\n  var CLASS_NAME_FADE$1 = 'fade';\n  var CLASS_NAME_SHOW$1 = 'show';\n  var SELECTOR_DROPDOWN = '.dropdown';\n  var SELECTOR_NAV_LIST_GROUP = '.nav, .list-group';\n  var SELECTOR_ACTIVE = '.active';\n  var SELECTOR_ACTIVE_UL = ':scope > li > .active';\n  var SELECTOR_DATA_TOGGLE = '[data-bs-toggle=\"tab\"], [data-bs-toggle=\"pill\"], [data-bs-toggle=\"list\"]';\n  var SELECTOR_DROPDOWN_TOGGLE = '.dropdown-toggle';\n  var SELECTOR_DROPDOWN_ACTIVE_CHILD = ':scope > .dropdown-menu .active';\n  /**\n   * ------------------------------------------------------------------------\n   * Class Definition\n   * ------------------------------------------------------------------------\n   */\n  var Tab = /*#__PURE__*/function (_BaseComponent10) {\n    _inherits(Tab, _BaseComponent10);\n    var _super11 = _createSuper(Tab);\n    function Tab() {\n      _classCallCheck(this, Tab);\n      return _super11.apply(this, arguments);\n    }\n    _createClass(Tab, [{\n      key: \"show\",\n      value:\n      // Public\n\n      function show() {\n        var _this44 = this;\n        if (this._element.parentNode && this._element.parentNode.nodeType === Node.ELEMENT_NODE && this._element.classList.contains(CLASS_NAME_ACTIVE)) {\n          return;\n        }\n        var previous;\n        var target = getElementFromSelector(this._element);\n        var listElement = this._element.closest(SELECTOR_NAV_LIST_GROUP);\n        if (listElement) {\n          var itemSelector = listElement.nodeName === 'UL' || listElement.nodeName === 'OL' ? SELECTOR_ACTIVE_UL : SELECTOR_ACTIVE;\n          previous = SelectorEngine.find(itemSelector, listElement);\n          previous = previous[previous.length - 1];\n        }\n        var hideEvent = previous ? EventHandler.trigger(previous, EVENT_HIDE$1, {\n          relatedTarget: this._element\n        }) : null;\n        var showEvent = EventHandler.trigger(this._element, EVENT_SHOW$1, {\n          relatedTarget: previous\n        });\n        if (showEvent.defaultPrevented || hideEvent !== null && hideEvent.defaultPrevented) {\n          return;\n        }\n        this._activate(this._element, listElement);\n        var complete = function complete() {\n          EventHandler.trigger(previous, EVENT_HIDDEN$1, {\n            relatedTarget: _this44._element\n          });\n          EventHandler.trigger(_this44._element, EVENT_SHOWN$1, {\n            relatedTarget: previous\n          });\n        };\n        if (target) {\n          this._activate(target, target.parentNode, complete);\n        } else {\n          complete();\n        }\n      } // Private\n    }, {\n      key: \"_activate\",\n      value: function _activate(element, container, callback) {\n        var _this45 = this;\n        var activeElements = container && (container.nodeName === 'UL' || container.nodeName === 'OL') ? SelectorEngine.find(SELECTOR_ACTIVE_UL, container) : SelectorEngine.children(container, SELECTOR_ACTIVE);\n        var active = activeElements[0];\n        var isTransitioning = callback && active && active.classList.contains(CLASS_NAME_FADE$1);\n        var complete = function complete() {\n          return _this45._transitionComplete(element, active, callback);\n        };\n        if (active && isTransitioning) {\n          active.classList.remove(CLASS_NAME_SHOW$1);\n          this._queueCallback(complete, element, true);\n        } else {\n          complete();\n        }\n      }\n    }, {\n      key: \"_transitionComplete\",\n      value: function _transitionComplete(element, active, callback) {\n        if (active) {\n          active.classList.remove(CLASS_NAME_ACTIVE);\n          var dropdownChild = SelectorEngine.findOne(SELECTOR_DROPDOWN_ACTIVE_CHILD, active.parentNode);\n          if (dropdownChild) {\n            dropdownChild.classList.remove(CLASS_NAME_ACTIVE);\n          }\n          if (active.getAttribute('role') === 'tab') {\n            active.setAttribute('aria-selected', false);\n          }\n        }\n        element.classList.add(CLASS_NAME_ACTIVE);\n        if (element.getAttribute('role') === 'tab') {\n          element.setAttribute('aria-selected', true);\n        }\n        reflow(element);\n        if (element.classList.contains(CLASS_NAME_FADE$1)) {\n          element.classList.add(CLASS_NAME_SHOW$1);\n        }\n        var parent = element.parentNode;\n        if (parent && parent.nodeName === 'LI') {\n          parent = parent.parentNode;\n        }\n        if (parent && parent.classList.contains(CLASS_NAME_DROPDOWN_MENU)) {\n          var dropdownElement = element.closest(SELECTOR_DROPDOWN);\n          if (dropdownElement) {\n            SelectorEngine.find(SELECTOR_DROPDOWN_TOGGLE, dropdownElement).forEach(function (dropdown) {\n              return dropdown.classList.add(CLASS_NAME_ACTIVE);\n            });\n          }\n          element.setAttribute('aria-expanded', true);\n        }\n        if (callback) {\n          callback();\n        }\n      } // Static\n    }], [{\n      key: \"NAME\",\n      get:\n      // Getters\n      function get() {\n        return NAME$1;\n      }\n    }, {\n      key: \"jQueryInterface\",\n      value: function jQueryInterface(config) {\n        return this.each(function () {\n          var data = Tab.getOrCreateInstance(this);\n          if (typeof config === 'string') {\n            if (typeof data[config] === 'undefined') {\n              throw new TypeError(\"No method named \\\"\".concat(config, \"\\\"\"));\n            }\n            data[config]();\n          }\n        });\n      }\n    }]);\n    return Tab;\n  }(BaseComponent);\n  /**\n   * ------------------------------------------------------------------------\n   * Data Api implementation\n   * ------------------------------------------------------------------------\n   */\n  EventHandler.on(document, EVENT_CLICK_DATA_API, SELECTOR_DATA_TOGGLE, function (event) {\n    if (['A', 'AREA'].includes(this.tagName)) {\n      event.preventDefault();\n    }\n    if (isDisabled(this)) {\n      return;\n    }\n    var data = Tab.getOrCreateInstance(this);\n    data.show();\n  });\n  /**\n   * ------------------------------------------------------------------------\n   * jQuery\n   * ------------------------------------------------------------------------\n   * add .Tab to jQuery only if jQuery is present\n   */\n\n  defineJQueryPlugin(Tab);\n\n  /**\n   * --------------------------------------------------------------------------\n   * Bootstrap (v5.0.2): toast.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */\n  /**\n   * ------------------------------------------------------------------------\n   * Constants\n   * ------------------------------------------------------------------------\n   */\n\n  var NAME = 'toast';\n  var DATA_KEY = 'bs.toast';\n  var EVENT_KEY = \".\".concat(DATA_KEY);\n  var EVENT_CLICK_DISMISS = \"click.dismiss\".concat(EVENT_KEY);\n  var EVENT_MOUSEOVER = \"mouseover\".concat(EVENT_KEY);\n  var EVENT_MOUSEOUT = \"mouseout\".concat(EVENT_KEY);\n  var EVENT_FOCUSIN = \"focusin\".concat(EVENT_KEY);\n  var EVENT_FOCUSOUT = \"focusout\".concat(EVENT_KEY);\n  var EVENT_HIDE = \"hide\".concat(EVENT_KEY);\n  var EVENT_HIDDEN = \"hidden\".concat(EVENT_KEY);\n  var EVENT_SHOW = \"show\".concat(EVENT_KEY);\n  var EVENT_SHOWN = \"shown\".concat(EVENT_KEY);\n  var CLASS_NAME_FADE = 'fade';\n  var CLASS_NAME_HIDE = 'hide';\n  var CLASS_NAME_SHOW = 'show';\n  var CLASS_NAME_SHOWING = 'showing';\n  var DefaultType = {\n    animation: 'boolean',\n    autohide: 'boolean',\n    delay: 'number'\n  };\n  var Default = {\n    animation: true,\n    autohide: true,\n    delay: 5000\n  };\n  var SELECTOR_DATA_DISMISS = '[data-bs-dismiss=\"toast\"]';\n  /**\n   * ------------------------------------------------------------------------\n   * Class Definition\n   * ------------------------------------------------------------------------\n   */\n  var Toast = /*#__PURE__*/function (_BaseComponent11) {\n    _inherits(Toast, _BaseComponent11);\n    var _super12 = _createSuper(Toast);\n    function Toast(element, config) {\n      var _this46;\n      _classCallCheck(this, Toast);\n      _this46 = _super12.call(this, element);\n      _this46._config = _this46._getConfig(config);\n      _this46._timeout = null;\n      _this46._hasMouseInteraction = false;\n      _this46._hasKeyboardInteraction = false;\n      _this46._setListeners();\n      return _this46;\n    } // Getters\n    _createClass(Toast, [{\n      key: \"show\",\n      value:\n      // Public\n\n      function show() {\n        var _this47 = this;\n        var showEvent = EventHandler.trigger(this._element, EVENT_SHOW);\n        if (showEvent.defaultPrevented) {\n          return;\n        }\n        this._clearTimeout();\n        if (this._config.animation) {\n          this._element.classList.add(CLASS_NAME_FADE);\n        }\n        var complete = function complete() {\n          _this47._element.classList.remove(CLASS_NAME_SHOWING);\n          _this47._element.classList.add(CLASS_NAME_SHOW);\n          EventHandler.trigger(_this47._element, EVENT_SHOWN);\n          _this47._maybeScheduleHide();\n        };\n        this._element.classList.remove(CLASS_NAME_HIDE);\n        reflow(this._element);\n        this._element.classList.add(CLASS_NAME_SHOWING);\n        this._queueCallback(complete, this._element, this._config.animation);\n      }\n    }, {\n      key: \"hide\",\n      value: function hide() {\n        var _this48 = this;\n        if (!this._element.classList.contains(CLASS_NAME_SHOW)) {\n          return;\n        }\n        var hideEvent = EventHandler.trigger(this._element, EVENT_HIDE);\n        if (hideEvent.defaultPrevented) {\n          return;\n        }\n        var complete = function complete() {\n          _this48._element.classList.add(CLASS_NAME_HIDE);\n          EventHandler.trigger(_this48._element, EVENT_HIDDEN);\n        };\n        this._element.classList.remove(CLASS_NAME_SHOW);\n        this._queueCallback(complete, this._element, this._config.animation);\n      }\n    }, {\n      key: \"dispose\",\n      value: function dispose() {\n        this._clearTimeout();\n        if (this._element.classList.contains(CLASS_NAME_SHOW)) {\n          this._element.classList.remove(CLASS_NAME_SHOW);\n        }\n        _get(_getPrototypeOf(Toast.prototype), \"dispose\", this).call(this);\n      } // Private\n    }, {\n      key: \"_getConfig\",\n      value: function _getConfig(config) {\n        config = _objectSpread(_objectSpread(_objectSpread({}, Default), Manipulator.getDataAttributes(this._element)), _typeof(config) === 'object' && config ? config : {});\n        typeCheckConfig(NAME, config, this.constructor.DefaultType);\n        return config;\n      }\n    }, {\n      key: \"_maybeScheduleHide\",\n      value: function _maybeScheduleHide() {\n        var _this49 = this;\n        if (!this._config.autohide) {\n          return;\n        }\n        if (this._hasMouseInteraction || this._hasKeyboardInteraction) {\n          return;\n        }\n        this._timeout = setTimeout(function () {\n          _this49.hide();\n        }, this._config.delay);\n      }\n    }, {\n      key: \"_onInteraction\",\n      value: function _onInteraction(event, isInteracting) {\n        switch (event.type) {\n          case 'mouseover':\n          case 'mouseout':\n            this._hasMouseInteraction = isInteracting;\n            break;\n          case 'focusin':\n          case 'focusout':\n            this._hasKeyboardInteraction = isInteracting;\n            break;\n        }\n        if (isInteracting) {\n          this._clearTimeout();\n          return;\n        }\n        var nextElement = event.relatedTarget;\n        if (this._element === nextElement || this._element.contains(nextElement)) {\n          return;\n        }\n        this._maybeScheduleHide();\n      }\n    }, {\n      key: \"_setListeners\",\n      value: function _setListeners() {\n        var _this50 = this;\n        EventHandler.on(this._element, EVENT_CLICK_DISMISS, SELECTOR_DATA_DISMISS, function () {\n          return _this50.hide();\n        });\n        EventHandler.on(this._element, EVENT_MOUSEOVER, function (event) {\n          return _this50._onInteraction(event, true);\n        });\n        EventHandler.on(this._element, EVENT_MOUSEOUT, function (event) {\n          return _this50._onInteraction(event, false);\n        });\n        EventHandler.on(this._element, EVENT_FOCUSIN, function (event) {\n          return _this50._onInteraction(event, true);\n        });\n        EventHandler.on(this._element, EVENT_FOCUSOUT, function (event) {\n          return _this50._onInteraction(event, false);\n        });\n      }\n    }, {\n      key: \"_clearTimeout\",\n      value: function _clearTimeout() {\n        clearTimeout(this._timeout);\n        this._timeout = null;\n      } // Static\n    }], [{\n      key: \"DefaultType\",\n      get: function get() {\n        return DefaultType;\n      }\n    }, {\n      key: \"Default\",\n      get: function get() {\n        return Default;\n      }\n    }, {\n      key: \"NAME\",\n      get: function get() {\n        return NAME;\n      }\n    }, {\n      key: \"jQueryInterface\",\n      value: function jQueryInterface(config) {\n        return this.each(function () {\n          var data = Toast.getOrCreateInstance(this, config);\n          if (typeof config === 'string') {\n            if (typeof data[config] === 'undefined') {\n              throw new TypeError(\"No method named \\\"\".concat(config, \"\\\"\"));\n            }\n            data[config](this);\n          }\n        });\n      }\n    }]);\n    return Toast;\n  }(BaseComponent);\n  /**\n   * ------------------------------------------------------------------------\n   * jQuery\n   * ------------------------------------------------------------------------\n   * add .Toast to jQuery only if jQuery is present\n   */\n  defineJQueryPlugin(Toast);\n\n  /**\n   * --------------------------------------------------------------------------\n   * Bootstrap (v5.0.2): index.umd.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */\n  var index_umd = {\n    Alert: Alert,\n    Button: Button,\n    Carousel: Carousel,\n    Collapse: Collapse,\n    Dropdown: Dropdown,\n    Modal: Modal,\n    Offcanvas: Offcanvas,\n    Popover: Popover,\n    ScrollSpy: ScrollSpy,\n    Tab: Tab,\n    Toast: Toast,\n    Tooltip: Tooltip\n  };\n  return index_umd;\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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YnBhY2s6Ly9ib290c3RyYXAtdjUvLi4vLi4vanMvc3JjL2RvbS9zZWxlY3Rvci1lbmdpbmUuanM/Zjg3ZiIsIndlYnBhY2s6Ly9ib290c3RyYXAtdjUvLi4vLi4vanMvc3JjL3V0aWwvaW5kZXguanM/MGE3ZiIsIndlYnBhY2s6Ly9ib290c3RyYXAtdjUvLi4vLi4vanMvc3JjL2RvbS9ldmVudC1oYW5kbGVyLmpzP2JiMjciLCJ3ZWJwYWNrOi8vYm9vdHN0cmFwLXY1Ly4uLy4uL2pzL3NyYy9kb20vZGF0YS5qcz9kYmUzIiwid2VicGFjazovL2Jvb3RzdHJhcC12NS8uLi8uLi9qcy9zcmMvYmFzZS1jb21wb25lbnQuanM/MzYwMyIsIndlYnBhY2s6Ly9ib290c3RyYXAtdjUvLi4vLi4vanMvc3JjL2FsZXJ0LmpzPzgwMjQiLCJ3ZWJwYWNrOi8vYm9vdHN0cmFwLXY1Ly4uLy4uL2pzL3NyYy9idXR0b24uanM/ZDg0OCIsIndlYnBhY2s6Ly9ib290c3RyYXAtdjUvLi4vLi4vanMvc3JjL2RvbS9tYW5pcHVsYXRvci5qcz81YWUyIiwid2VicGFjazovL2Jvb3RzdHJhcC12NS8uLi8uLi9qcy9zcmMvY2Fyb3VzZWwuanM/ZDg1MiIsIndlYnBhY2s6Ly9ib290c3RyYXAtdjUvLi4vLi4vanMvc3JjL2NvbGxhcHNlLmpzPzRjNTgiLCJ3ZWJwYWNrOi8vYm9vdHN0cmFwLXY1Ly4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZW51bXMuanM/NDY5NyIsIndlYnBhY2s6Ly9ib290c3RyYXAtdjUvLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0Tm9kZU5hbWUuanM/OTA2MCIsIndlYnBhY2s6Ly9ib290c3RyYXAtdjUvLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0V2luZG93LmpzPzlhOTQiLCJ3ZWJwYWNrOi8vYm9vdHN0cmFwLXY1Ly4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2luc3RhbmNlT2YuanM/N2NmOCIsIndlYnBhY2s6Ly9ib290c3RyYXAtdjUvLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvYXBwbHlTdHlsZXMuanM/MTJlYiIsIndlYnBhY2s6Ly9ib290c3RyYXAtdjUvLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9nZXRCYXNlUGxhY2VtZW50LmpzPzE1N2QiLCJ3ZWJwYWNrOi8vYm9vdHN0cmFwLXY1Ly4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldEJvdW5kaW5nQ2xpZW50UmVjdC5qcz9kZDE0Iiwid2VicGFjazovL2Jvb3RzdHJhcC12NS8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRMYXlvdXRSZWN0LmpzPzc4MDMiLCJ3ZWJwYWNrOi8vYm9vdHN0cmFwLXY1Ly4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2NvbnRhaW5zLmpzPzU4MTAiLCJ3ZWJwYWNrOi8vYm9vdHN0cmFwLXY1Ly4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldENvbXB1dGVkU3R5bGUuanM/MDkwOCIsIndlYnBhY2s6Ly9ib290c3RyYXAtdjUvLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvaXNUYWJsZUVsZW1lbnQuanM/MzdkNCIsIndlYnBhY2s6Ly9ib290c3RyYXAtdjUvLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0RG9jdW1lbnRFbGVtZW50LmpzPzM4NDgiLCJ3ZWJwYWNrOi8vYm9vdHN0cmFwLXY1Ly4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldFBhcmVudE5vZGUuanM/ZTA4OSIsIndlYnBhY2s6Ly9ib290c3RyYXAtdjUvLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0T2Zmc2V0UGFyZW50LmpzPzU4MmEiLCJ3ZWJwYWNrOi8vYm9vdHN0cmFwLXY1Ly4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50LmpzPzVkMGIiLCJ3ZWJwYWNrOi8vYm9vdHN0cmFwLXY1Ly4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvbWF0aC5qcz8zYjhjIiwid2VicGFjazovL2Jvb3RzdHJhcC12NS8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL3dpdGhpbi5qcz9kMDkzIiwid2VicGFjazovL2Jvb3RzdHJhcC12NS8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2dldEZyZXNoU2lkZU9iamVjdC5qcz9kMDdmIiwid2VicGFjazovL2Jvb3RzdHJhcC12NS8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL21lcmdlUGFkZGluZ09iamVjdC5qcz84MGY1Iiwid2VicGFjazovL2Jvb3RzdHJhcC12NS8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2V4cGFuZFRvSGFzaE1hcC5qcz81NDExIiwid2VicGFjazovL2Jvb3RzdHJhcC12NS8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9hcnJvdy5qcz9kMTMwIiwid2VicGFjazovL2Jvb3RzdHJhcC12NS8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9jb21wdXRlU3R5bGVzLmpzPzYzOTEiLCJ3ZWJwYWNrOi8vYm9vdHN0cmFwLXY1Ly4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvbW9kaWZpZXJzL2V2ZW50TGlzdGVuZXJzLmpzPzc5MzUiLCJ3ZWJwYWNrOi8vYm9vdHN0cmFwLXY1Ly4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZ2V0T3Bwb3NpdGVQbGFjZW1lbnQuanM/YTAwNiIsIndlYnBhY2s6Ly9ib290c3RyYXAtdjUvLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9nZXRPcHBvc2l0ZVZhcmlhdGlvblBsYWNlbWVudC5qcz9mODFlIiwid2VicGFjazovL2Jvb3RzdHJhcC12NS8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRXaW5kb3dTY3JvbGwuanM/OGE3MCIsIndlYnBhY2s6Ly9ib290c3RyYXAtdjUvLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0V2luZG93U2Nyb2xsQmFyWC5qcz82NmQzIiwid2VicGFjazovL2Jvb3RzdHJhcC12NS8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRWaWV3cG9ydFJlY3QuanM/ZDdmZSIsIndlYnBhY2s6Ly9ib290c3RyYXAtdjUvLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0RG9jdW1lbnRSZWN0LmpzPzMzMWUiLCJ3ZWJwYWNrOi8vYm9vdHN0cmFwLXY1Ly4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2lzU2Nyb2xsUGFyZW50LmpzPzc4NjMiLCJ3ZWJwYWNrOi8vYm9vdHN0cmFwLXY1Ly4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldFNjcm9sbFBhcmVudC5qcz9hMzJhIiwid2VicGFjazovL2Jvb3RzdHJhcC12NS8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9saXN0U2Nyb2xsUGFyZW50cy5qcz82ZjU5Iiwid2VicGFjazovL2Jvb3RzdHJhcC12NS8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL3JlY3RUb0NsaWVudFJlY3QuanM/OWMzOSIsIndlYnBhY2s6Ly9ib290c3RyYXAtdjUvLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0Q2xpcHBpbmdSZWN0LmpzP2QxNmQiLCJ3ZWJwYWNrOi8vYm9vdHN0cmFwLXY1Ly4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZ2V0VmFyaWF0aW9uLmpzP2MwMWYiLCJ3ZWJwYWNrOi8vYm9vdHN0cmFwLXY1Ly4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvY29tcHV0ZU9mZnNldHMuanM/NGU3NSIsIndlYnBhY2s6Ly9ib290c3RyYXAtdjUvLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9kZXRlY3RPdmVyZmxvdy5qcz9iNTM0Iiwid2VicGFjazovL2Jvb3RzdHJhcC12NS8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2NvbXB1dGVBdXRvUGxhY2VtZW50LmpzPzJlYTEiLCJ3ZWJwYWNrOi8vYm9vdHN0cmFwLXY1Ly4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvbW9kaWZpZXJzL2ZsaXAuanM/ZGI0OCIsIndlYnBhY2s6Ly9ib290c3RyYXAtdjUvLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvaGlkZS5qcz9hYjk3Iiwid2VicGFjazovL2Jvb3RzdHJhcC12NS8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9vZmZzZXQuanM/YzM2OSIsIndlYnBhY2s6Ly9ib290c3RyYXAtdjUvLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvcG9wcGVyT2Zmc2V0cy5qcz81ODAxIiwid2VicGFjazovL2Jvb3RzdHJhcC12NS8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2dldEFsdEF4aXMuanM/ZDhjNyIsIndlYnBhY2s6Ly9ib290c3RyYXAtdjUvLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvcHJldmVudE92ZXJmbG93LmpzP2Y5OGUiLCJ3ZWJwYWNrOi8vYm9vdHN0cmFwLXY1Ly4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldEhUTUxFbGVtZW50U2Nyb2xsLmpzP2I3ZTYiLCJ3ZWJwYWNrOi8vYm9vdHN0cmFwLXY1Ly4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldE5vZGVTY3JvbGwuanM/NjZjZiIsIndlYnBhY2s6Ly9ib290c3RyYXAtdjUvLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0Q29tcG9zaXRlUmVjdC5qcz9kZDJhIiwid2VicGFjazovL2Jvb3RzdHJhcC12NS8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL29yZGVyTW9kaWZpZXJzLmpzP2NmYWIiLCJ3ZWJwYWNrOi8vYm9vdHN0cmFwLXY1Ly4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZGVib3VuY2UuanM/YjgwYiIsIndlYnBhY2s6Ly9ib290c3RyYXAtdjUvLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9tZXJnZUJ5TmFtZS5qcz9iMDY5Iiwid2VicGFjazovL2Jvb3RzdHJhcC12NS8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2NyZWF0ZVBvcHBlci5qcz9hOTAwIiwid2VicGFjazovL2Jvb3RzdHJhcC12NS8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3BvcHBlci1saXRlLmpzPzk1ZDAiLCJ3ZWJwYWNrOi8vYm9vdHN0cmFwLXY1Ly4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvcG9wcGVyLmpzPzUxNWUiLCJ3ZWJwYWNrOi8vYm9vdHN0cmFwLXY1Ly4uLy4uL2pzL3NyYy9kcm9wZG93bi5qcz9lYzA0Iiwid2VicGFjazovL2Jvb3RzdHJhcC12NS8uLi8uLi9qcy9zcmMvdXRpbC9zY3JvbGxiYXIuanM/NWM3YyIsIndlYnBhY2s6Ly9ib290c3RyYXAtdjUvLi4vLi4vanMvc3JjL3V0aWwvYmFja2Ryb3AuanM/NTg0MyIsIndlYnBhY2s6Ly9ib290c3RyYXAtdjUvLi4vLi4vanMvc3JjL21vZGFsLmpzP2U0Y2IiLCJ3ZWJwYWNrOi8vYm9vdHN0cmFwLXY1Ly4uLy4uL2pzL3NyYy9vZmZjYW52YXMuanM/MzIyNCIsIndlYnBhY2s6Ly9ib290c3RyYXAtdjUvLi4vLi4vanMvc3JjL3V0aWwvc2FuaXRpemVyLmpzPzE1NjEiLCJ3ZWJwYWNrOi8vYm9vdHN0cmFwLXY1Ly4uLy4uL2pzL3NyYy90b29sdGlwLmpzP2IyNDkiLCJ3ZWJwYWNrOi8vYm9vdHN0cmFwLXY1Ly4uLy4uL2pzL3NyYy9wb3BvdmVyLmpzPzI4MzIiLCJ3ZWJwYWNrOi8vYm9vdHN0cmFwLXY1Ly4uLy4uL2pzL3NyYy9zY3JvbGxzcHkuanM/NjkwMiIsIndlYnBhY2s6Ly9ib290c3RyYXAtdjUvLi4vLi4vanMvc3JjL3RhYi5qcz8yYzllIiwid2VicGFjazovL2Jvb3RzdHJhcC12NS8uLi8uLi9qcy9zcmMvdG9hc3QuanM/ZWExMCIsIndlYnBhY2s6Ly9ib290c3RyYXAtdjUvLi4vLi4vanMvaW5kZXgudW1kLmpzPzEzMjYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQm9vdHN0cmFwICh2NS4wLjIpOiBkb20vc2VsZWN0b3ItZW5naW5lLmpzXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvbnN0YW50c1xuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuY29uc3QgTk9ERV9URVhUID0gM1xuXG5jb25zdCBTZWxlY3RvckVuZ2luZSA9IHtcbiAgZmluZChzZWxlY3RvciwgZWxlbWVudCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkge1xuICAgIHJldHVybiBbXS5jb25jYXQoLi4uRWxlbWVudC5wcm90b3R5cGUucXVlcnlTZWxlY3RvckFsbC5jYWxsKGVsZW1lbnQsIHNlbGVjdG9yKSlcbiAgfSxcblxuICBmaW5kT25lKHNlbGVjdG9yLCBlbGVtZW50ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgcmV0dXJuIEVsZW1lbnQucHJvdG90eXBlLnF1ZXJ5U2VsZWN0b3IuY2FsbChlbGVtZW50LCBzZWxlY3RvcilcbiAgfSxcblxuICBjaGlsZHJlbihlbGVtZW50LCBzZWxlY3Rvcikge1xuICAgIHJldHVybiBbXS5jb25jYXQoLi4uZWxlbWVudC5jaGlsZHJlbilcbiAgICAgIC5maWx0ZXIoY2hpbGQgPT4gY2hpbGQubWF0Y2hlcyhzZWxlY3RvcikpXG4gIH0sXG5cbiAgcGFyZW50cyhlbGVtZW50LCBzZWxlY3Rvcikge1xuICAgIGNvbnN0IHBhcmVudHMgPSBbXVxuXG4gICAgbGV0IGFuY2VzdG9yID0gZWxlbWVudC5wYXJlbnROb2RlXG5cbiAgICB3aGlsZSAoYW5jZXN0b3IgJiYgYW5jZXN0b3Iubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFICYmIGFuY2VzdG9yLm5vZGVUeXBlICE9PSBOT0RFX1RFWFQpIHtcbiAgICAgIGlmIChhbmNlc3Rvci5tYXRjaGVzKHNlbGVjdG9yKSkge1xuICAgICAgICBwYXJlbnRzLnB1c2goYW5jZXN0b3IpXG4gICAgICB9XG5cbiAgICAgIGFuY2VzdG9yID0gYW5jZXN0b3IucGFyZW50Tm9kZVxuICAgIH1cblxuICAgIHJldHVybiBwYXJlbnRzXG4gIH0sXG5cbiAgcHJldihlbGVtZW50LCBzZWxlY3Rvcikge1xuICAgIGxldCBwcmV2aW91cyA9IGVsZW1lbnQucHJldmlvdXNFbGVtZW50U2libGluZ1xuXG4gICAgd2hpbGUgKHByZXZpb3VzKSB7XG4gICAgICBpZiAocHJldmlvdXMubWF0Y2hlcyhzZWxlY3RvcikpIHtcbiAgICAgICAgcmV0dXJuIFtwcmV2aW91c11cbiAgICAgIH1cblxuICAgICAgcHJldmlvdXMgPSBwcmV2aW91cy5wcmV2aW91c0VsZW1lbnRTaWJsaW5nXG4gICAgfVxuXG4gICAgcmV0dXJuIFtdXG4gIH0sXG5cbiAgbmV4dChlbGVtZW50LCBzZWxlY3Rvcikge1xuICAgIGxldCBuZXh0ID0gZWxlbWVudC5uZXh0RWxlbWVudFNpYmxpbmdcblxuICAgIHdoaWxlIChuZXh0KSB7XG4gICAgICBpZiAobmV4dC5tYXRjaGVzKHNlbGVjdG9yKSkge1xuICAgICAgICByZXR1cm4gW25leHRdXG4gICAgICB9XG5cbiAgICAgIG5leHQgPSBuZXh0Lm5leHRFbGVtZW50U2libGluZ1xuICAgIH1cblxuICAgIHJldHVybiBbXVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFNlbGVjdG9yRW5naW5lXG4iLCJpbXBvcnQgU2VsZWN0b3JFbmdpbmUgZnJvbSAnLi4vZG9tL3NlbGVjdG9yLWVuZ2luZSdcblxuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQm9vdHN0cmFwICh2NS4wLjIpOiB1dGlsL2luZGV4LmpzXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuY29uc3QgTUFYX1VJRCA9IDEwMDAwMDBcbmNvbnN0IE1JTExJU0VDT05EU19NVUxUSVBMSUVSID0gMTAwMFxuY29uc3QgVFJBTlNJVElPTl9FTkQgPSAndHJhbnNpdGlvbmVuZCdcblxuLy8gU2hvdXRvdXQgQW5ndXNDcm9sbCAoaHR0cHM6Ly9nb28uZ2wvcHh3UUdwKVxuY29uc3QgdG9UeXBlID0gb2JqID0+IHtcbiAgaWYgKG9iaiA9PT0gbnVsbCB8fCBvYmogPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBgJHtvYmp9YFxuICB9XG5cbiAgcmV0dXJuIHt9LnRvU3RyaW5nLmNhbGwob2JqKS5tYXRjaCgvXFxzKFthLXpdKykvaSlbMV0udG9Mb3dlckNhc2UoKVxufVxuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBQdWJsaWMgVXRpbCBBcGlcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuY29uc3QgZ2V0VUlEID0gcHJlZml4ID0+IHtcbiAgZG8ge1xuICAgIHByZWZpeCArPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBNQVhfVUlEKVxuICB9IHdoaWxlIChkb2N1bWVudC5nZXRFbGVtZW50QnlJZChwcmVmaXgpKVxuXG4gIHJldHVybiBwcmVmaXhcbn1cblxuY29uc3QgZ2V0U2VsZWN0b3IgPSBlbGVtZW50ID0+IHtcbiAgbGV0IHNlbGVjdG9yID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtYnMtdGFyZ2V0JylcblxuICBpZiAoIXNlbGVjdG9yIHx8IHNlbGVjdG9yID09PSAnIycpIHtcbiAgICBsZXQgaHJlZkF0dHIgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnaHJlZicpXG5cbiAgICAvLyBUaGUgb25seSB2YWxpZCBjb250ZW50IHRoYXQgY291bGQgZG91YmxlIGFzIGEgc2VsZWN0b3IgYXJlIElEcyBvciBjbGFzc2VzLFxuICAgIC8vIHNvIGV2ZXJ5dGhpbmcgc3RhcnRpbmcgd2l0aCBgI2Agb3IgYC5gLiBJZiBhIFwicmVhbFwiIFVSTCBpcyB1c2VkIGFzIHRoZSBzZWxlY3RvcixcbiAgICAvLyBgZG9jdW1lbnQucXVlcnlTZWxlY3RvcmAgd2lsbCByaWdodGZ1bGx5IGNvbXBsYWluIGl0IGlzIGludmFsaWQuXG4gICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9pc3N1ZXMvMzIyNzNcbiAgICBpZiAoIWhyZWZBdHRyIHx8ICghaHJlZkF0dHIuaW5jbHVkZXMoJyMnKSAmJiAhaHJlZkF0dHIuc3RhcnRzV2l0aCgnLicpKSkge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG5cbiAgICAvLyBKdXN0IGluIGNhc2Ugc29tZSBDTVMgcHV0cyBvdXQgYSBmdWxsIFVSTCB3aXRoIHRoZSBhbmNob3IgYXBwZW5kZWRcbiAgICBpZiAoaHJlZkF0dHIuaW5jbHVkZXMoJyMnKSAmJiAhaHJlZkF0dHIuc3RhcnRzV2l0aCgnIycpKSB7XG4gICAgICBocmVmQXR0ciA9IGAjJHtocmVmQXR0ci5zcGxpdCgnIycpWzFdfWBcbiAgICB9XG5cbiAgICBzZWxlY3RvciA9IGhyZWZBdHRyICYmIGhyZWZBdHRyICE9PSAnIycgPyBocmVmQXR0ci50cmltKCkgOiBudWxsXG4gIH1cblxuICByZXR1cm4gc2VsZWN0b3Jcbn1cblxuY29uc3QgZ2V0U2VsZWN0b3JGcm9tRWxlbWVudCA9IGVsZW1lbnQgPT4ge1xuICBjb25zdCBzZWxlY3RvciA9IGdldFNlbGVjdG9yKGVsZW1lbnQpXG5cbiAgaWYgKHNlbGVjdG9yKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpID8gc2VsZWN0b3IgOiBudWxsXG4gIH1cblxuICByZXR1cm4gbnVsbFxufVxuXG5jb25zdCBnZXRFbGVtZW50RnJvbVNlbGVjdG9yID0gZWxlbWVudCA9PiB7XG4gIGNvbnN0IHNlbGVjdG9yID0gZ2V0U2VsZWN0b3IoZWxlbWVudClcblxuICByZXR1cm4gc2VsZWN0b3IgPyBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKSA6IG51bGxcbn1cblxuY29uc3QgZ2V0VHJhbnNpdGlvbkR1cmF0aW9uRnJvbUVsZW1lbnQgPSBlbGVtZW50ID0+IHtcbiAgaWYgKCFlbGVtZW50KSB7XG4gICAgcmV0dXJuIDBcbiAgfVxuXG4gIC8vIEdldCB0cmFuc2l0aW9uLWR1cmF0aW9uIG9mIHRoZSBlbGVtZW50XG4gIGxldCB7IHRyYW5zaXRpb25EdXJhdGlvbiwgdHJhbnNpdGlvbkRlbGF5IH0gPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KVxuXG4gIGNvbnN0IGZsb2F0VHJhbnNpdGlvbkR1cmF0aW9uID0gTnVtYmVyLnBhcnNlRmxvYXQodHJhbnNpdGlvbkR1cmF0aW9uKVxuICBjb25zdCBmbG9hdFRyYW5zaXRpb25EZWxheSA9IE51bWJlci5wYXJzZUZsb2F0KHRyYW5zaXRpb25EZWxheSlcblxuICAvLyBSZXR1cm4gMCBpZiBlbGVtZW50IG9yIHRyYW5zaXRpb24gZHVyYXRpb24gaXMgbm90IGZvdW5kXG4gIGlmICghZmxvYXRUcmFuc2l0aW9uRHVyYXRpb24gJiYgIWZsb2F0VHJhbnNpdGlvbkRlbGF5KSB7XG4gICAgcmV0dXJuIDBcbiAgfVxuXG4gIC8vIElmIG11bHRpcGxlIGR1cmF0aW9ucyBhcmUgZGVmaW5lZCwgdGFrZSB0aGUgZmlyc3RcbiAgdHJhbnNpdGlvbkR1cmF0aW9uID0gdHJhbnNpdGlvbkR1cmF0aW9uLnNwbGl0KCcsJylbMF1cbiAgdHJhbnNpdGlvbkRlbGF5ID0gdHJhbnNpdGlvbkRlbGF5LnNwbGl0KCcsJylbMF1cblxuICByZXR1cm4gKE51bWJlci5wYXJzZUZsb2F0KHRyYW5zaXRpb25EdXJhdGlvbikgKyBOdW1iZXIucGFyc2VGbG9hdCh0cmFuc2l0aW9uRGVsYXkpKSAqIE1JTExJU0VDT05EU19NVUxUSVBMSUVSXG59XG5cbmNvbnN0IHRyaWdnZXJUcmFuc2l0aW9uRW5kID0gZWxlbWVudCA9PiB7XG4gIGVsZW1lbnQuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoVFJBTlNJVElPTl9FTkQpKVxufVxuXG5jb25zdCBpc0VsZW1lbnQgPSBvYmogPT4ge1xuICBpZiAoIW9iaiB8fCB0eXBlb2Ygb2JqICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgaWYgKHR5cGVvZiBvYmouanF1ZXJ5ICE9PSAndW5kZWZpbmVkJykge1xuICAgIG9iaiA9IG9ialswXVxuICB9XG5cbiAgcmV0dXJuIHR5cGVvZiBvYmoubm9kZVR5cGUgIT09ICd1bmRlZmluZWQnXG59XG5cbmNvbnN0IGdldEVsZW1lbnQgPSBvYmogPT4ge1xuICBpZiAoaXNFbGVtZW50KG9iaikpIHsgLy8gaXQncyBhIGpRdWVyeSBvYmplY3Qgb3IgYSBub2RlIGVsZW1lbnRcbiAgICByZXR1cm4gb2JqLmpxdWVyeSA/IG9ialswXSA6IG9ialxuICB9XG5cbiAgaWYgKHR5cGVvZiBvYmogPT09ICdzdHJpbmcnICYmIG9iai5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIFNlbGVjdG9yRW5naW5lLmZpbmRPbmUob2JqKVxuICB9XG5cbiAgcmV0dXJuIG51bGxcbn1cblxuY29uc3QgdHlwZUNoZWNrQ29uZmlnID0gKGNvbXBvbmVudE5hbWUsIGNvbmZpZywgY29uZmlnVHlwZXMpID0+IHtcbiAgT2JqZWN0LmtleXMoY29uZmlnVHlwZXMpLmZvckVhY2gocHJvcGVydHkgPT4ge1xuICAgIGNvbnN0IGV4cGVjdGVkVHlwZXMgPSBjb25maWdUeXBlc1twcm9wZXJ0eV1cbiAgICBjb25zdCB2YWx1ZSA9IGNvbmZpZ1twcm9wZXJ0eV1cbiAgICBjb25zdCB2YWx1ZVR5cGUgPSB2YWx1ZSAmJiBpc0VsZW1lbnQodmFsdWUpID8gJ2VsZW1lbnQnIDogdG9UeXBlKHZhbHVlKVxuXG4gICAgaWYgKCFuZXcgUmVnRXhwKGV4cGVjdGVkVHlwZXMpLnRlc3QodmFsdWVUeXBlKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgYCR7Y29tcG9uZW50TmFtZS50b1VwcGVyQ2FzZSgpfTogT3B0aW9uIFwiJHtwcm9wZXJ0eX1cIiBwcm92aWRlZCB0eXBlIFwiJHt2YWx1ZVR5cGV9XCIgYnV0IGV4cGVjdGVkIHR5cGUgXCIke2V4cGVjdGVkVHlwZXN9XCIuYFxuICAgICAgKVxuICAgIH1cbiAgfSlcbn1cblxuY29uc3QgaXNWaXNpYmxlID0gZWxlbWVudCA9PiB7XG4gIGlmICghaXNFbGVtZW50KGVsZW1lbnQpIHx8IGVsZW1lbnQuZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIHJldHVybiBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLmdldFByb3BlcnR5VmFsdWUoJ3Zpc2liaWxpdHknKSA9PT0gJ3Zpc2libGUnXG59XG5cbmNvbnN0IGlzRGlzYWJsZWQgPSBlbGVtZW50ID0+IHtcbiAgaWYgKCFlbGVtZW50IHx8IGVsZW1lbnQubm9kZVR5cGUgIT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGlmIChlbGVtZW50LmNsYXNzTGlzdC5jb250YWlucygnZGlzYWJsZWQnKSkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBpZiAodHlwZW9mIGVsZW1lbnQuZGlzYWJsZWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQuZGlzYWJsZWRcbiAgfVxuXG4gIHJldHVybiBlbGVtZW50Lmhhc0F0dHJpYnV0ZSgnZGlzYWJsZWQnKSAmJiBlbGVtZW50LmdldEF0dHJpYnV0ZSgnZGlzYWJsZWQnKSAhPT0gJ2ZhbHNlJ1xufVxuXG5jb25zdCBmaW5kU2hhZG93Um9vdCA9IGVsZW1lbnQgPT4ge1xuICBpZiAoIWRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5hdHRhY2hTaGFkb3cpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgLy8gQ2FuIGZpbmQgdGhlIHNoYWRvdyByb290IG90aGVyd2lzZSBpdCdsbCByZXR1cm4gdGhlIGRvY3VtZW50XG4gIGlmICh0eXBlb2YgZWxlbWVudC5nZXRSb290Tm9kZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNvbnN0IHJvb3QgPSBlbGVtZW50LmdldFJvb3ROb2RlKClcbiAgICByZXR1cm4gcm9vdCBpbnN0YW5jZW9mIFNoYWRvd1Jvb3QgPyByb290IDogbnVsbFxuICB9XG5cbiAgaWYgKGVsZW1lbnQgaW5zdGFuY2VvZiBTaGFkb3dSb290KSB7XG4gICAgcmV0dXJuIGVsZW1lbnRcbiAgfVxuXG4gIC8vIHdoZW4gd2UgZG9uJ3QgZmluZCBhIHNoYWRvdyByb290XG4gIGlmICghZWxlbWVudC5wYXJlbnROb2RlKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIHJldHVybiBmaW5kU2hhZG93Um9vdChlbGVtZW50LnBhcmVudE5vZGUpXG59XG5cbmNvbnN0IG5vb3AgPSAoKSA9PiB7fVxuXG5jb25zdCByZWZsb3cgPSBlbGVtZW50ID0+IGVsZW1lbnQub2Zmc2V0SGVpZ2h0XG5cbmNvbnN0IGdldGpRdWVyeSA9ICgpID0+IHtcbiAgY29uc3QgeyBqUXVlcnkgfSA9IHdpbmRvd1xuXG4gIGlmIChqUXVlcnkgJiYgIWRvY3VtZW50LmJvZHkuaGFzQXR0cmlidXRlKCdkYXRhLWJzLW5vLWpxdWVyeScpKSB7XG4gICAgcmV0dXJuIGpRdWVyeVxuICB9XG5cbiAgcmV0dXJuIG51bGxcbn1cblxuY29uc3QgRE9NQ29udGVudExvYWRlZENhbGxiYWNrcyA9IFtdXG5cbmNvbnN0IG9uRE9NQ29udGVudExvYWRlZCA9IGNhbGxiYWNrID0+IHtcbiAgaWYgKGRvY3VtZW50LnJlYWR5U3RhdGUgPT09ICdsb2FkaW5nJykge1xuICAgIC8vIGFkZCBsaXN0ZW5lciBvbiB0aGUgZmlyc3QgY2FsbCB3aGVuIHRoZSBkb2N1bWVudCBpcyBpbiBsb2FkaW5nIHN0YXRlXG4gICAgaWYgKCFET01Db250ZW50TG9hZGVkQ2FsbGJhY2tzLmxlbmd0aCkge1xuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsICgpID0+IHtcbiAgICAgICAgRE9NQ29udGVudExvYWRlZENhbGxiYWNrcy5mb3JFYWNoKGNhbGxiYWNrID0+IGNhbGxiYWNrKCkpXG4gICAgICB9KVxuICAgIH1cblxuICAgIERPTUNvbnRlbnRMb2FkZWRDYWxsYmFja3MucHVzaChjYWxsYmFjaylcbiAgfSBlbHNlIHtcbiAgICBjYWxsYmFjaygpXG4gIH1cbn1cblxuY29uc3QgaXNSVEwgPSAoKSA9PiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuZGlyID09PSAncnRsJ1xuXG5jb25zdCBkZWZpbmVKUXVlcnlQbHVnaW4gPSBwbHVnaW4gPT4ge1xuICBvbkRPTUNvbnRlbnRMb2FkZWQoKCkgPT4ge1xuICAgIGNvbnN0ICQgPSBnZXRqUXVlcnkoKVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICgkKSB7XG4gICAgICBjb25zdCBuYW1lID0gcGx1Z2luLk5BTUVcbiAgICAgIGNvbnN0IEpRVUVSWV9OT19DT05GTElDVCA9ICQuZm5bbmFtZV1cbiAgICAgICQuZm5bbmFtZV0gPSBwbHVnaW4ualF1ZXJ5SW50ZXJmYWNlXG4gICAgICAkLmZuW25hbWVdLkNvbnN0cnVjdG9yID0gcGx1Z2luXG4gICAgICAkLmZuW25hbWVdLm5vQ29uZmxpY3QgPSAoKSA9PiB7XG4gICAgICAgICQuZm5bbmFtZV0gPSBKUVVFUllfTk9fQ09ORkxJQ1RcbiAgICAgICAgcmV0dXJuIHBsdWdpbi5qUXVlcnlJbnRlcmZhY2VcbiAgICAgIH1cbiAgICB9XG4gIH0pXG59XG5cbmNvbnN0IGV4ZWN1dGUgPSBjYWxsYmFjayA9PiB7XG4gIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjaygpXG4gIH1cbn1cblxuY29uc3QgZXhlY3V0ZUFmdGVyVHJhbnNpdGlvbiA9IChjYWxsYmFjaywgdHJhbnNpdGlvbkVsZW1lbnQsIHdhaXRGb3JUcmFuc2l0aW9uID0gdHJ1ZSkgPT4ge1xuICBpZiAoIXdhaXRGb3JUcmFuc2l0aW9uKSB7XG4gICAgZXhlY3V0ZShjYWxsYmFjaylcbiAgICByZXR1cm5cbiAgfVxuXG4gIGNvbnN0IGR1cmF0aW9uUGFkZGluZyA9IDVcbiAgY29uc3QgZW11bGF0ZWREdXJhdGlvbiA9IGdldFRyYW5zaXRpb25EdXJhdGlvbkZyb21FbGVtZW50KHRyYW5zaXRpb25FbGVtZW50KSArIGR1cmF0aW9uUGFkZGluZ1xuXG4gIGxldCBjYWxsZWQgPSBmYWxzZVxuXG4gIGNvbnN0IGhhbmRsZXIgPSAoeyB0YXJnZXQgfSkgPT4ge1xuICAgIGlmICh0YXJnZXQgIT09IHRyYW5zaXRpb25FbGVtZW50KSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjYWxsZWQgPSB0cnVlXG4gICAgdHJhbnNpdGlvbkVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihUUkFOU0lUSU9OX0VORCwgaGFuZGxlcilcbiAgICBleGVjdXRlKGNhbGxiYWNrKVxuICB9XG5cbiAgdHJhbnNpdGlvbkVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihUUkFOU0lUSU9OX0VORCwgaGFuZGxlcilcbiAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgaWYgKCFjYWxsZWQpIHtcbiAgICAgIHRyaWdnZXJUcmFuc2l0aW9uRW5kKHRyYW5zaXRpb25FbGVtZW50KVxuICAgIH1cbiAgfSwgZW11bGF0ZWREdXJhdGlvbilcbn1cblxuLyoqXG4gKiBSZXR1cm4gdGhlIHByZXZpb3VzL25leHQgZWxlbWVudCBvZiBhIGxpc3QuXG4gKlxuICogQHBhcmFtIHthcnJheX0gbGlzdCAgICBUaGUgbGlzdCBvZiBlbGVtZW50c1xuICogQHBhcmFtIGFjdGl2ZUVsZW1lbnQgICBUaGUgYWN0aXZlIGVsZW1lbnRcbiAqIEBwYXJhbSBzaG91bGRHZXROZXh0ICAgQ2hvb3NlIHRvIGdldCBuZXh0IG9yIHByZXZpb3VzIGVsZW1lbnRcbiAqIEBwYXJhbSBpc0N5Y2xlQWxsb3dlZFxuICogQHJldHVybiB7RWxlbWVudHxlbGVtfSBUaGUgcHJvcGVyIGVsZW1lbnRcbiAqL1xuY29uc3QgZ2V0TmV4dEFjdGl2ZUVsZW1lbnQgPSAobGlzdCwgYWN0aXZlRWxlbWVudCwgc2hvdWxkR2V0TmV4dCwgaXNDeWNsZUFsbG93ZWQpID0+IHtcbiAgbGV0IGluZGV4ID0gbGlzdC5pbmRleE9mKGFjdGl2ZUVsZW1lbnQpXG5cbiAgLy8gaWYgdGhlIGVsZW1lbnQgZG9lcyBub3QgZXhpc3QgaW4gdGhlIGxpc3QgcmV0dXJuIGFuIGVsZW1lbnQgZGVwZW5kaW5nIG9uIHRoZSBkaXJlY3Rpb24gYW5kIGlmIGN5Y2xlIGlzIGFsbG93ZWRcbiAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgIHJldHVybiBsaXN0WyFzaG91bGRHZXROZXh0ICYmIGlzQ3ljbGVBbGxvd2VkID8gbGlzdC5sZW5ndGggLSAxIDogMF1cbiAgfVxuXG4gIGNvbnN0IGxpc3RMZW5ndGggPSBsaXN0Lmxlbmd0aFxuXG4gIGluZGV4ICs9IHNob3VsZEdldE5leHQgPyAxIDogLTFcblxuICBpZiAoaXNDeWNsZUFsbG93ZWQpIHtcbiAgICBpbmRleCA9IChpbmRleCArIGxpc3RMZW5ndGgpICUgbGlzdExlbmd0aFxuICB9XG5cbiAgcmV0dXJuIGxpc3RbTWF0aC5tYXgoMCwgTWF0aC5taW4oaW5kZXgsIGxpc3RMZW5ndGggLSAxKSldXG59XG5cbmV4cG9ydCB7XG4gIGdldEVsZW1lbnQsXG4gIGdldFVJRCxcbiAgZ2V0U2VsZWN0b3JGcm9tRWxlbWVudCxcbiAgZ2V0RWxlbWVudEZyb21TZWxlY3RvcixcbiAgZ2V0VHJhbnNpdGlvbkR1cmF0aW9uRnJvbUVsZW1lbnQsXG4gIHRyaWdnZXJUcmFuc2l0aW9uRW5kLFxuICBpc0VsZW1lbnQsXG4gIHR5cGVDaGVja0NvbmZpZyxcbiAgaXNWaXNpYmxlLFxuICBpc0Rpc2FibGVkLFxuICBmaW5kU2hhZG93Um9vdCxcbiAgbm9vcCxcbiAgZ2V0TmV4dEFjdGl2ZUVsZW1lbnQsXG4gIHJlZmxvdyxcbiAgZ2V0alF1ZXJ5LFxuICBvbkRPTUNvbnRlbnRMb2FkZWQsXG4gIGlzUlRMLFxuICBkZWZpbmVKUXVlcnlQbHVnaW4sXG4gIGV4ZWN1dGUsXG4gIGV4ZWN1dGVBZnRlclRyYW5zaXRpb25cbn1cbiIsIi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEJvb3RzdHJhcCAodjUuMC4yKTogZG9tL2V2ZW50LWhhbmRsZXIuanNcbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5pbXBvcnQgeyBnZXRqUXVlcnkgfSBmcm9tICcuLi91dGlsL2luZGV4J1xuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29uc3RhbnRzXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5jb25zdCBuYW1lc3BhY2VSZWdleCA9IC9bXi5dKig/PVxcLi4qKVxcLnwuKi9cbmNvbnN0IHN0cmlwTmFtZVJlZ2V4ID0gL1xcLi4qL1xuY29uc3Qgc3RyaXBVaWRSZWdleCA9IC86OlxcZCskL1xuY29uc3QgZXZlbnRSZWdpc3RyeSA9IHt9IC8vIEV2ZW50cyBzdG9yYWdlXG5sZXQgdWlkRXZlbnQgPSAxXG5jb25zdCBjdXN0b21FdmVudHMgPSB7XG4gIG1vdXNlZW50ZXI6ICdtb3VzZW92ZXInLFxuICBtb3VzZWxlYXZlOiAnbW91c2VvdXQnXG59XG5jb25zdCBjdXN0b21FdmVudHNSZWdleCA9IC9eKG1vdXNlZW50ZXJ8bW91c2VsZWF2ZSkvaVxuY29uc3QgbmF0aXZlRXZlbnRzID0gbmV3IFNldChbXG4gICdjbGljaycsXG4gICdkYmxjbGljaycsXG4gICdtb3VzZXVwJyxcbiAgJ21vdXNlZG93bicsXG4gICdjb250ZXh0bWVudScsXG4gICdtb3VzZXdoZWVsJyxcbiAgJ0RPTU1vdXNlU2Nyb2xsJyxcbiAgJ21vdXNlb3ZlcicsXG4gICdtb3VzZW91dCcsXG4gICdtb3VzZW1vdmUnLFxuICAnc2VsZWN0c3RhcnQnLFxuICAnc2VsZWN0ZW5kJyxcbiAgJ2tleWRvd24nLFxuICAna2V5cHJlc3MnLFxuICAna2V5dXAnLFxuICAnb3JpZW50YXRpb25jaGFuZ2UnLFxuICAndG91Y2hzdGFydCcsXG4gICd0b3VjaG1vdmUnLFxuICAndG91Y2hlbmQnLFxuICAndG91Y2hjYW5jZWwnLFxuICAncG9pbnRlcmRvd24nLFxuICAncG9pbnRlcm1vdmUnLFxuICAncG9pbnRlcnVwJyxcbiAgJ3BvaW50ZXJsZWF2ZScsXG4gICdwb2ludGVyY2FuY2VsJyxcbiAgJ2dlc3R1cmVzdGFydCcsXG4gICdnZXN0dXJlY2hhbmdlJyxcbiAgJ2dlc3R1cmVlbmQnLFxuICAnZm9jdXMnLFxuICAnYmx1cicsXG4gICdjaGFuZ2UnLFxuICAncmVzZXQnLFxuICAnc2VsZWN0JyxcbiAgJ3N1Ym1pdCcsXG4gICdmb2N1c2luJyxcbiAgJ2ZvY3Vzb3V0JyxcbiAgJ2xvYWQnLFxuICAndW5sb2FkJyxcbiAgJ2JlZm9yZXVubG9hZCcsXG4gICdyZXNpemUnLFxuICAnbW92ZScsXG4gICdET01Db250ZW50TG9hZGVkJyxcbiAgJ3JlYWR5c3RhdGVjaGFuZ2UnLFxuICAnZXJyb3InLFxuICAnYWJvcnQnLFxuICAnc2Nyb2xsJ1xuXSlcblxuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIFByaXZhdGUgbWV0aG9kc1xuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuZnVuY3Rpb24gZ2V0VWlkRXZlbnQoZWxlbWVudCwgdWlkKSB7XG4gIHJldHVybiAodWlkICYmIGAke3VpZH06OiR7dWlkRXZlbnQrK31gKSB8fCBlbGVtZW50LnVpZEV2ZW50IHx8IHVpZEV2ZW50Kytcbn1cblxuZnVuY3Rpb24gZ2V0RXZlbnQoZWxlbWVudCkge1xuICBjb25zdCB1aWQgPSBnZXRVaWRFdmVudChlbGVtZW50KVxuXG4gIGVsZW1lbnQudWlkRXZlbnQgPSB1aWRcbiAgZXZlbnRSZWdpc3RyeVt1aWRdID0gZXZlbnRSZWdpc3RyeVt1aWRdIHx8IHt9XG5cbiAgcmV0dXJuIGV2ZW50UmVnaXN0cnlbdWlkXVxufVxuXG5mdW5jdGlvbiBib290c3RyYXBIYW5kbGVyKGVsZW1lbnQsIGZuKSB7XG4gIHJldHVybiBmdW5jdGlvbiBoYW5kbGVyKGV2ZW50KSB7XG4gICAgZXZlbnQuZGVsZWdhdGVUYXJnZXQgPSBlbGVtZW50XG5cbiAgICBpZiAoaGFuZGxlci5vbmVPZmYpIHtcbiAgICAgIEV2ZW50SGFuZGxlci5vZmYoZWxlbWVudCwgZXZlbnQudHlwZSwgZm4pXG4gICAgfVxuXG4gICAgcmV0dXJuIGZuLmFwcGx5KGVsZW1lbnQsIFtldmVudF0pXG4gIH1cbn1cblxuZnVuY3Rpb24gYm9vdHN0cmFwRGVsZWdhdGlvbkhhbmRsZXIoZWxlbWVudCwgc2VsZWN0b3IsIGZuKSB7XG4gIHJldHVybiBmdW5jdGlvbiBoYW5kbGVyKGV2ZW50KSB7XG4gICAgY29uc3QgZG9tRWxlbWVudHMgPSBlbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpXG5cbiAgICBmb3IgKGxldCB7IHRhcmdldCB9ID0gZXZlbnQ7IHRhcmdldCAmJiB0YXJnZXQgIT09IHRoaXM7IHRhcmdldCA9IHRhcmdldC5wYXJlbnROb2RlKSB7XG4gICAgICBmb3IgKGxldCBpID0gZG9tRWxlbWVudHMubGVuZ3RoOyBpLS07KSB7XG4gICAgICAgIGlmIChkb21FbGVtZW50c1tpXSA9PT0gdGFyZ2V0KSB7XG4gICAgICAgICAgZXZlbnQuZGVsZWdhdGVUYXJnZXQgPSB0YXJnZXRcblxuICAgICAgICAgIGlmIChoYW5kbGVyLm9uZU9mZikge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHVuaWNvcm4vY29uc2lzdGVudC1kZXN0cnVjdHVyaW5nXG4gICAgICAgICAgICBFdmVudEhhbmRsZXIub2ZmKGVsZW1lbnQsIGV2ZW50LnR5cGUsIHNlbGVjdG9yLCBmbilcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gZm4uYXBwbHkodGFyZ2V0LCBbZXZlbnRdKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gVG8gcGxlYXNlIEVTTGludFxuICAgIHJldHVybiBudWxsXG4gIH1cbn1cblxuZnVuY3Rpb24gZmluZEhhbmRsZXIoZXZlbnRzLCBoYW5kbGVyLCBkZWxlZ2F0aW9uU2VsZWN0b3IgPSBudWxsKSB7XG4gIGNvbnN0IHVpZEV2ZW50TGlzdCA9IE9iamVjdC5rZXlzKGV2ZW50cylcblxuICBmb3IgKGxldCBpID0gMCwgbGVuID0gdWlkRXZlbnRMaXN0Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgY29uc3QgZXZlbnQgPSBldmVudHNbdWlkRXZlbnRMaXN0W2ldXVxuXG4gICAgaWYgKGV2ZW50Lm9yaWdpbmFsSGFuZGxlciA9PT0gaGFuZGxlciAmJiBldmVudC5kZWxlZ2F0aW9uU2VsZWN0b3IgPT09IGRlbGVnYXRpb25TZWxlY3Rvcikge1xuICAgICAgcmV0dXJuIGV2ZW50XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGxcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplUGFyYW1zKG9yaWdpbmFsVHlwZUV2ZW50LCBoYW5kbGVyLCBkZWxlZ2F0aW9uRm4pIHtcbiAgY29uc3QgZGVsZWdhdGlvbiA9IHR5cGVvZiBoYW5kbGVyID09PSAnc3RyaW5nJ1xuICBjb25zdCBvcmlnaW5hbEhhbmRsZXIgPSBkZWxlZ2F0aW9uID8gZGVsZWdhdGlvbkZuIDogaGFuZGxlclxuXG4gIGxldCB0eXBlRXZlbnQgPSBnZXRUeXBlRXZlbnQob3JpZ2luYWxUeXBlRXZlbnQpXG4gIGNvbnN0IGlzTmF0aXZlID0gbmF0aXZlRXZlbnRzLmhhcyh0eXBlRXZlbnQpXG5cbiAgaWYgKCFpc05hdGl2ZSkge1xuICAgIHR5cGVFdmVudCA9IG9yaWdpbmFsVHlwZUV2ZW50XG4gIH1cblxuICByZXR1cm4gW2RlbGVnYXRpb24sIG9yaWdpbmFsSGFuZGxlciwgdHlwZUV2ZW50XVxufVxuXG5mdW5jdGlvbiBhZGRIYW5kbGVyKGVsZW1lbnQsIG9yaWdpbmFsVHlwZUV2ZW50LCBoYW5kbGVyLCBkZWxlZ2F0aW9uRm4sIG9uZU9mZikge1xuICBpZiAodHlwZW9mIG9yaWdpbmFsVHlwZUV2ZW50ICE9PSAnc3RyaW5nJyB8fCAhZWxlbWVudCkge1xuICAgIHJldHVyblxuICB9XG5cbiAgaWYgKCFoYW5kbGVyKSB7XG4gICAgaGFuZGxlciA9IGRlbGVnYXRpb25GblxuICAgIGRlbGVnYXRpb25GbiA9IG51bGxcbiAgfVxuXG4gIC8vIGluIGNhc2Ugb2YgbW91c2VlbnRlciBvciBtb3VzZWxlYXZlIHdyYXAgdGhlIGhhbmRsZXIgd2l0aGluIGEgZnVuY3Rpb24gdGhhdCBjaGVja3MgZm9yIGl0cyBET00gcG9zaXRpb25cbiAgLy8gdGhpcyBwcmV2ZW50cyB0aGUgaGFuZGxlciBmcm9tIGJlaW5nIGRpc3BhdGNoZWQgdGhlIHNhbWUgd2F5IGFzIG1vdXNlb3ZlciBvciBtb3VzZW91dCBkb2VzXG4gIGlmIChjdXN0b21FdmVudHNSZWdleC50ZXN0KG9yaWdpbmFsVHlwZUV2ZW50KSkge1xuICAgIGNvbnN0IHdyYXBGbiA9IGZuID0+IHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKCFldmVudC5yZWxhdGVkVGFyZ2V0IHx8IChldmVudC5yZWxhdGVkVGFyZ2V0ICE9PSBldmVudC5kZWxlZ2F0ZVRhcmdldCAmJiAhZXZlbnQuZGVsZWdhdGVUYXJnZXQuY29udGFpbnMoZXZlbnQucmVsYXRlZFRhcmdldCkpKSB7XG4gICAgICAgICAgcmV0dXJuIGZuLmNhbGwodGhpcywgZXZlbnQpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZGVsZWdhdGlvbkZuKSB7XG4gICAgICBkZWxlZ2F0aW9uRm4gPSB3cmFwRm4oZGVsZWdhdGlvbkZuKVxuICAgIH0gZWxzZSB7XG4gICAgICBoYW5kbGVyID0gd3JhcEZuKGhhbmRsZXIpXG4gICAgfVxuICB9XG5cbiAgY29uc3QgW2RlbGVnYXRpb24sIG9yaWdpbmFsSGFuZGxlciwgdHlwZUV2ZW50XSA9IG5vcm1hbGl6ZVBhcmFtcyhvcmlnaW5hbFR5cGVFdmVudCwgaGFuZGxlciwgZGVsZWdhdGlvbkZuKVxuICBjb25zdCBldmVudHMgPSBnZXRFdmVudChlbGVtZW50KVxuICBjb25zdCBoYW5kbGVycyA9IGV2ZW50c1t0eXBlRXZlbnRdIHx8IChldmVudHNbdHlwZUV2ZW50XSA9IHt9KVxuICBjb25zdCBwcmV2aW91c0ZuID0gZmluZEhhbmRsZXIoaGFuZGxlcnMsIG9yaWdpbmFsSGFuZGxlciwgZGVsZWdhdGlvbiA/IGhhbmRsZXIgOiBudWxsKVxuXG4gIGlmIChwcmV2aW91c0ZuKSB7XG4gICAgcHJldmlvdXNGbi5vbmVPZmYgPSBwcmV2aW91c0ZuLm9uZU9mZiAmJiBvbmVPZmZcblxuICAgIHJldHVyblxuICB9XG5cbiAgY29uc3QgdWlkID0gZ2V0VWlkRXZlbnQob3JpZ2luYWxIYW5kbGVyLCBvcmlnaW5hbFR5cGVFdmVudC5yZXBsYWNlKG5hbWVzcGFjZVJlZ2V4LCAnJykpXG4gIGNvbnN0IGZuID0gZGVsZWdhdGlvbiA/XG4gICAgYm9vdHN0cmFwRGVsZWdhdGlvbkhhbmRsZXIoZWxlbWVudCwgaGFuZGxlciwgZGVsZWdhdGlvbkZuKSA6XG4gICAgYm9vdHN0cmFwSGFuZGxlcihlbGVtZW50LCBoYW5kbGVyKVxuXG4gIGZuLmRlbGVnYXRpb25TZWxlY3RvciA9IGRlbGVnYXRpb24gPyBoYW5kbGVyIDogbnVsbFxuICBmbi5vcmlnaW5hbEhhbmRsZXIgPSBvcmlnaW5hbEhhbmRsZXJcbiAgZm4ub25lT2ZmID0gb25lT2ZmXG4gIGZuLnVpZEV2ZW50ID0gdWlkXG4gIGhhbmRsZXJzW3VpZF0gPSBmblxuXG4gIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcih0eXBlRXZlbnQsIGZuLCBkZWxlZ2F0aW9uKVxufVxuXG5mdW5jdGlvbiByZW1vdmVIYW5kbGVyKGVsZW1lbnQsIGV2ZW50cywgdHlwZUV2ZW50LCBoYW5kbGVyLCBkZWxlZ2F0aW9uU2VsZWN0b3IpIHtcbiAgY29uc3QgZm4gPSBmaW5kSGFuZGxlcihldmVudHNbdHlwZUV2ZW50XSwgaGFuZGxlciwgZGVsZWdhdGlvblNlbGVjdG9yKVxuXG4gIGlmICghZm4pIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlRXZlbnQsIGZuLCBCb29sZWFuKGRlbGVnYXRpb25TZWxlY3RvcikpXG4gIGRlbGV0ZSBldmVudHNbdHlwZUV2ZW50XVtmbi51aWRFdmVudF1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlTmFtZXNwYWNlZEhhbmRsZXJzKGVsZW1lbnQsIGV2ZW50cywgdHlwZUV2ZW50LCBuYW1lc3BhY2UpIHtcbiAgY29uc3Qgc3RvcmVFbGVtZW50RXZlbnQgPSBldmVudHNbdHlwZUV2ZW50XSB8fCB7fVxuXG4gIE9iamVjdC5rZXlzKHN0b3JlRWxlbWVudEV2ZW50KS5mb3JFYWNoKGhhbmRsZXJLZXkgPT4ge1xuICAgIGlmIChoYW5kbGVyS2V5LmluY2x1ZGVzKG5hbWVzcGFjZSkpIHtcbiAgICAgIGNvbnN0IGV2ZW50ID0gc3RvcmVFbGVtZW50RXZlbnRbaGFuZGxlcktleV1cblxuICAgICAgcmVtb3ZlSGFuZGxlcihlbGVtZW50LCBldmVudHMsIHR5cGVFdmVudCwgZXZlbnQub3JpZ2luYWxIYW5kbGVyLCBldmVudC5kZWxlZ2F0aW9uU2VsZWN0b3IpXG4gICAgfVxuICB9KVxufVxuXG5mdW5jdGlvbiBnZXRUeXBlRXZlbnQoZXZlbnQpIHtcbiAgLy8gYWxsb3cgdG8gZ2V0IHRoZSBuYXRpdmUgZXZlbnRzIGZyb20gbmFtZXNwYWNlZCBldmVudHMgKCdjbGljay5icy5idXR0b24nIC0tPiAnY2xpY2snKVxuICBldmVudCA9IGV2ZW50LnJlcGxhY2Uoc3RyaXBOYW1lUmVnZXgsICcnKVxuICByZXR1cm4gY3VzdG9tRXZlbnRzW2V2ZW50XSB8fCBldmVudFxufVxuXG5jb25zdCBFdmVudEhhbmRsZXIgPSB7XG4gIG9uKGVsZW1lbnQsIGV2ZW50LCBoYW5kbGVyLCBkZWxlZ2F0aW9uRm4pIHtcbiAgICBhZGRIYW5kbGVyKGVsZW1lbnQsIGV2ZW50LCBoYW5kbGVyLCBkZWxlZ2F0aW9uRm4sIGZhbHNlKVxuICB9LFxuXG4gIG9uZShlbGVtZW50LCBldmVudCwgaGFuZGxlciwgZGVsZWdhdGlvbkZuKSB7XG4gICAgYWRkSGFuZGxlcihlbGVtZW50LCBldmVudCwgaGFuZGxlciwgZGVsZWdhdGlvbkZuLCB0cnVlKVxuICB9LFxuXG4gIG9mZihlbGVtZW50LCBvcmlnaW5hbFR5cGVFdmVudCwgaGFuZGxlciwgZGVsZWdhdGlvbkZuKSB7XG4gICAgaWYgKHR5cGVvZiBvcmlnaW5hbFR5cGVFdmVudCAhPT0gJ3N0cmluZycgfHwgIWVsZW1lbnQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IFtkZWxlZ2F0aW9uLCBvcmlnaW5hbEhhbmRsZXIsIHR5cGVFdmVudF0gPSBub3JtYWxpemVQYXJhbXMob3JpZ2luYWxUeXBlRXZlbnQsIGhhbmRsZXIsIGRlbGVnYXRpb25GbilcbiAgICBjb25zdCBpbk5hbWVzcGFjZSA9IHR5cGVFdmVudCAhPT0gb3JpZ2luYWxUeXBlRXZlbnRcbiAgICBjb25zdCBldmVudHMgPSBnZXRFdmVudChlbGVtZW50KVxuICAgIGNvbnN0IGlzTmFtZXNwYWNlID0gb3JpZ2luYWxUeXBlRXZlbnQuc3RhcnRzV2l0aCgnLicpXG5cbiAgICBpZiAodHlwZW9mIG9yaWdpbmFsSGFuZGxlciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIC8vIFNpbXBsZXN0IGNhc2U6IGhhbmRsZXIgaXMgcGFzc2VkLCByZW1vdmUgdGhhdCBsaXN0ZW5lciBPTkxZLlxuICAgICAgaWYgKCFldmVudHMgfHwgIWV2ZW50c1t0eXBlRXZlbnRdKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICByZW1vdmVIYW5kbGVyKGVsZW1lbnQsIGV2ZW50cywgdHlwZUV2ZW50LCBvcmlnaW5hbEhhbmRsZXIsIGRlbGVnYXRpb24gPyBoYW5kbGVyIDogbnVsbClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmIChpc05hbWVzcGFjZSkge1xuICAgICAgT2JqZWN0LmtleXMoZXZlbnRzKS5mb3JFYWNoKGVsZW1lbnRFdmVudCA9PiB7XG4gICAgICAgIHJlbW92ZU5hbWVzcGFjZWRIYW5kbGVycyhlbGVtZW50LCBldmVudHMsIGVsZW1lbnRFdmVudCwgb3JpZ2luYWxUeXBlRXZlbnQuc2xpY2UoMSkpXG4gICAgICB9KVxuICAgIH1cblxuICAgIGNvbnN0IHN0b3JlRWxlbWVudEV2ZW50ID0gZXZlbnRzW3R5cGVFdmVudF0gfHwge31cbiAgICBPYmplY3Qua2V5cyhzdG9yZUVsZW1lbnRFdmVudCkuZm9yRWFjaChrZXlIYW5kbGVycyA9PiB7XG4gICAgICBjb25zdCBoYW5kbGVyS2V5ID0ga2V5SGFuZGxlcnMucmVwbGFjZShzdHJpcFVpZFJlZ2V4LCAnJylcblxuICAgICAgaWYgKCFpbk5hbWVzcGFjZSB8fCBvcmlnaW5hbFR5cGVFdmVudC5pbmNsdWRlcyhoYW5kbGVyS2V5KSkge1xuICAgICAgICBjb25zdCBldmVudCA9IHN0b3JlRWxlbWVudEV2ZW50W2tleUhhbmRsZXJzXVxuXG4gICAgICAgIHJlbW92ZUhhbmRsZXIoZWxlbWVudCwgZXZlbnRzLCB0eXBlRXZlbnQsIGV2ZW50Lm9yaWdpbmFsSGFuZGxlciwgZXZlbnQuZGVsZWdhdGlvblNlbGVjdG9yKVxuICAgICAgfVxuICAgIH0pXG4gIH0sXG5cbiAgdHJpZ2dlcihlbGVtZW50LCBldmVudCwgYXJncykge1xuICAgIGlmICh0eXBlb2YgZXZlbnQgIT09ICdzdHJpbmcnIHx8ICFlbGVtZW50KSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cblxuICAgIGNvbnN0ICQgPSBnZXRqUXVlcnkoKVxuICAgIGNvbnN0IHR5cGVFdmVudCA9IGdldFR5cGVFdmVudChldmVudClcbiAgICBjb25zdCBpbk5hbWVzcGFjZSA9IGV2ZW50ICE9PSB0eXBlRXZlbnRcbiAgICBjb25zdCBpc05hdGl2ZSA9IG5hdGl2ZUV2ZW50cy5oYXModHlwZUV2ZW50KVxuXG4gICAgbGV0IGpRdWVyeUV2ZW50XG4gICAgbGV0IGJ1YmJsZXMgPSB0cnVlXG4gICAgbGV0IG5hdGl2ZURpc3BhdGNoID0gdHJ1ZVxuICAgIGxldCBkZWZhdWx0UHJldmVudGVkID0gZmFsc2VcbiAgICBsZXQgZXZ0ID0gbnVsbFxuXG4gICAgaWYgKGluTmFtZXNwYWNlICYmICQpIHtcbiAgICAgIGpRdWVyeUV2ZW50ID0gJC5FdmVudChldmVudCwgYXJncylcblxuICAgICAgJChlbGVtZW50KS50cmlnZ2VyKGpRdWVyeUV2ZW50KVxuICAgICAgYnViYmxlcyA9ICFqUXVlcnlFdmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpXG4gICAgICBuYXRpdmVEaXNwYXRjaCA9ICFqUXVlcnlFdmVudC5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCgpXG4gICAgICBkZWZhdWx0UHJldmVudGVkID0galF1ZXJ5RXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKClcbiAgICB9XG5cbiAgICBpZiAoaXNOYXRpdmUpIHtcbiAgICAgIGV2dCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdIVE1MRXZlbnRzJylcbiAgICAgIGV2dC5pbml0RXZlbnQodHlwZUV2ZW50LCBidWJibGVzLCB0cnVlKVxuICAgIH0gZWxzZSB7XG4gICAgICBldnQgPSBuZXcgQ3VzdG9tRXZlbnQoZXZlbnQsIHtcbiAgICAgICAgYnViYmxlcyxcbiAgICAgICAgY2FuY2VsYWJsZTogdHJ1ZVxuICAgICAgfSlcbiAgICB9XG5cbiAgICAvLyBtZXJnZSBjdXN0b20gaW5mb3JtYXRpb24gaW4gb3VyIGV2ZW50XG4gICAgaWYgKHR5cGVvZiBhcmdzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgT2JqZWN0LmtleXMoYXJncykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXZ0LCBrZXksIHtcbiAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJnc1trZXldXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICB9XG5cbiAgICBpZiAoZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KClcbiAgICB9XG5cbiAgICBpZiAobmF0aXZlRGlzcGF0Y2gpIHtcbiAgICAgIGVsZW1lbnQuZGlzcGF0Y2hFdmVudChldnQpXG4gICAgfVxuXG4gICAgaWYgKGV2dC5kZWZhdWx0UHJldmVudGVkICYmIHR5cGVvZiBqUXVlcnlFdmVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGpRdWVyeUV2ZW50LnByZXZlbnREZWZhdWx0KClcbiAgICB9XG5cbiAgICByZXR1cm4gZXZ0XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgRXZlbnRIYW5kbGVyXG4iLCIvKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBCb290c3RyYXAgKHY1LjAuMik6IGRvbS9kYXRhLmpzXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvbnN0YW50c1xuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuY29uc3QgZWxlbWVudE1hcCA9IG5ldyBNYXAoKVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIHNldChlbGVtZW50LCBrZXksIGluc3RhbmNlKSB7XG4gICAgaWYgKCFlbGVtZW50TWFwLmhhcyhlbGVtZW50KSkge1xuICAgICAgZWxlbWVudE1hcC5zZXQoZWxlbWVudCwgbmV3IE1hcCgpKVxuICAgIH1cblxuICAgIGNvbnN0IGluc3RhbmNlTWFwID0gZWxlbWVudE1hcC5nZXQoZWxlbWVudClcblxuICAgIC8vIG1ha2UgaXQgY2xlYXIgd2Ugb25seSB3YW50IG9uZSBpbnN0YW5jZSBwZXIgZWxlbWVudFxuICAgIC8vIGNhbiBiZSByZW1vdmVkIGxhdGVyIHdoZW4gbXVsdGlwbGUga2V5L2luc3RhbmNlcyBhcmUgZmluZSB0byBiZSB1c2VkXG4gICAgaWYgKCFpbnN0YW5jZU1hcC5oYXMoa2V5KSAmJiBpbnN0YW5jZU1hcC5zaXplICE9PSAwKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgY29uc29sZS5lcnJvcihgQm9vdHN0cmFwIGRvZXNuJ3QgYWxsb3cgbW9yZSB0aGFuIG9uZSBpbnN0YW5jZSBwZXIgZWxlbWVudC4gQm91bmQgaW5zdGFuY2U6ICR7QXJyYXkuZnJvbShpbnN0YW5jZU1hcC5rZXlzKCkpWzBdfS5gKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaW5zdGFuY2VNYXAuc2V0KGtleSwgaW5zdGFuY2UpXG4gIH0sXG5cbiAgZ2V0KGVsZW1lbnQsIGtleSkge1xuICAgIGlmIChlbGVtZW50TWFwLmhhcyhlbGVtZW50KSkge1xuICAgICAgcmV0dXJuIGVsZW1lbnRNYXAuZ2V0KGVsZW1lbnQpLmdldChrZXkpIHx8IG51bGxcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbFxuICB9LFxuXG4gIHJlbW92ZShlbGVtZW50LCBrZXkpIHtcbiAgICBpZiAoIWVsZW1lbnRNYXAuaGFzKGVsZW1lbnQpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCBpbnN0YW5jZU1hcCA9IGVsZW1lbnRNYXAuZ2V0KGVsZW1lbnQpXG5cbiAgICBpbnN0YW5jZU1hcC5kZWxldGUoa2V5KVxuXG4gICAgLy8gZnJlZSB1cCBlbGVtZW50IHJlZmVyZW5jZXMgaWYgdGhlcmUgYXJlIG5vIGluc3RhbmNlcyBsZWZ0IGZvciBhbiBlbGVtZW50XG4gICAgaWYgKGluc3RhbmNlTWFwLnNpemUgPT09IDApIHtcbiAgICAgIGVsZW1lbnRNYXAuZGVsZXRlKGVsZW1lbnQpXG4gICAgfVxuICB9XG59XG4iLCIvKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBCb290c3RyYXAgKHY1LjAuMik6IGJhc2UtY29tcG9uZW50LmpzXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuaW1wb3J0IERhdGEgZnJvbSAnLi9kb20vZGF0YSdcbmltcG9ydCB7XG4gIGV4ZWN1dGVBZnRlclRyYW5zaXRpb24sXG4gIGdldEVsZW1lbnRcbn0gZnJvbSAnLi91dGlsL2luZGV4J1xuaW1wb3J0IEV2ZW50SGFuZGxlciBmcm9tICcuL2RvbS9ldmVudC1oYW5kbGVyJ1xuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29uc3RhbnRzXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5jb25zdCBWRVJTSU9OID0gJzUuMC4yJ1xuXG5jbGFzcyBCYXNlQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IoZWxlbWVudCkge1xuICAgIGVsZW1lbnQgPSBnZXRFbGVtZW50KGVsZW1lbnQpXG5cbiAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMuX2VsZW1lbnQgPSBlbGVtZW50XG4gICAgRGF0YS5zZXQodGhpcy5fZWxlbWVudCwgdGhpcy5jb25zdHJ1Y3Rvci5EQVRBX0tFWSwgdGhpcylcbiAgfVxuXG4gIGRpc3Bvc2UoKSB7XG4gICAgRGF0YS5yZW1vdmUodGhpcy5fZWxlbWVudCwgdGhpcy5jb25zdHJ1Y3Rvci5EQVRBX0tFWSlcbiAgICBFdmVudEhhbmRsZXIub2ZmKHRoaXMuX2VsZW1lbnQsIHRoaXMuY29uc3RydWN0b3IuRVZFTlRfS0VZKVxuXG4gICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGhpcykuZm9yRWFjaChwcm9wZXJ0eU5hbWUgPT4ge1xuICAgICAgdGhpc1twcm9wZXJ0eU5hbWVdID0gbnVsbFxuICAgIH0pXG4gIH1cblxuICBfcXVldWVDYWxsYmFjayhjYWxsYmFjaywgZWxlbWVudCwgaXNBbmltYXRlZCA9IHRydWUpIHtcbiAgICBleGVjdXRlQWZ0ZXJUcmFuc2l0aW9uKGNhbGxiYWNrLCBlbGVtZW50LCBpc0FuaW1hdGVkKVxuICB9XG5cbiAgLyoqIFN0YXRpYyAqL1xuXG4gIHN0YXRpYyBnZXRJbnN0YW5jZShlbGVtZW50KSB7XG4gICAgcmV0dXJuIERhdGEuZ2V0KGVsZW1lbnQsIHRoaXMuREFUQV9LRVkpXG4gIH1cblxuICBzdGF0aWMgZ2V0T3JDcmVhdGVJbnN0YW5jZShlbGVtZW50LCBjb25maWcgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLmdldEluc3RhbmNlKGVsZW1lbnQpIHx8IG5ldyB0aGlzKGVsZW1lbnQsIHR5cGVvZiBjb25maWcgPT09ICdvYmplY3QnID8gY29uZmlnIDogbnVsbClcbiAgfVxuXG4gIHN0YXRpYyBnZXQgVkVSU0lPTigpIHtcbiAgICByZXR1cm4gVkVSU0lPTlxuICB9XG5cbiAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignWW91IGhhdmUgdG8gaW1wbGVtZW50IHRoZSBzdGF0aWMgbWV0aG9kIFwiTkFNRVwiLCBmb3IgZWFjaCBjb21wb25lbnQhJylcbiAgfVxuXG4gIHN0YXRpYyBnZXQgREFUQV9LRVkoKSB7XG4gICAgcmV0dXJuIGBicy4ke3RoaXMuTkFNRX1gXG4gIH1cblxuICBzdGF0aWMgZ2V0IEVWRU5UX0tFWSgpIHtcbiAgICByZXR1cm4gYC4ke3RoaXMuREFUQV9LRVl9YFxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEJhc2VDb21wb25lbnRcbiIsIi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEJvb3RzdHJhcCAodjUuMC4yKTogYWxlcnQuanNcbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5pbXBvcnQge1xuICBkZWZpbmVKUXVlcnlQbHVnaW4sXG4gIGdldEVsZW1lbnRGcm9tU2VsZWN0b3Jcbn0gZnJvbSAnLi91dGlsL2luZGV4J1xuaW1wb3J0IEV2ZW50SGFuZGxlciBmcm9tICcuL2RvbS9ldmVudC1oYW5kbGVyJ1xuaW1wb3J0IEJhc2VDb21wb25lbnQgZnJvbSAnLi9iYXNlLWNvbXBvbmVudCdcblxuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvbnN0YW50c1xuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuY29uc3QgTkFNRSA9ICdhbGVydCdcbmNvbnN0IERBVEFfS0VZID0gJ2JzLmFsZXJ0J1xuY29uc3QgRVZFTlRfS0VZID0gYC4ke0RBVEFfS0VZfWBcbmNvbnN0IERBVEFfQVBJX0tFWSA9ICcuZGF0YS1hcGknXG5cbmNvbnN0IFNFTEVDVE9SX0RJU01JU1MgPSAnW2RhdGEtYnMtZGlzbWlzcz1cImFsZXJ0XCJdJ1xuXG5jb25zdCBFVkVOVF9DTE9TRSA9IGBjbG9zZSR7RVZFTlRfS0VZfWBcbmNvbnN0IEVWRU5UX0NMT1NFRCA9IGBjbG9zZWQke0VWRU5UX0tFWX1gXG5jb25zdCBFVkVOVF9DTElDS19EQVRBX0FQSSA9IGBjbGljayR7RVZFTlRfS0VZfSR7REFUQV9BUElfS0VZfWBcblxuY29uc3QgQ0xBU1NfTkFNRV9BTEVSVCA9ICdhbGVydCdcbmNvbnN0IENMQVNTX05BTUVfRkFERSA9ICdmYWRlJ1xuY29uc3QgQ0xBU1NfTkFNRV9TSE9XID0gJ3Nob3cnXG5cbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDbGFzcyBEZWZpbml0aW9uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5jbGFzcyBBbGVydCBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICAvLyBHZXR0ZXJzXG5cbiAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgIHJldHVybiBOQU1FXG4gIH1cblxuICAvLyBQdWJsaWNcblxuICBjbG9zZShlbGVtZW50KSB7XG4gICAgY29uc3Qgcm9vdEVsZW1lbnQgPSBlbGVtZW50ID8gdGhpcy5fZ2V0Um9vdEVsZW1lbnQoZWxlbWVudCkgOiB0aGlzLl9lbGVtZW50XG4gICAgY29uc3QgY3VzdG9tRXZlbnQgPSB0aGlzLl90cmlnZ2VyQ2xvc2VFdmVudChyb290RWxlbWVudClcblxuICAgIGlmIChjdXN0b21FdmVudCA9PT0gbnVsbCB8fCBjdXN0b21FdmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLl9yZW1vdmVFbGVtZW50KHJvb3RFbGVtZW50KVxuICB9XG5cbiAgLy8gUHJpdmF0ZVxuXG4gIF9nZXRSb290RWxlbWVudChlbGVtZW50KSB7XG4gICAgcmV0dXJuIGdldEVsZW1lbnRGcm9tU2VsZWN0b3IoZWxlbWVudCkgfHwgZWxlbWVudC5jbG9zZXN0KGAuJHtDTEFTU19OQU1FX0FMRVJUfWApXG4gIH1cblxuICBfdHJpZ2dlckNsb3NlRXZlbnQoZWxlbWVudCkge1xuICAgIHJldHVybiBFdmVudEhhbmRsZXIudHJpZ2dlcihlbGVtZW50LCBFVkVOVF9DTE9TRSlcbiAgfVxuXG4gIF9yZW1vdmVFbGVtZW50KGVsZW1lbnQpIHtcbiAgICBlbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9TSE9XKVxuXG4gICAgY29uc3QgaXNBbmltYXRlZCA9IGVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfRkFERSlcbiAgICB0aGlzLl9xdWV1ZUNhbGxiYWNrKCgpID0+IHRoaXMuX2Rlc3Ryb3lFbGVtZW50KGVsZW1lbnQpLCBlbGVtZW50LCBpc0FuaW1hdGVkKVxuICB9XG5cbiAgX2Rlc3Ryb3lFbGVtZW50KGVsZW1lbnQpIHtcbiAgICBlbGVtZW50LnJlbW92ZSgpXG5cbiAgICBFdmVudEhhbmRsZXIudHJpZ2dlcihlbGVtZW50LCBFVkVOVF9DTE9TRUQpXG4gIH1cblxuICAvLyBTdGF0aWNcblxuICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKGNvbmZpZykge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgY29uc3QgZGF0YSA9IEFsZXJ0LmdldE9yQ3JlYXRlSW5zdGFuY2UodGhpcylcblxuICAgICAgaWYgKGNvbmZpZyA9PT0gJ2Nsb3NlJykge1xuICAgICAgICBkYXRhW2NvbmZpZ10odGhpcylcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgc3RhdGljIGhhbmRsZURpc21pc3MoYWxlcnRJbnN0YW5jZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIGlmIChldmVudCkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICB9XG5cbiAgICAgIGFsZXJ0SW5zdGFuY2UuY2xvc2UodGhpcylcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIERhdGEgQXBpIGltcGxlbWVudGF0aW9uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5FdmVudEhhbmRsZXIub24oZG9jdW1lbnQsIEVWRU5UX0NMSUNLX0RBVEFfQVBJLCBTRUxFQ1RPUl9ESVNNSVNTLCBBbGVydC5oYW5kbGVEaXNtaXNzKG5ldyBBbGVydCgpKSlcblxuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIGpRdWVyeVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBhZGQgLkFsZXJ0IHRvIGpRdWVyeSBvbmx5IGlmIGpRdWVyeSBpcyBwcmVzZW50XG4gKi9cblxuZGVmaW5lSlF1ZXJ5UGx1Z2luKEFsZXJ0KVxuXG5leHBvcnQgZGVmYXVsdCBBbGVydFxuIiwiLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQm9vdHN0cmFwICh2NS4wLjIpOiBidXR0b24uanNcbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5pbXBvcnQgeyBkZWZpbmVKUXVlcnlQbHVnaW4gfSBmcm9tICcuL3V0aWwvaW5kZXgnXG5pbXBvcnQgRXZlbnRIYW5kbGVyIGZyb20gJy4vZG9tL2V2ZW50LWhhbmRsZXInXG5pbXBvcnQgQmFzZUNvbXBvbmVudCBmcm9tICcuL2Jhc2UtY29tcG9uZW50J1xuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29uc3RhbnRzXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5jb25zdCBOQU1FID0gJ2J1dHRvbidcbmNvbnN0IERBVEFfS0VZID0gJ2JzLmJ1dHRvbidcbmNvbnN0IEVWRU5UX0tFWSA9IGAuJHtEQVRBX0tFWX1gXG5jb25zdCBEQVRBX0FQSV9LRVkgPSAnLmRhdGEtYXBpJ1xuXG5jb25zdCBDTEFTU19OQU1FX0FDVElWRSA9ICdhY3RpdmUnXG5cbmNvbnN0IFNFTEVDVE9SX0RBVEFfVE9HR0xFID0gJ1tkYXRhLWJzLXRvZ2dsZT1cImJ1dHRvblwiXSdcblxuY29uc3QgRVZFTlRfQ0xJQ0tfREFUQV9BUEkgPSBgY2xpY2ske0VWRU5UX0tFWX0ke0RBVEFfQVBJX0tFWX1gXG5cbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDbGFzcyBEZWZpbml0aW9uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5jbGFzcyBCdXR0b24gZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgLy8gR2V0dGVyc1xuXG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICByZXR1cm4gTkFNRVxuICB9XG5cbiAgLy8gUHVibGljXG5cbiAgdG9nZ2xlKCkge1xuICAgIC8vIFRvZ2dsZSBjbGFzcyBhbmQgc3luYyB0aGUgYGFyaWEtcHJlc3NlZGAgYXR0cmlidXRlIHdpdGggdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgYC50b2dnbGUoKWAgbWV0aG9kXG4gICAgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtcHJlc3NlZCcsIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LnRvZ2dsZShDTEFTU19OQU1FX0FDVElWRSkpXG4gIH1cblxuICAvLyBTdGF0aWNcblxuICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKGNvbmZpZykge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgY29uc3QgZGF0YSA9IEJ1dHRvbi5nZXRPckNyZWF0ZUluc3RhbmNlKHRoaXMpXG5cbiAgICAgIGlmIChjb25maWcgPT09ICd0b2dnbGUnKSB7XG4gICAgICAgIGRhdGFbY29uZmlnXSgpXG4gICAgICB9XG4gICAgfSlcbiAgfVxufVxuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogRGF0YSBBcGkgaW1wbGVtZW50YXRpb25cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbkV2ZW50SGFuZGxlci5vbihkb2N1bWVudCwgRVZFTlRfQ0xJQ0tfREFUQV9BUEksIFNFTEVDVE9SX0RBVEFfVE9HR0xFLCBldmVudCA9PiB7XG4gIGV2ZW50LnByZXZlbnREZWZhdWx0KClcblxuICBjb25zdCBidXR0b24gPSBldmVudC50YXJnZXQuY2xvc2VzdChTRUxFQ1RPUl9EQVRBX1RPR0dMRSlcbiAgY29uc3QgZGF0YSA9IEJ1dHRvbi5nZXRPckNyZWF0ZUluc3RhbmNlKGJ1dHRvbilcblxuICBkYXRhLnRvZ2dsZSgpXG59KVxuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogalF1ZXJ5XG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIGFkZCAuQnV0dG9uIHRvIGpRdWVyeSBvbmx5IGlmIGpRdWVyeSBpcyBwcmVzZW50XG4gKi9cblxuZGVmaW5lSlF1ZXJ5UGx1Z2luKEJ1dHRvbilcblxuZXhwb3J0IGRlZmF1bHQgQnV0dG9uXG4iLCIvKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBCb290c3RyYXAgKHY1LjAuMik6IGRvbS9tYW5pcHVsYXRvci5qc1xuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZURhdGEodmFsKSB7XG4gIGlmICh2YWwgPT09ICd0cnVlJykge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBpZiAodmFsID09PSAnZmFsc2UnKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBpZiAodmFsID09PSBOdW1iZXIodmFsKS50b1N0cmluZygpKSB7XG4gICAgcmV0dXJuIE51bWJlcih2YWwpXG4gIH1cblxuICBpZiAodmFsID09PSAnJyB8fCB2YWwgPT09ICdudWxsJykge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZURhdGFLZXkoa2V5KSB7XG4gIHJldHVybiBrZXkucmVwbGFjZSgvW0EtWl0vZywgY2hyID0+IGAtJHtjaHIudG9Mb3dlckNhc2UoKX1gKVxufVxuXG5jb25zdCBNYW5pcHVsYXRvciA9IHtcbiAgc2V0RGF0YUF0dHJpYnV0ZShlbGVtZW50LCBrZXksIHZhbHVlKSB7XG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoYGRhdGEtYnMtJHtub3JtYWxpemVEYXRhS2V5KGtleSl9YCwgdmFsdWUpXG4gIH0sXG5cbiAgcmVtb3ZlRGF0YUF0dHJpYnV0ZShlbGVtZW50LCBrZXkpIHtcbiAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShgZGF0YS1icy0ke25vcm1hbGl6ZURhdGFLZXkoa2V5KX1gKVxuICB9LFxuXG4gIGdldERhdGFBdHRyaWJ1dGVzKGVsZW1lbnQpIHtcbiAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgIHJldHVybiB7fVxuICAgIH1cblxuICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSB7fVxuXG4gICAgT2JqZWN0LmtleXMoZWxlbWVudC5kYXRhc2V0KVxuICAgICAgLmZpbHRlcihrZXkgPT4ga2V5LnN0YXJ0c1dpdGgoJ2JzJykpXG4gICAgICAuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICBsZXQgcHVyZUtleSA9IGtleS5yZXBsYWNlKC9eYnMvLCAnJylcbiAgICAgICAgcHVyZUtleSA9IHB1cmVLZXkuY2hhckF0KDApLnRvTG93ZXJDYXNlKCkgKyBwdXJlS2V5LnNsaWNlKDEsIHB1cmVLZXkubGVuZ3RoKVxuICAgICAgICBhdHRyaWJ1dGVzW3B1cmVLZXldID0gbm9ybWFsaXplRGF0YShlbGVtZW50LmRhdGFzZXRba2V5XSlcbiAgICAgIH0pXG5cbiAgICByZXR1cm4gYXR0cmlidXRlc1xuICB9LFxuXG4gIGdldERhdGFBdHRyaWJ1dGUoZWxlbWVudCwga2V5KSB7XG4gICAgcmV0dXJuIG5vcm1hbGl6ZURhdGEoZWxlbWVudC5nZXRBdHRyaWJ1dGUoYGRhdGEtYnMtJHtub3JtYWxpemVEYXRhS2V5KGtleSl9YCkpXG4gIH0sXG5cbiAgb2Zmc2V0KGVsZW1lbnQpIHtcbiAgICBjb25zdCByZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHRvcDogcmVjdC50b3AgKyBkb2N1bWVudC5ib2R5LnNjcm9sbFRvcCxcbiAgICAgIGxlZnQ6IHJlY3QubGVmdCArIGRvY3VtZW50LmJvZHkuc2Nyb2xsTGVmdFxuICAgIH1cbiAgfSxcblxuICBwb3NpdGlvbihlbGVtZW50KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRvcDogZWxlbWVudC5vZmZzZXRUb3AsXG4gICAgICBsZWZ0OiBlbGVtZW50Lm9mZnNldExlZnRcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTWFuaXB1bGF0b3JcbiIsIi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEJvb3RzdHJhcCAodjUuMC4yKTogY2Fyb3VzZWwuanNcbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5pbXBvcnQge1xuICBkZWZpbmVKUXVlcnlQbHVnaW4sXG4gIGdldEVsZW1lbnRGcm9tU2VsZWN0b3IsXG4gIGlzUlRMLFxuICBpc1Zpc2libGUsXG4gIGdldE5leHRBY3RpdmVFbGVtZW50LFxuICByZWZsb3csXG4gIHRyaWdnZXJUcmFuc2l0aW9uRW5kLFxuICB0eXBlQ2hlY2tDb25maWdcbn0gZnJvbSAnLi91dGlsL2luZGV4J1xuaW1wb3J0IEV2ZW50SGFuZGxlciBmcm9tICcuL2RvbS9ldmVudC1oYW5kbGVyJ1xuaW1wb3J0IE1hbmlwdWxhdG9yIGZyb20gJy4vZG9tL21hbmlwdWxhdG9yJ1xuaW1wb3J0IFNlbGVjdG9yRW5naW5lIGZyb20gJy4vZG9tL3NlbGVjdG9yLWVuZ2luZSdcbmltcG9ydCBCYXNlQ29tcG9uZW50IGZyb20gJy4vYmFzZS1jb21wb25lbnQnXG5cbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb25zdGFudHNcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbmNvbnN0IE5BTUUgPSAnY2Fyb3VzZWwnXG5jb25zdCBEQVRBX0tFWSA9ICdicy5jYXJvdXNlbCdcbmNvbnN0IEVWRU5UX0tFWSA9IGAuJHtEQVRBX0tFWX1gXG5jb25zdCBEQVRBX0FQSV9LRVkgPSAnLmRhdGEtYXBpJ1xuXG5jb25zdCBBUlJPV19MRUZUX0tFWSA9ICdBcnJvd0xlZnQnXG5jb25zdCBBUlJPV19SSUdIVF9LRVkgPSAnQXJyb3dSaWdodCdcbmNvbnN0IFRPVUNIRVZFTlRfQ09NUEFUX1dBSVQgPSA1MDAgLy8gVGltZSBmb3IgbW91c2UgY29tcGF0IGV2ZW50cyB0byBmaXJlIGFmdGVyIHRvdWNoXG5jb25zdCBTV0lQRV9USFJFU0hPTEQgPSA0MFxuXG5jb25zdCBEZWZhdWx0ID0ge1xuICBpbnRlcnZhbDogNTAwMCxcbiAga2V5Ym9hcmQ6IHRydWUsXG4gIHNsaWRlOiBmYWxzZSxcbiAgcGF1c2U6ICdob3ZlcicsXG4gIHdyYXA6IHRydWUsXG4gIHRvdWNoOiB0cnVlXG59XG5cbmNvbnN0IERlZmF1bHRUeXBlID0ge1xuICBpbnRlcnZhbDogJyhudW1iZXJ8Ym9vbGVhbiknLFxuICBrZXlib2FyZDogJ2Jvb2xlYW4nLFxuICBzbGlkZTogJyhib29sZWFufHN0cmluZyknLFxuICBwYXVzZTogJyhzdHJpbmd8Ym9vbGVhbiknLFxuICB3cmFwOiAnYm9vbGVhbicsXG4gIHRvdWNoOiAnYm9vbGVhbidcbn1cblxuY29uc3QgT1JERVJfTkVYVCA9ICduZXh0J1xuY29uc3QgT1JERVJfUFJFViA9ICdwcmV2J1xuY29uc3QgRElSRUNUSU9OX0xFRlQgPSAnbGVmdCdcbmNvbnN0IERJUkVDVElPTl9SSUdIVCA9ICdyaWdodCdcblxuY29uc3QgS0VZX1RPX0RJUkVDVElPTiA9IHtcbiAgW0FSUk9XX0xFRlRfS0VZXTogRElSRUNUSU9OX1JJR0hULFxuICBbQVJST1dfUklHSFRfS0VZXTogRElSRUNUSU9OX0xFRlRcbn1cblxuY29uc3QgRVZFTlRfU0xJREUgPSBgc2xpZGUke0VWRU5UX0tFWX1gXG5jb25zdCBFVkVOVF9TTElEID0gYHNsaWQke0VWRU5UX0tFWX1gXG5jb25zdCBFVkVOVF9LRVlET1dOID0gYGtleWRvd24ke0VWRU5UX0tFWX1gXG5jb25zdCBFVkVOVF9NT1VTRUVOVEVSID0gYG1vdXNlZW50ZXIke0VWRU5UX0tFWX1gXG5jb25zdCBFVkVOVF9NT1VTRUxFQVZFID0gYG1vdXNlbGVhdmUke0VWRU5UX0tFWX1gXG5jb25zdCBFVkVOVF9UT1VDSFNUQVJUID0gYHRvdWNoc3RhcnQke0VWRU5UX0tFWX1gXG5jb25zdCBFVkVOVF9UT1VDSE1PVkUgPSBgdG91Y2htb3ZlJHtFVkVOVF9LRVl9YFxuY29uc3QgRVZFTlRfVE9VQ0hFTkQgPSBgdG91Y2hlbmQke0VWRU5UX0tFWX1gXG5jb25zdCBFVkVOVF9QT0lOVEVSRE9XTiA9IGBwb2ludGVyZG93biR7RVZFTlRfS0VZfWBcbmNvbnN0IEVWRU5UX1BPSU5URVJVUCA9IGBwb2ludGVydXAke0VWRU5UX0tFWX1gXG5jb25zdCBFVkVOVF9EUkFHX1NUQVJUID0gYGRyYWdzdGFydCR7RVZFTlRfS0VZfWBcbmNvbnN0IEVWRU5UX0xPQURfREFUQV9BUEkgPSBgbG9hZCR7RVZFTlRfS0VZfSR7REFUQV9BUElfS0VZfWBcbmNvbnN0IEVWRU5UX0NMSUNLX0RBVEFfQVBJID0gYGNsaWNrJHtFVkVOVF9LRVl9JHtEQVRBX0FQSV9LRVl9YFxuXG5jb25zdCBDTEFTU19OQU1FX0NBUk9VU0VMID0gJ2Nhcm91c2VsJ1xuY29uc3QgQ0xBU1NfTkFNRV9BQ1RJVkUgPSAnYWN0aXZlJ1xuY29uc3QgQ0xBU1NfTkFNRV9TTElERSA9ICdzbGlkZSdcbmNvbnN0IENMQVNTX05BTUVfRU5EID0gJ2Nhcm91c2VsLWl0ZW0tZW5kJ1xuY29uc3QgQ0xBU1NfTkFNRV9TVEFSVCA9ICdjYXJvdXNlbC1pdGVtLXN0YXJ0J1xuY29uc3QgQ0xBU1NfTkFNRV9ORVhUID0gJ2Nhcm91c2VsLWl0ZW0tbmV4dCdcbmNvbnN0IENMQVNTX05BTUVfUFJFViA9ICdjYXJvdXNlbC1pdGVtLXByZXYnXG5jb25zdCBDTEFTU19OQU1FX1BPSU5URVJfRVZFTlQgPSAncG9pbnRlci1ldmVudCdcblxuY29uc3QgU0VMRUNUT1JfQUNUSVZFID0gJy5hY3RpdmUnXG5jb25zdCBTRUxFQ1RPUl9BQ1RJVkVfSVRFTSA9ICcuYWN0aXZlLmNhcm91c2VsLWl0ZW0nXG5jb25zdCBTRUxFQ1RPUl9JVEVNID0gJy5jYXJvdXNlbC1pdGVtJ1xuY29uc3QgU0VMRUNUT1JfSVRFTV9JTUcgPSAnLmNhcm91c2VsLWl0ZW0gaW1nJ1xuY29uc3QgU0VMRUNUT1JfTkVYVF9QUkVWID0gJy5jYXJvdXNlbC1pdGVtLW5leHQsIC5jYXJvdXNlbC1pdGVtLXByZXYnXG5jb25zdCBTRUxFQ1RPUl9JTkRJQ0FUT1JTID0gJy5jYXJvdXNlbC1pbmRpY2F0b3JzJ1xuY29uc3QgU0VMRUNUT1JfSU5ESUNBVE9SID0gJ1tkYXRhLWJzLXRhcmdldF0nXG5jb25zdCBTRUxFQ1RPUl9EQVRBX1NMSURFID0gJ1tkYXRhLWJzLXNsaWRlXSwgW2RhdGEtYnMtc2xpZGUtdG9dJ1xuY29uc3QgU0VMRUNUT1JfREFUQV9SSURFID0gJ1tkYXRhLWJzLXJpZGU9XCJjYXJvdXNlbFwiXSdcblxuY29uc3QgUE9JTlRFUl9UWVBFX1RPVUNIID0gJ3RvdWNoJ1xuY29uc3QgUE9JTlRFUl9UWVBFX1BFTiA9ICdwZW4nXG5cbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDbGFzcyBEZWZpbml0aW9uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuY2xhc3MgQ2Fyb3VzZWwgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IoZWxlbWVudCwgY29uZmlnKSB7XG4gICAgc3VwZXIoZWxlbWVudClcblxuICAgIHRoaXMuX2l0ZW1zID0gbnVsbFxuICAgIHRoaXMuX2ludGVydmFsID0gbnVsbFxuICAgIHRoaXMuX2FjdGl2ZUVsZW1lbnQgPSBudWxsXG4gICAgdGhpcy5faXNQYXVzZWQgPSBmYWxzZVxuICAgIHRoaXMuX2lzU2xpZGluZyA9IGZhbHNlXG4gICAgdGhpcy50b3VjaFRpbWVvdXQgPSBudWxsXG4gICAgdGhpcy50b3VjaFN0YXJ0WCA9IDBcbiAgICB0aGlzLnRvdWNoRGVsdGFYID0gMFxuXG4gICAgdGhpcy5fY29uZmlnID0gdGhpcy5fZ2V0Q29uZmlnKGNvbmZpZylcbiAgICB0aGlzLl9pbmRpY2F0b3JzRWxlbWVudCA9IFNlbGVjdG9yRW5naW5lLmZpbmRPbmUoU0VMRUNUT1JfSU5ESUNBVE9SUywgdGhpcy5fZWxlbWVudClcbiAgICB0aGlzLl90b3VjaFN1cHBvcnRlZCA9ICdvbnRvdWNoc3RhcnQnIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCB8fCBuYXZpZ2F0b3IubWF4VG91Y2hQb2ludHMgPiAwXG4gICAgdGhpcy5fcG9pbnRlckV2ZW50ID0gQm9vbGVhbih3aW5kb3cuUG9pbnRlckV2ZW50KVxuXG4gICAgdGhpcy5fYWRkRXZlbnRMaXN0ZW5lcnMoKVxuICB9XG5cbiAgLy8gR2V0dGVyc1xuXG4gIHN0YXRpYyBnZXQgRGVmYXVsdCgpIHtcbiAgICByZXR1cm4gRGVmYXVsdFxuICB9XG5cbiAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgIHJldHVybiBOQU1FXG4gIH1cblxuICAvLyBQdWJsaWNcblxuICBuZXh0KCkge1xuICAgIHRoaXMuX3NsaWRlKE9SREVSX05FWFQpXG4gIH1cblxuICBuZXh0V2hlblZpc2libGUoKSB7XG4gICAgLy8gRG9uJ3QgY2FsbCBuZXh0IHdoZW4gdGhlIHBhZ2UgaXNuJ3QgdmlzaWJsZVxuICAgIC8vIG9yIHRoZSBjYXJvdXNlbCBvciBpdHMgcGFyZW50IGlzbid0IHZpc2libGVcbiAgICBpZiAoIWRvY3VtZW50LmhpZGRlbiAmJiBpc1Zpc2libGUodGhpcy5fZWxlbWVudCkpIHtcbiAgICAgIHRoaXMubmV4dCgpXG4gICAgfVxuICB9XG5cbiAgcHJldigpIHtcbiAgICB0aGlzLl9zbGlkZShPUkRFUl9QUkVWKVxuICB9XG5cbiAgcGF1c2UoZXZlbnQpIHtcbiAgICBpZiAoIWV2ZW50KSB7XG4gICAgICB0aGlzLl9pc1BhdXNlZCA9IHRydWVcbiAgICB9XG5cbiAgICBpZiAoU2VsZWN0b3JFbmdpbmUuZmluZE9uZShTRUxFQ1RPUl9ORVhUX1BSRVYsIHRoaXMuX2VsZW1lbnQpKSB7XG4gICAgICB0cmlnZ2VyVHJhbnNpdGlvbkVuZCh0aGlzLl9lbGVtZW50KVxuICAgICAgdGhpcy5jeWNsZSh0cnVlKVxuICAgIH1cblxuICAgIGNsZWFySW50ZXJ2YWwodGhpcy5faW50ZXJ2YWwpXG4gICAgdGhpcy5faW50ZXJ2YWwgPSBudWxsXG4gIH1cblxuICBjeWNsZShldmVudCkge1xuICAgIGlmICghZXZlbnQpIHtcbiAgICAgIHRoaXMuX2lzUGF1c2VkID0gZmFsc2VcbiAgICB9XG5cbiAgICBpZiAodGhpcy5faW50ZXJ2YWwpIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5faW50ZXJ2YWwpXG4gICAgICB0aGlzLl9pbnRlcnZhbCA9IG51bGxcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fY29uZmlnICYmIHRoaXMuX2NvbmZpZy5pbnRlcnZhbCAmJiAhdGhpcy5faXNQYXVzZWQpIHtcbiAgICAgIHRoaXMuX3VwZGF0ZUludGVydmFsKClcblxuICAgICAgdGhpcy5faW50ZXJ2YWwgPSBzZXRJbnRlcnZhbChcbiAgICAgICAgKGRvY3VtZW50LnZpc2liaWxpdHlTdGF0ZSA/IHRoaXMubmV4dFdoZW5WaXNpYmxlIDogdGhpcy5uZXh0KS5iaW5kKHRoaXMpLFxuICAgICAgICB0aGlzLl9jb25maWcuaW50ZXJ2YWxcbiAgICAgIClcbiAgICB9XG4gIH1cblxuICB0byhpbmRleCkge1xuICAgIHRoaXMuX2FjdGl2ZUVsZW1lbnQgPSBTZWxlY3RvckVuZ2luZS5maW5kT25lKFNFTEVDVE9SX0FDVElWRV9JVEVNLCB0aGlzLl9lbGVtZW50KVxuICAgIGNvbnN0IGFjdGl2ZUluZGV4ID0gdGhpcy5fZ2V0SXRlbUluZGV4KHRoaXMuX2FjdGl2ZUVsZW1lbnQpXG5cbiAgICBpZiAoaW5kZXggPiB0aGlzLl9pdGVtcy5sZW5ndGggLSAxIHx8IGluZGV4IDwgMCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2lzU2xpZGluZykge1xuICAgICAgRXZlbnRIYW5kbGVyLm9uZSh0aGlzLl9lbGVtZW50LCBFVkVOVF9TTElELCAoKSA9PiB0aGlzLnRvKGluZGV4KSlcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmIChhY3RpdmVJbmRleCA9PT0gaW5kZXgpIHtcbiAgICAgIHRoaXMucGF1c2UoKVxuICAgICAgdGhpcy5jeWNsZSgpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCBvcmRlciA9IGluZGV4ID4gYWN0aXZlSW5kZXggP1xuICAgICAgT1JERVJfTkVYVCA6XG4gICAgICBPUkRFUl9QUkVWXG5cbiAgICB0aGlzLl9zbGlkZShvcmRlciwgdGhpcy5faXRlbXNbaW5kZXhdKVxuICB9XG5cbiAgLy8gUHJpdmF0ZVxuXG4gIF9nZXRDb25maWcoY29uZmlnKSB7XG4gICAgY29uZmlnID0ge1xuICAgICAgLi4uRGVmYXVsdCxcbiAgICAgIC4uLk1hbmlwdWxhdG9yLmdldERhdGFBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpLFxuICAgICAgLi4uKHR5cGVvZiBjb25maWcgPT09ICdvYmplY3QnID8gY29uZmlnIDoge30pXG4gICAgfVxuICAgIHR5cGVDaGVja0NvbmZpZyhOQU1FLCBjb25maWcsIERlZmF1bHRUeXBlKVxuICAgIHJldHVybiBjb25maWdcbiAgfVxuXG4gIF9oYW5kbGVTd2lwZSgpIHtcbiAgICBjb25zdCBhYnNEZWx0YXggPSBNYXRoLmFicyh0aGlzLnRvdWNoRGVsdGFYKVxuXG4gICAgaWYgKGFic0RlbHRheCA8PSBTV0lQRV9USFJFU0hPTEQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IGRpcmVjdGlvbiA9IGFic0RlbHRheCAvIHRoaXMudG91Y2hEZWx0YVhcblxuICAgIHRoaXMudG91Y2hEZWx0YVggPSAwXG5cbiAgICBpZiAoIWRpcmVjdGlvbikge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdGhpcy5fc2xpZGUoZGlyZWN0aW9uID4gMCA/IERJUkVDVElPTl9SSUdIVCA6IERJUkVDVElPTl9MRUZUKVxuICB9XG5cbiAgX2FkZEV2ZW50TGlzdGVuZXJzKCkge1xuICAgIGlmICh0aGlzLl9jb25maWcua2V5Ym9hcmQpIHtcbiAgICAgIEV2ZW50SGFuZGxlci5vbih0aGlzLl9lbGVtZW50LCBFVkVOVF9LRVlET1dOLCBldmVudCA9PiB0aGlzLl9rZXlkb3duKGV2ZW50KSlcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fY29uZmlnLnBhdXNlID09PSAnaG92ZXInKSB7XG4gICAgICBFdmVudEhhbmRsZXIub24odGhpcy5fZWxlbWVudCwgRVZFTlRfTU9VU0VFTlRFUiwgZXZlbnQgPT4gdGhpcy5wYXVzZShldmVudCkpXG4gICAgICBFdmVudEhhbmRsZXIub24odGhpcy5fZWxlbWVudCwgRVZFTlRfTU9VU0VMRUFWRSwgZXZlbnQgPT4gdGhpcy5jeWNsZShldmVudCkpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2NvbmZpZy50b3VjaCAmJiB0aGlzLl90b3VjaFN1cHBvcnRlZCkge1xuICAgICAgdGhpcy5fYWRkVG91Y2hFdmVudExpc3RlbmVycygpXG4gICAgfVxuICB9XG5cbiAgX2FkZFRvdWNoRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgY29uc3Qgc3RhcnQgPSBldmVudCA9PiB7XG4gICAgICBpZiAodGhpcy5fcG9pbnRlckV2ZW50ICYmIChldmVudC5wb2ludGVyVHlwZSA9PT0gUE9JTlRFUl9UWVBFX1BFTiB8fCBldmVudC5wb2ludGVyVHlwZSA9PT0gUE9JTlRFUl9UWVBFX1RPVUNIKSkge1xuICAgICAgICB0aGlzLnRvdWNoU3RhcnRYID0gZXZlbnQuY2xpZW50WFxuICAgICAgfSBlbHNlIGlmICghdGhpcy5fcG9pbnRlckV2ZW50KSB7XG4gICAgICAgIHRoaXMudG91Y2hTdGFydFggPSBldmVudC50b3VjaGVzWzBdLmNsaWVudFhcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBtb3ZlID0gZXZlbnQgPT4ge1xuICAgICAgLy8gZW5zdXJlIHN3aXBpbmcgd2l0aCBvbmUgdG91Y2ggYW5kIG5vdCBwaW5jaGluZ1xuICAgICAgdGhpcy50b3VjaERlbHRhWCA9IGV2ZW50LnRvdWNoZXMgJiYgZXZlbnQudG91Y2hlcy5sZW5ndGggPiAxID9cbiAgICAgICAgMCA6XG4gICAgICAgIGV2ZW50LnRvdWNoZXNbMF0uY2xpZW50WCAtIHRoaXMudG91Y2hTdGFydFhcbiAgICB9XG5cbiAgICBjb25zdCBlbmQgPSBldmVudCA9PiB7XG4gICAgICBpZiAodGhpcy5fcG9pbnRlckV2ZW50ICYmIChldmVudC5wb2ludGVyVHlwZSA9PT0gUE9JTlRFUl9UWVBFX1BFTiB8fCBldmVudC5wb2ludGVyVHlwZSA9PT0gUE9JTlRFUl9UWVBFX1RPVUNIKSkge1xuICAgICAgICB0aGlzLnRvdWNoRGVsdGFYID0gZXZlbnQuY2xpZW50WCAtIHRoaXMudG91Y2hTdGFydFhcbiAgICAgIH1cblxuICAgICAgdGhpcy5faGFuZGxlU3dpcGUoKVxuICAgICAgaWYgKHRoaXMuX2NvbmZpZy5wYXVzZSA9PT0gJ2hvdmVyJykge1xuICAgICAgICAvLyBJZiBpdCdzIGEgdG91Y2gtZW5hYmxlZCBkZXZpY2UsIG1vdXNlZW50ZXIvbGVhdmUgYXJlIGZpcmVkIGFzXG4gICAgICAgIC8vIHBhcnQgb2YgdGhlIG1vdXNlIGNvbXBhdGliaWxpdHkgZXZlbnRzIG9uIGZpcnN0IHRhcCAtIHRoZSBjYXJvdXNlbFxuICAgICAgICAvLyB3b3VsZCBzdG9wIGN5Y2xpbmcgdW50aWwgdXNlciB0YXBwZWQgb3V0IG9mIGl0O1xuICAgICAgICAvLyBoZXJlLCB3ZSBsaXN0ZW4gZm9yIHRvdWNoZW5kLCBleHBsaWNpdGx5IHBhdXNlIHRoZSBjYXJvdXNlbFxuICAgICAgICAvLyAoYXMgaWYgaXQncyB0aGUgc2Vjb25kIHRpbWUgd2UgdGFwIG9uIGl0LCBtb3VzZWVudGVyIGNvbXBhdCBldmVudFxuICAgICAgICAvLyBpcyBOT1QgZmlyZWQpIGFuZCBhZnRlciBhIHRpbWVvdXQgKHRvIGFsbG93IGZvciBtb3VzZSBjb21wYXRpYmlsaXR5XG4gICAgICAgIC8vIGV2ZW50cyB0byBmaXJlKSB3ZSBleHBsaWNpdGx5IHJlc3RhcnQgY3ljbGluZ1xuXG4gICAgICAgIHRoaXMucGF1c2UoKVxuICAgICAgICBpZiAodGhpcy50b3VjaFRpbWVvdXQpIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50b3VjaFRpbWVvdXQpXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnRvdWNoVGltZW91dCA9IHNldFRpbWVvdXQoZXZlbnQgPT4gdGhpcy5jeWNsZShldmVudCksIFRPVUNIRVZFTlRfQ09NUEFUX1dBSVQgKyB0aGlzLl9jb25maWcuaW50ZXJ2YWwpXG4gICAgICB9XG4gICAgfVxuXG4gICAgU2VsZWN0b3JFbmdpbmUuZmluZChTRUxFQ1RPUl9JVEVNX0lNRywgdGhpcy5fZWxlbWVudCkuZm9yRWFjaChpdGVtSW1nID0+IHtcbiAgICAgIEV2ZW50SGFuZGxlci5vbihpdGVtSW1nLCBFVkVOVF9EUkFHX1NUQVJULCBlID0+IGUucHJldmVudERlZmF1bHQoKSlcbiAgICB9KVxuXG4gICAgaWYgKHRoaXMuX3BvaW50ZXJFdmVudCkge1xuICAgICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2VsZW1lbnQsIEVWRU5UX1BPSU5URVJET1dOLCBldmVudCA9PiBzdGFydChldmVudCkpXG4gICAgICBFdmVudEhhbmRsZXIub24odGhpcy5fZWxlbWVudCwgRVZFTlRfUE9JTlRFUlVQLCBldmVudCA9PiBlbmQoZXZlbnQpKVxuXG4gICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9QT0lOVEVSX0VWRU5UKVxuICAgIH0gZWxzZSB7XG4gICAgICBFdmVudEhhbmRsZXIub24odGhpcy5fZWxlbWVudCwgRVZFTlRfVE9VQ0hTVEFSVCwgZXZlbnQgPT4gc3RhcnQoZXZlbnQpKVxuICAgICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2VsZW1lbnQsIEVWRU5UX1RPVUNITU9WRSwgZXZlbnQgPT4gbW92ZShldmVudCkpXG4gICAgICBFdmVudEhhbmRsZXIub24odGhpcy5fZWxlbWVudCwgRVZFTlRfVE9VQ0hFTkQsIGV2ZW50ID0+IGVuZChldmVudCkpXG4gICAgfVxuICB9XG5cbiAgX2tleWRvd24oZXZlbnQpIHtcbiAgICBpZiAoL2lucHV0fHRleHRhcmVhL2kudGVzdChldmVudC50YXJnZXQudGFnTmFtZSkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IGRpcmVjdGlvbiA9IEtFWV9UT19ESVJFQ1RJT05bZXZlbnQua2V5XVxuICAgIGlmIChkaXJlY3Rpb24pIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KClcbiAgICAgIHRoaXMuX3NsaWRlKGRpcmVjdGlvbilcbiAgICB9XG4gIH1cblxuICBfZ2V0SXRlbUluZGV4KGVsZW1lbnQpIHtcbiAgICB0aGlzLl9pdGVtcyA9IGVsZW1lbnQgJiYgZWxlbWVudC5wYXJlbnROb2RlID9cbiAgICAgIFNlbGVjdG9yRW5naW5lLmZpbmQoU0VMRUNUT1JfSVRFTSwgZWxlbWVudC5wYXJlbnROb2RlKSA6XG4gICAgICBbXVxuXG4gICAgcmV0dXJuIHRoaXMuX2l0ZW1zLmluZGV4T2YoZWxlbWVudClcbiAgfVxuXG4gIF9nZXRJdGVtQnlPcmRlcihvcmRlciwgYWN0aXZlRWxlbWVudCkge1xuICAgIGNvbnN0IGlzTmV4dCA9IG9yZGVyID09PSBPUkRFUl9ORVhUXG4gICAgcmV0dXJuIGdldE5leHRBY3RpdmVFbGVtZW50KHRoaXMuX2l0ZW1zLCBhY3RpdmVFbGVtZW50LCBpc05leHQsIHRoaXMuX2NvbmZpZy53cmFwKVxuICB9XG5cbiAgX3RyaWdnZXJTbGlkZUV2ZW50KHJlbGF0ZWRUYXJnZXQsIGV2ZW50RGlyZWN0aW9uTmFtZSkge1xuICAgIGNvbnN0IHRhcmdldEluZGV4ID0gdGhpcy5fZ2V0SXRlbUluZGV4KHJlbGF0ZWRUYXJnZXQpXG4gICAgY29uc3QgZnJvbUluZGV4ID0gdGhpcy5fZ2V0SXRlbUluZGV4KFNlbGVjdG9yRW5naW5lLmZpbmRPbmUoU0VMRUNUT1JfQUNUSVZFX0lURU0sIHRoaXMuX2VsZW1lbnQpKVxuXG4gICAgcmV0dXJuIEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX1NMSURFLCB7XG4gICAgICByZWxhdGVkVGFyZ2V0LFxuICAgICAgZGlyZWN0aW9uOiBldmVudERpcmVjdGlvbk5hbWUsXG4gICAgICBmcm9tOiBmcm9tSW5kZXgsXG4gICAgICB0bzogdGFyZ2V0SW5kZXhcbiAgICB9KVxuICB9XG5cbiAgX3NldEFjdGl2ZUluZGljYXRvckVsZW1lbnQoZWxlbWVudCkge1xuICAgIGlmICh0aGlzLl9pbmRpY2F0b3JzRWxlbWVudCkge1xuICAgICAgY29uc3QgYWN0aXZlSW5kaWNhdG9yID0gU2VsZWN0b3JFbmdpbmUuZmluZE9uZShTRUxFQ1RPUl9BQ1RJVkUsIHRoaXMuX2luZGljYXRvcnNFbGVtZW50KVxuXG4gICAgICBhY3RpdmVJbmRpY2F0b3IuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19OQU1FX0FDVElWRSlcbiAgICAgIGFjdGl2ZUluZGljYXRvci5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtY3VycmVudCcpXG5cbiAgICAgIGNvbnN0IGluZGljYXRvcnMgPSBTZWxlY3RvckVuZ2luZS5maW5kKFNFTEVDVE9SX0lORElDQVRPUiwgdGhpcy5faW5kaWNhdG9yc0VsZW1lbnQpXG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5kaWNhdG9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoTnVtYmVyLnBhcnNlSW50KGluZGljYXRvcnNbaV0uZ2V0QXR0cmlidXRlKCdkYXRhLWJzLXNsaWRlLXRvJyksIDEwKSA9PT0gdGhpcy5fZ2V0SXRlbUluZGV4KGVsZW1lbnQpKSB7XG4gICAgICAgICAgaW5kaWNhdG9yc1tpXS5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfQUNUSVZFKVxuICAgICAgICAgIGluZGljYXRvcnNbaV0uc2V0QXR0cmlidXRlKCdhcmlhLWN1cnJlbnQnLCAndHJ1ZScpXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIF91cGRhdGVJbnRlcnZhbCgpIHtcbiAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5fYWN0aXZlRWxlbWVudCB8fCBTZWxlY3RvckVuZ2luZS5maW5kT25lKFNFTEVDVE9SX0FDVElWRV9JVEVNLCB0aGlzLl9lbGVtZW50KVxuXG4gICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCBlbGVtZW50SW50ZXJ2YWwgPSBOdW1iZXIucGFyc2VJbnQoZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtYnMtaW50ZXJ2YWwnKSwgMTApXG5cbiAgICBpZiAoZWxlbWVudEludGVydmFsKSB7XG4gICAgICB0aGlzLl9jb25maWcuZGVmYXVsdEludGVydmFsID0gdGhpcy5fY29uZmlnLmRlZmF1bHRJbnRlcnZhbCB8fCB0aGlzLl9jb25maWcuaW50ZXJ2YWxcbiAgICAgIHRoaXMuX2NvbmZpZy5pbnRlcnZhbCA9IGVsZW1lbnRJbnRlcnZhbFxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9jb25maWcuaW50ZXJ2YWwgPSB0aGlzLl9jb25maWcuZGVmYXVsdEludGVydmFsIHx8IHRoaXMuX2NvbmZpZy5pbnRlcnZhbFxuICAgIH1cbiAgfVxuXG4gIF9zbGlkZShkaXJlY3Rpb25Pck9yZGVyLCBlbGVtZW50KSB7XG4gICAgY29uc3Qgb3JkZXIgPSB0aGlzLl9kaXJlY3Rpb25Ub09yZGVyKGRpcmVjdGlvbk9yT3JkZXIpXG4gICAgY29uc3QgYWN0aXZlRWxlbWVudCA9IFNlbGVjdG9yRW5naW5lLmZpbmRPbmUoU0VMRUNUT1JfQUNUSVZFX0lURU0sIHRoaXMuX2VsZW1lbnQpXG4gICAgY29uc3QgYWN0aXZlRWxlbWVudEluZGV4ID0gdGhpcy5fZ2V0SXRlbUluZGV4KGFjdGl2ZUVsZW1lbnQpXG4gICAgY29uc3QgbmV4dEVsZW1lbnQgPSBlbGVtZW50IHx8IHRoaXMuX2dldEl0ZW1CeU9yZGVyKG9yZGVyLCBhY3RpdmVFbGVtZW50KVxuXG4gICAgY29uc3QgbmV4dEVsZW1lbnRJbmRleCA9IHRoaXMuX2dldEl0ZW1JbmRleChuZXh0RWxlbWVudClcbiAgICBjb25zdCBpc0N5Y2xpbmcgPSBCb29sZWFuKHRoaXMuX2ludGVydmFsKVxuXG4gICAgY29uc3QgaXNOZXh0ID0gb3JkZXIgPT09IE9SREVSX05FWFRcbiAgICBjb25zdCBkaXJlY3Rpb25hbENsYXNzTmFtZSA9IGlzTmV4dCA/IENMQVNTX05BTUVfU1RBUlQgOiBDTEFTU19OQU1FX0VORFxuICAgIGNvbnN0IG9yZGVyQ2xhc3NOYW1lID0gaXNOZXh0ID8gQ0xBU1NfTkFNRV9ORVhUIDogQ0xBU1NfTkFNRV9QUkVWXG4gICAgY29uc3QgZXZlbnREaXJlY3Rpb25OYW1lID0gdGhpcy5fb3JkZXJUb0RpcmVjdGlvbihvcmRlcilcblxuICAgIGlmIChuZXh0RWxlbWVudCAmJiBuZXh0RWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9BQ1RJVkUpKSB7XG4gICAgICB0aGlzLl9pc1NsaWRpbmcgPSBmYWxzZVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2lzU2xpZGluZykge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3Qgc2xpZGVFdmVudCA9IHRoaXMuX3RyaWdnZXJTbGlkZUV2ZW50KG5leHRFbGVtZW50LCBldmVudERpcmVjdGlvbk5hbWUpXG4gICAgaWYgKHNsaWRlRXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKCFhY3RpdmVFbGVtZW50IHx8ICFuZXh0RWxlbWVudCkge1xuICAgICAgLy8gU29tZSB3ZWlyZG5lc3MgaXMgaGFwcGVuaW5nLCBzbyB3ZSBiYWlsXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLl9pc1NsaWRpbmcgPSB0cnVlXG5cbiAgICBpZiAoaXNDeWNsaW5nKSB7XG4gICAgICB0aGlzLnBhdXNlKClcbiAgICB9XG5cbiAgICB0aGlzLl9zZXRBY3RpdmVJbmRpY2F0b3JFbGVtZW50KG5leHRFbGVtZW50KVxuICAgIHRoaXMuX2FjdGl2ZUVsZW1lbnQgPSBuZXh0RWxlbWVudFxuXG4gICAgY29uc3QgdHJpZ2dlclNsaWRFdmVudCA9ICgpID0+IHtcbiAgICAgIEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX1NMSUQsIHtcbiAgICAgICAgcmVsYXRlZFRhcmdldDogbmV4dEVsZW1lbnQsXG4gICAgICAgIGRpcmVjdGlvbjogZXZlbnREaXJlY3Rpb25OYW1lLFxuICAgICAgICBmcm9tOiBhY3RpdmVFbGVtZW50SW5kZXgsXG4gICAgICAgIHRvOiBuZXh0RWxlbWVudEluZGV4XG4gICAgICB9KVxuICAgIH1cblxuICAgIGlmICh0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX1NMSURFKSkge1xuICAgICAgbmV4dEVsZW1lbnQuY2xhc3NMaXN0LmFkZChvcmRlckNsYXNzTmFtZSlcblxuICAgICAgcmVmbG93KG5leHRFbGVtZW50KVxuXG4gICAgICBhY3RpdmVFbGVtZW50LmNsYXNzTGlzdC5hZGQoZGlyZWN0aW9uYWxDbGFzc05hbWUpXG4gICAgICBuZXh0RWxlbWVudC5jbGFzc0xpc3QuYWRkKGRpcmVjdGlvbmFsQ2xhc3NOYW1lKVxuXG4gICAgICBjb25zdCBjb21wbGV0ZUNhbGxCYWNrID0gKCkgPT4ge1xuICAgICAgICBuZXh0RWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKGRpcmVjdGlvbmFsQ2xhc3NOYW1lLCBvcmRlckNsYXNzTmFtZSlcbiAgICAgICAgbmV4dEVsZW1lbnQuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX0FDVElWRSlcblxuICAgICAgICBhY3RpdmVFbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9BQ1RJVkUsIG9yZGVyQ2xhc3NOYW1lLCBkaXJlY3Rpb25hbENsYXNzTmFtZSlcblxuICAgICAgICB0aGlzLl9pc1NsaWRpbmcgPSBmYWxzZVxuXG4gICAgICAgIHNldFRpbWVvdXQodHJpZ2dlclNsaWRFdmVudCwgMClcbiAgICAgIH1cblxuICAgICAgdGhpcy5fcXVldWVDYWxsYmFjayhjb21wbGV0ZUNhbGxCYWNrLCBhY3RpdmVFbGVtZW50LCB0cnVlKVxuICAgIH0gZWxzZSB7XG4gICAgICBhY3RpdmVFbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9BQ1RJVkUpXG4gICAgICBuZXh0RWxlbWVudC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfQUNUSVZFKVxuXG4gICAgICB0aGlzLl9pc1NsaWRpbmcgPSBmYWxzZVxuICAgICAgdHJpZ2dlclNsaWRFdmVudCgpXG4gICAgfVxuXG4gICAgaWYgKGlzQ3ljbGluZykge1xuICAgICAgdGhpcy5jeWNsZSgpXG4gICAgfVxuICB9XG5cbiAgX2RpcmVjdGlvblRvT3JkZXIoZGlyZWN0aW9uKSB7XG4gICAgaWYgKCFbRElSRUNUSU9OX1JJR0hULCBESVJFQ1RJT05fTEVGVF0uaW5jbHVkZXMoZGlyZWN0aW9uKSkge1xuICAgICAgcmV0dXJuIGRpcmVjdGlvblxuICAgIH1cblxuICAgIGlmIChpc1JUTCgpKSB7XG4gICAgICByZXR1cm4gZGlyZWN0aW9uID09PSBESVJFQ1RJT05fTEVGVCA/IE9SREVSX1BSRVYgOiBPUkRFUl9ORVhUXG4gICAgfVxuXG4gICAgcmV0dXJuIGRpcmVjdGlvbiA9PT0gRElSRUNUSU9OX0xFRlQgPyBPUkRFUl9ORVhUIDogT1JERVJfUFJFVlxuICB9XG5cbiAgX29yZGVyVG9EaXJlY3Rpb24ob3JkZXIpIHtcbiAgICBpZiAoIVtPUkRFUl9ORVhULCBPUkRFUl9QUkVWXS5pbmNsdWRlcyhvcmRlcikpIHtcbiAgICAgIHJldHVybiBvcmRlclxuICAgIH1cblxuICAgIGlmIChpc1JUTCgpKSB7XG4gICAgICByZXR1cm4gb3JkZXIgPT09IE9SREVSX1BSRVYgPyBESVJFQ1RJT05fTEVGVCA6IERJUkVDVElPTl9SSUdIVFxuICAgIH1cblxuICAgIHJldHVybiBvcmRlciA9PT0gT1JERVJfUFJFViA/IERJUkVDVElPTl9SSUdIVCA6IERJUkVDVElPTl9MRUZUXG4gIH1cblxuICAvLyBTdGF0aWNcblxuICBzdGF0aWMgY2Fyb3VzZWxJbnRlcmZhY2UoZWxlbWVudCwgY29uZmlnKSB7XG4gICAgY29uc3QgZGF0YSA9IENhcm91c2VsLmdldE9yQ3JlYXRlSW5zdGFuY2UoZWxlbWVudCwgY29uZmlnKVxuXG4gICAgbGV0IHsgX2NvbmZpZyB9ID0gZGF0YVxuICAgIGlmICh0eXBlb2YgY29uZmlnID09PSAnb2JqZWN0Jykge1xuICAgICAgX2NvbmZpZyA9IHtcbiAgICAgICAgLi4uX2NvbmZpZyxcbiAgICAgICAgLi4uY29uZmlnXG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgYWN0aW9uID0gdHlwZW9mIGNvbmZpZyA9PT0gJ3N0cmluZycgPyBjb25maWcgOiBfY29uZmlnLnNsaWRlXG5cbiAgICBpZiAodHlwZW9mIGNvbmZpZyA9PT0gJ251bWJlcicpIHtcbiAgICAgIGRhdGEudG8oY29uZmlnKVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGFjdGlvbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGlmICh0eXBlb2YgZGF0YVthY3Rpb25dID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXCIke2FjdGlvbn1cImApXG4gICAgICB9XG5cbiAgICAgIGRhdGFbYWN0aW9uXSgpXG4gICAgfSBlbHNlIGlmIChfY29uZmlnLmludGVydmFsICYmIF9jb25maWcucmlkZSkge1xuICAgICAgZGF0YS5wYXVzZSgpXG4gICAgICBkYXRhLmN5Y2xlKClcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKGNvbmZpZykge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgQ2Fyb3VzZWwuY2Fyb3VzZWxJbnRlcmZhY2UodGhpcywgY29uZmlnKVxuICAgIH0pXG4gIH1cblxuICBzdGF0aWMgZGF0YUFwaUNsaWNrSGFuZGxlcihldmVudCkge1xuICAgIGNvbnN0IHRhcmdldCA9IGdldEVsZW1lbnRGcm9tU2VsZWN0b3IodGhpcylcblxuICAgIGlmICghdGFyZ2V0IHx8ICF0YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfQ0FST1VTRUwpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCBjb25maWcgPSB7XG4gICAgICAuLi5NYW5pcHVsYXRvci5nZXREYXRhQXR0cmlidXRlcyh0YXJnZXQpLFxuICAgICAgLi4uTWFuaXB1bGF0b3IuZ2V0RGF0YUF0dHJpYnV0ZXModGhpcylcbiAgICB9XG4gICAgY29uc3Qgc2xpZGVJbmRleCA9IHRoaXMuZ2V0QXR0cmlidXRlKCdkYXRhLWJzLXNsaWRlLXRvJylcblxuICAgIGlmIChzbGlkZUluZGV4KSB7XG4gICAgICBjb25maWcuaW50ZXJ2YWwgPSBmYWxzZVxuICAgIH1cblxuICAgIENhcm91c2VsLmNhcm91c2VsSW50ZXJmYWNlKHRhcmdldCwgY29uZmlnKVxuXG4gICAgaWYgKHNsaWRlSW5kZXgpIHtcbiAgICAgIENhcm91c2VsLmdldEluc3RhbmNlKHRhcmdldCkudG8oc2xpZGVJbmRleClcbiAgICB9XG5cbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpXG4gIH1cbn1cblxuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIERhdGEgQXBpIGltcGxlbWVudGF0aW9uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5FdmVudEhhbmRsZXIub24oZG9jdW1lbnQsIEVWRU5UX0NMSUNLX0RBVEFfQVBJLCBTRUxFQ1RPUl9EQVRBX1NMSURFLCBDYXJvdXNlbC5kYXRhQXBpQ2xpY2tIYW5kbGVyKVxuXG5FdmVudEhhbmRsZXIub24od2luZG93LCBFVkVOVF9MT0FEX0RBVEFfQVBJLCAoKSA9PiB7XG4gIGNvbnN0IGNhcm91c2VscyA9IFNlbGVjdG9yRW5naW5lLmZpbmQoU0VMRUNUT1JfREFUQV9SSURFKVxuXG4gIGZvciAobGV0IGkgPSAwLCBsZW4gPSBjYXJvdXNlbHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBDYXJvdXNlbC5jYXJvdXNlbEludGVyZmFjZShjYXJvdXNlbHNbaV0sIENhcm91c2VsLmdldEluc3RhbmNlKGNhcm91c2Vsc1tpXSkpXG4gIH1cbn0pXG5cbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBqUXVlcnlcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogYWRkIC5DYXJvdXNlbCB0byBqUXVlcnkgb25seSBpZiBqUXVlcnkgaXMgcHJlc2VudFxuICovXG5cbmRlZmluZUpRdWVyeVBsdWdpbihDYXJvdXNlbClcblxuZXhwb3J0IGRlZmF1bHQgQ2Fyb3VzZWxcbiIsIi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEJvb3RzdHJhcCAodjUuMC4yKTogY29sbGFwc2UuanNcbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5pbXBvcnQge1xuICBkZWZpbmVKUXVlcnlQbHVnaW4sXG4gIGdldEVsZW1lbnQsXG4gIGdldFNlbGVjdG9yRnJvbUVsZW1lbnQsXG4gIGdldEVsZW1lbnRGcm9tU2VsZWN0b3IsXG4gIHJlZmxvdyxcbiAgdHlwZUNoZWNrQ29uZmlnXG59IGZyb20gJy4vdXRpbC9pbmRleCdcbmltcG9ydCBEYXRhIGZyb20gJy4vZG9tL2RhdGEnXG5pbXBvcnQgRXZlbnRIYW5kbGVyIGZyb20gJy4vZG9tL2V2ZW50LWhhbmRsZXInXG5pbXBvcnQgTWFuaXB1bGF0b3IgZnJvbSAnLi9kb20vbWFuaXB1bGF0b3InXG5pbXBvcnQgU2VsZWN0b3JFbmdpbmUgZnJvbSAnLi9kb20vc2VsZWN0b3ItZW5naW5lJ1xuaW1wb3J0IEJhc2VDb21wb25lbnQgZnJvbSAnLi9iYXNlLWNvbXBvbmVudCdcblxuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvbnN0YW50c1xuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuY29uc3QgTkFNRSA9ICdjb2xsYXBzZSdcbmNvbnN0IERBVEFfS0VZID0gJ2JzLmNvbGxhcHNlJ1xuY29uc3QgRVZFTlRfS0VZID0gYC4ke0RBVEFfS0VZfWBcbmNvbnN0IERBVEFfQVBJX0tFWSA9ICcuZGF0YS1hcGknXG5cbmNvbnN0IERlZmF1bHQgPSB7XG4gIHRvZ2dsZTogdHJ1ZSxcbiAgcGFyZW50OiAnJ1xufVxuXG5jb25zdCBEZWZhdWx0VHlwZSA9IHtcbiAgdG9nZ2xlOiAnYm9vbGVhbicsXG4gIHBhcmVudDogJyhzdHJpbmd8ZWxlbWVudCknXG59XG5cbmNvbnN0IEVWRU5UX1NIT1cgPSBgc2hvdyR7RVZFTlRfS0VZfWBcbmNvbnN0IEVWRU5UX1NIT1dOID0gYHNob3duJHtFVkVOVF9LRVl9YFxuY29uc3QgRVZFTlRfSElERSA9IGBoaWRlJHtFVkVOVF9LRVl9YFxuY29uc3QgRVZFTlRfSElEREVOID0gYGhpZGRlbiR7RVZFTlRfS0VZfWBcbmNvbnN0IEVWRU5UX0NMSUNLX0RBVEFfQVBJID0gYGNsaWNrJHtFVkVOVF9LRVl9JHtEQVRBX0FQSV9LRVl9YFxuXG5jb25zdCBDTEFTU19OQU1FX1NIT1cgPSAnc2hvdydcbmNvbnN0IENMQVNTX05BTUVfQ09MTEFQU0UgPSAnY29sbGFwc2UnXG5jb25zdCBDTEFTU19OQU1FX0NPTExBUFNJTkcgPSAnY29sbGFwc2luZydcbmNvbnN0IENMQVNTX05BTUVfQ09MTEFQU0VEID0gJ2NvbGxhcHNlZCdcblxuY29uc3QgV0lEVEggPSAnd2lkdGgnXG5jb25zdCBIRUlHSFQgPSAnaGVpZ2h0J1xuXG5jb25zdCBTRUxFQ1RPUl9BQ1RJVkVTID0gJy5zaG93LCAuY29sbGFwc2luZydcbmNvbnN0IFNFTEVDVE9SX0RBVEFfVE9HR0xFID0gJ1tkYXRhLWJzLXRvZ2dsZT1cImNvbGxhcHNlXCJdJ1xuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ2xhc3MgRGVmaW5pdGlvblxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuY2xhc3MgQ29sbGFwc2UgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IoZWxlbWVudCwgY29uZmlnKSB7XG4gICAgc3VwZXIoZWxlbWVudClcblxuICAgIHRoaXMuX2lzVHJhbnNpdGlvbmluZyA9IGZhbHNlXG4gICAgdGhpcy5fY29uZmlnID0gdGhpcy5fZ2V0Q29uZmlnKGNvbmZpZylcbiAgICB0aGlzLl90cmlnZ2VyQXJyYXkgPSBTZWxlY3RvckVuZ2luZS5maW5kKFxuICAgICAgYCR7U0VMRUNUT1JfREFUQV9UT0dHTEV9W2hyZWY9XCIjJHt0aGlzLl9lbGVtZW50LmlkfVwiXSxgICtcbiAgICAgIGAke1NFTEVDVE9SX0RBVEFfVE9HR0xFfVtkYXRhLWJzLXRhcmdldD1cIiMke3RoaXMuX2VsZW1lbnQuaWR9XCJdYFxuICAgIClcblxuICAgIGNvbnN0IHRvZ2dsZUxpc3QgPSBTZWxlY3RvckVuZ2luZS5maW5kKFNFTEVDVE9SX0RBVEFfVE9HR0xFKVxuXG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHRvZ2dsZUxpc3QubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGNvbnN0IGVsZW0gPSB0b2dnbGVMaXN0W2ldXG4gICAgICBjb25zdCBzZWxlY3RvciA9IGdldFNlbGVjdG9yRnJvbUVsZW1lbnQoZWxlbSlcbiAgICAgIGNvbnN0IGZpbHRlckVsZW1lbnQgPSBTZWxlY3RvckVuZ2luZS5maW5kKHNlbGVjdG9yKVxuICAgICAgICAuZmlsdGVyKGZvdW5kRWxlbSA9PiBmb3VuZEVsZW0gPT09IHRoaXMuX2VsZW1lbnQpXG5cbiAgICAgIGlmIChzZWxlY3RvciAhPT0gbnVsbCAmJiBmaWx0ZXJFbGVtZW50Lmxlbmd0aCkge1xuICAgICAgICB0aGlzLl9zZWxlY3RvciA9IHNlbGVjdG9yXG4gICAgICAgIHRoaXMuX3RyaWdnZXJBcnJheS5wdXNoKGVsZW0pXG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5fcGFyZW50ID0gdGhpcy5fY29uZmlnLnBhcmVudCA/IHRoaXMuX2dldFBhcmVudCgpIDogbnVsbFxuXG4gICAgaWYgKCF0aGlzLl9jb25maWcucGFyZW50KSB7XG4gICAgICB0aGlzLl9hZGRBcmlhQW5kQ29sbGFwc2VkQ2xhc3ModGhpcy5fZWxlbWVudCwgdGhpcy5fdHJpZ2dlckFycmF5KVxuICAgIH1cblxuICAgIGlmICh0aGlzLl9jb25maWcudG9nZ2xlKSB7XG4gICAgICB0aGlzLnRvZ2dsZSgpXG4gICAgfVxuICB9XG5cbiAgLy8gR2V0dGVyc1xuXG4gIHN0YXRpYyBnZXQgRGVmYXVsdCgpIHtcbiAgICByZXR1cm4gRGVmYXVsdFxuICB9XG5cbiAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgIHJldHVybiBOQU1FXG4gIH1cblxuICAvLyBQdWJsaWNcblxuICB0b2dnbGUoKSB7XG4gICAgaWYgKHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfU0hPVykpIHtcbiAgICAgIHRoaXMuaGlkZSgpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2hvdygpXG4gICAgfVxuICB9XG5cbiAgc2hvdygpIHtcbiAgICBpZiAodGhpcy5faXNUcmFuc2l0aW9uaW5nIHx8IHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfU0hPVykpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGxldCBhY3RpdmVzXG4gICAgbGV0IGFjdGl2ZXNEYXRhXG5cbiAgICBpZiAodGhpcy5fcGFyZW50KSB7XG4gICAgICBhY3RpdmVzID0gU2VsZWN0b3JFbmdpbmUuZmluZChTRUxFQ1RPUl9BQ1RJVkVTLCB0aGlzLl9wYXJlbnQpXG4gICAgICAgIC5maWx0ZXIoZWxlbSA9PiB7XG4gICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLl9jb25maWcucGFyZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlKCdkYXRhLWJzLXBhcmVudCcpID09PSB0aGlzLl9jb25maWcucGFyZW50XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGVsZW0uY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfQ09MTEFQU0UpXG4gICAgICAgIH0pXG5cbiAgICAgIGlmIChhY3RpdmVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBhY3RpdmVzID0gbnVsbFxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGNvbnRhaW5lciA9IFNlbGVjdG9yRW5naW5lLmZpbmRPbmUodGhpcy5fc2VsZWN0b3IpXG4gICAgaWYgKGFjdGl2ZXMpIHtcbiAgICAgIGNvbnN0IHRlbXBBY3RpdmVEYXRhID0gYWN0aXZlcy5maW5kKGVsZW0gPT4gY29udGFpbmVyICE9PSBlbGVtKVxuICAgICAgYWN0aXZlc0RhdGEgPSB0ZW1wQWN0aXZlRGF0YSA/IENvbGxhcHNlLmdldEluc3RhbmNlKHRlbXBBY3RpdmVEYXRhKSA6IG51bGxcblxuICAgICAgaWYgKGFjdGl2ZXNEYXRhICYmIGFjdGl2ZXNEYXRhLl9pc1RyYW5zaXRpb25pbmcpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3Qgc3RhcnRFdmVudCA9IEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX1NIT1cpXG4gICAgaWYgKHN0YXJ0RXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKGFjdGl2ZXMpIHtcbiAgICAgIGFjdGl2ZXMuZm9yRWFjaChlbGVtQWN0aXZlID0+IHtcbiAgICAgICAgaWYgKGNvbnRhaW5lciAhPT0gZWxlbUFjdGl2ZSkge1xuICAgICAgICAgIENvbGxhcHNlLmNvbGxhcHNlSW50ZXJmYWNlKGVsZW1BY3RpdmUsICdoaWRlJylcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghYWN0aXZlc0RhdGEpIHtcbiAgICAgICAgICBEYXRhLnNldChlbGVtQWN0aXZlLCBEQVRBX0tFWSwgbnVsbClcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG5cbiAgICBjb25zdCBkaW1lbnNpb24gPSB0aGlzLl9nZXREaW1lbnNpb24oKVxuXG4gICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfQ09MTEFQU0UpXG4gICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfQ09MTEFQU0lORylcblxuICAgIHRoaXMuX2VsZW1lbnQuc3R5bGVbZGltZW5zaW9uXSA9IDBcblxuICAgIGlmICh0aGlzLl90cmlnZ2VyQXJyYXkubGVuZ3RoKSB7XG4gICAgICB0aGlzLl90cmlnZ2VyQXJyYXkuZm9yRWFjaChlbGVtZW50ID0+IHtcbiAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfQ09MTEFQU0VEKVxuICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcsIHRydWUpXG4gICAgICB9KVxuICAgIH1cblxuICAgIHRoaXMuc2V0VHJhbnNpdGlvbmluZyh0cnVlKVxuXG4gICAgY29uc3QgY29tcGxldGUgPSAoKSA9PiB7XG4gICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9DT0xMQVBTSU5HKVxuICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfQ09MTEFQU0UsIENMQVNTX05BTUVfU0hPVylcblxuICAgICAgdGhpcy5fZWxlbWVudC5zdHlsZVtkaW1lbnNpb25dID0gJydcblxuICAgICAgdGhpcy5zZXRUcmFuc2l0aW9uaW5nKGZhbHNlKVxuXG4gICAgICBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9TSE9XTilcbiAgICB9XG5cbiAgICBjb25zdCBjYXBpdGFsaXplZERpbWVuc2lvbiA9IGRpbWVuc2lvblswXS50b1VwcGVyQ2FzZSgpICsgZGltZW5zaW9uLnNsaWNlKDEpXG4gICAgY29uc3Qgc2Nyb2xsU2l6ZSA9IGBzY3JvbGwke2NhcGl0YWxpemVkRGltZW5zaW9ufWBcblxuICAgIHRoaXMuX3F1ZXVlQ2FsbGJhY2soY29tcGxldGUsIHRoaXMuX2VsZW1lbnQsIHRydWUpXG4gICAgdGhpcy5fZWxlbWVudC5zdHlsZVtkaW1lbnNpb25dID0gYCR7dGhpcy5fZWxlbWVudFtzY3JvbGxTaXplXX1weGBcbiAgfVxuXG4gIGhpZGUoKSB7XG4gICAgaWYgKHRoaXMuX2lzVHJhbnNpdGlvbmluZyB8fCAhdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9TSE9XKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3Qgc3RhcnRFdmVudCA9IEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0hJREUpXG4gICAgaWYgKHN0YXJ0RXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3QgZGltZW5zaW9uID0gdGhpcy5fZ2V0RGltZW5zaW9uKClcblxuICAgIHRoaXMuX2VsZW1lbnQuc3R5bGVbZGltZW5zaW9uXSA9IGAke3RoaXMuX2VsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClbZGltZW5zaW9uXX1weGBcblxuICAgIHJlZmxvdyh0aGlzLl9lbGVtZW50KVxuXG4gICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfQ09MTEFQU0lORylcbiAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9DT0xMQVBTRSwgQ0xBU1NfTkFNRV9TSE9XKVxuXG4gICAgY29uc3QgdHJpZ2dlckFycmF5TGVuZ3RoID0gdGhpcy5fdHJpZ2dlckFycmF5Lmxlbmd0aFxuICAgIGlmICh0cmlnZ2VyQXJyYXlMZW5ndGggPiAwKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRyaWdnZXJBcnJheUxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHRyaWdnZXIgPSB0aGlzLl90cmlnZ2VyQXJyYXlbaV1cbiAgICAgICAgY29uc3QgZWxlbSA9IGdldEVsZW1lbnRGcm9tU2VsZWN0b3IodHJpZ2dlcilcblxuICAgICAgICBpZiAoZWxlbSAmJiAhZWxlbS5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9TSE9XKSkge1xuICAgICAgICAgIHRyaWdnZXIuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX0NPTExBUFNFRClcbiAgICAgICAgICB0cmlnZ2VyLnNldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcsIGZhbHNlKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5zZXRUcmFuc2l0aW9uaW5nKHRydWUpXG5cbiAgICBjb25zdCBjb21wbGV0ZSA9ICgpID0+IHtcbiAgICAgIHRoaXMuc2V0VHJhbnNpdGlvbmluZyhmYWxzZSlcbiAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19OQU1FX0NPTExBUFNJTkcpXG4gICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9DT0xMQVBTRSlcbiAgICAgIEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0hJRERFTilcbiAgICB9XG5cbiAgICB0aGlzLl9lbGVtZW50LnN0eWxlW2RpbWVuc2lvbl0gPSAnJ1xuXG4gICAgdGhpcy5fcXVldWVDYWxsYmFjayhjb21wbGV0ZSwgdGhpcy5fZWxlbWVudCwgdHJ1ZSlcbiAgfVxuXG4gIHNldFRyYW5zaXRpb25pbmcoaXNUcmFuc2l0aW9uaW5nKSB7XG4gICAgdGhpcy5faXNUcmFuc2l0aW9uaW5nID0gaXNUcmFuc2l0aW9uaW5nXG4gIH1cblxuICAvLyBQcml2YXRlXG5cbiAgX2dldENvbmZpZyhjb25maWcpIHtcbiAgICBjb25maWcgPSB7XG4gICAgICAuLi5EZWZhdWx0LFxuICAgICAgLi4uY29uZmlnXG4gICAgfVxuICAgIGNvbmZpZy50b2dnbGUgPSBCb29sZWFuKGNvbmZpZy50b2dnbGUpIC8vIENvZXJjZSBzdHJpbmcgdmFsdWVzXG4gICAgdHlwZUNoZWNrQ29uZmlnKE5BTUUsIGNvbmZpZywgRGVmYXVsdFR5cGUpXG4gICAgcmV0dXJuIGNvbmZpZ1xuICB9XG5cbiAgX2dldERpbWVuc2lvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoV0lEVEgpID8gV0lEVEggOiBIRUlHSFRcbiAgfVxuXG4gIF9nZXRQYXJlbnQoKSB7XG4gICAgbGV0IHsgcGFyZW50IH0gPSB0aGlzLl9jb25maWdcblxuICAgIHBhcmVudCA9IGdldEVsZW1lbnQocGFyZW50KVxuXG4gICAgY29uc3Qgc2VsZWN0b3IgPSBgJHtTRUxFQ1RPUl9EQVRBX1RPR0dMRX1bZGF0YS1icy1wYXJlbnQ9XCIke3BhcmVudH1cIl1gXG5cbiAgICBTZWxlY3RvckVuZ2luZS5maW5kKHNlbGVjdG9yLCBwYXJlbnQpXG4gICAgICAuZm9yRWFjaChlbGVtZW50ID0+IHtcbiAgICAgICAgY29uc3Qgc2VsZWN0ZWQgPSBnZXRFbGVtZW50RnJvbVNlbGVjdG9yKGVsZW1lbnQpXG5cbiAgICAgICAgdGhpcy5fYWRkQXJpYUFuZENvbGxhcHNlZENsYXNzKFxuICAgICAgICAgIHNlbGVjdGVkLFxuICAgICAgICAgIFtlbGVtZW50XVxuICAgICAgICApXG4gICAgICB9KVxuXG4gICAgcmV0dXJuIHBhcmVudFxuICB9XG5cbiAgX2FkZEFyaWFBbmRDb2xsYXBzZWRDbGFzcyhlbGVtZW50LCB0cmlnZ2VyQXJyYXkpIHtcbiAgICBpZiAoIWVsZW1lbnQgfHwgIXRyaWdnZXJBcnJheS5sZW5ndGgpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IGlzT3BlbiA9IGVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfU0hPVylcblxuICAgIHRyaWdnZXJBcnJheS5mb3JFYWNoKGVsZW0gPT4ge1xuICAgICAgaWYgKGlzT3Blbikge1xuICAgICAgICBlbGVtLmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9DT0xMQVBTRUQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbGVtLmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9DT0xMQVBTRUQpXG4gICAgICB9XG5cbiAgICAgIGVsZW0uc2V0QXR0cmlidXRlKCdhcmlhLWV4cGFuZGVkJywgaXNPcGVuKVxuICAgIH0pXG4gIH1cblxuICAvLyBTdGF0aWNcblxuICBzdGF0aWMgY29sbGFwc2VJbnRlcmZhY2UoZWxlbWVudCwgY29uZmlnKSB7XG4gICAgbGV0IGRhdGEgPSBDb2xsYXBzZS5nZXRJbnN0YW5jZShlbGVtZW50KVxuICAgIGNvbnN0IF9jb25maWcgPSB7XG4gICAgICAuLi5EZWZhdWx0LFxuICAgICAgLi4uTWFuaXB1bGF0b3IuZ2V0RGF0YUF0dHJpYnV0ZXMoZWxlbWVudCksXG4gICAgICAuLi4odHlwZW9mIGNvbmZpZyA9PT0gJ29iamVjdCcgJiYgY29uZmlnID8gY29uZmlnIDoge30pXG4gICAgfVxuXG4gICAgaWYgKCFkYXRhICYmIF9jb25maWcudG9nZ2xlICYmIHR5cGVvZiBjb25maWcgPT09ICdzdHJpbmcnICYmIC9zaG93fGhpZGUvLnRlc3QoY29uZmlnKSkge1xuICAgICAgX2NvbmZpZy50b2dnbGUgPSBmYWxzZVxuICAgIH1cblxuICAgIGlmICghZGF0YSkge1xuICAgICAgZGF0YSA9IG5ldyBDb2xsYXBzZShlbGVtZW50LCBfY29uZmlnKVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgY29uZmlnID09PSAnc3RyaW5nJykge1xuICAgICAgaWYgKHR5cGVvZiBkYXRhW2NvbmZpZ10gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcIiR7Y29uZmlnfVwiYClcbiAgICAgIH1cblxuICAgICAgZGF0YVtjb25maWddKClcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKGNvbmZpZykge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgQ29sbGFwc2UuY29sbGFwc2VJbnRlcmZhY2UodGhpcywgY29uZmlnKVxuICAgIH0pXG4gIH1cbn1cblxuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIERhdGEgQXBpIGltcGxlbWVudGF0aW9uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5FdmVudEhhbmRsZXIub24oZG9jdW1lbnQsIEVWRU5UX0NMSUNLX0RBVEFfQVBJLCBTRUxFQ1RPUl9EQVRBX1RPR0dMRSwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gIC8vIHByZXZlbnREZWZhdWx0IG9ubHkgZm9yIDxhPiBlbGVtZW50cyAod2hpY2ggY2hhbmdlIHRoZSBVUkwpIG5vdCBpbnNpZGUgdGhlIGNvbGxhcHNpYmxlIGVsZW1lbnRcbiAgaWYgKGV2ZW50LnRhcmdldC50YWdOYW1lID09PSAnQScgfHwgKGV2ZW50LmRlbGVnYXRlVGFyZ2V0ICYmIGV2ZW50LmRlbGVnYXRlVGFyZ2V0LnRhZ05hbWUgPT09ICdBJykpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpXG4gIH1cblxuICBjb25zdCB0cmlnZ2VyRGF0YSA9IE1hbmlwdWxhdG9yLmdldERhdGFBdHRyaWJ1dGVzKHRoaXMpXG4gIGNvbnN0IHNlbGVjdG9yID0gZ2V0U2VsZWN0b3JGcm9tRWxlbWVudCh0aGlzKVxuICBjb25zdCBzZWxlY3RvckVsZW1lbnRzID0gU2VsZWN0b3JFbmdpbmUuZmluZChzZWxlY3RvcilcblxuICBzZWxlY3RvckVsZW1lbnRzLmZvckVhY2goZWxlbWVudCA9PiB7XG4gICAgY29uc3QgZGF0YSA9IENvbGxhcHNlLmdldEluc3RhbmNlKGVsZW1lbnQpXG4gICAgbGV0IGNvbmZpZ1xuICAgIGlmIChkYXRhKSB7XG4gICAgICAvLyB1cGRhdGUgcGFyZW50IGF0dHJpYnV0ZVxuICAgICAgaWYgKGRhdGEuX3BhcmVudCA9PT0gbnVsbCAmJiB0eXBlb2YgdHJpZ2dlckRhdGEucGFyZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICBkYXRhLl9jb25maWcucGFyZW50ID0gdHJpZ2dlckRhdGEucGFyZW50XG4gICAgICAgIGRhdGEuX3BhcmVudCA9IGRhdGEuX2dldFBhcmVudCgpXG4gICAgICB9XG5cbiAgICAgIGNvbmZpZyA9ICd0b2dnbGUnXG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbmZpZyA9IHRyaWdnZXJEYXRhXG4gICAgfVxuXG4gICAgQ29sbGFwc2UuY29sbGFwc2VJbnRlcmZhY2UoZWxlbWVudCwgY29uZmlnKVxuICB9KVxufSlcblxuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIGpRdWVyeVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBhZGQgLkNvbGxhcHNlIHRvIGpRdWVyeSBvbmx5IGlmIGpRdWVyeSBpcyBwcmVzZW50XG4gKi9cblxuZGVmaW5lSlF1ZXJ5UGx1Z2luKENvbGxhcHNlKVxuXG5leHBvcnQgZGVmYXVsdCBDb2xsYXBzZVxuIiwiZXhwb3J0IHZhciB0b3AgPSAndG9wJztcbmV4cG9ydCB2YXIgYm90dG9tID0gJ2JvdHRvbSc7XG5leHBvcnQgdmFyIHJpZ2h0ID0gJ3JpZ2h0JztcbmV4cG9ydCB2YXIgbGVmdCA9ICdsZWZ0JztcbmV4cG9ydCB2YXIgYXV0byA9ICdhdXRvJztcbmV4cG9ydCB2YXIgYmFzZVBsYWNlbWVudHMgPSBbdG9wLCBib3R0b20sIHJpZ2h0LCBsZWZ0XTtcbmV4cG9ydCB2YXIgc3RhcnQgPSAnc3RhcnQnO1xuZXhwb3J0IHZhciBlbmQgPSAnZW5kJztcbmV4cG9ydCB2YXIgY2xpcHBpbmdQYXJlbnRzID0gJ2NsaXBwaW5nUGFyZW50cyc7XG5leHBvcnQgdmFyIHZpZXdwb3J0ID0gJ3ZpZXdwb3J0JztcbmV4cG9ydCB2YXIgcG9wcGVyID0gJ3BvcHBlcic7XG5leHBvcnQgdmFyIHJlZmVyZW5jZSA9ICdyZWZlcmVuY2UnO1xuZXhwb3J0IHZhciB2YXJpYXRpb25QbGFjZW1lbnRzID0gLyojX19QVVJFX18qL2Jhc2VQbGFjZW1lbnRzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIGFjYy5jb25jYXQoW3BsYWNlbWVudCArIFwiLVwiICsgc3RhcnQsIHBsYWNlbWVudCArIFwiLVwiICsgZW5kXSk7XG59LCBbXSk7XG5leHBvcnQgdmFyIHBsYWNlbWVudHMgPSAvKiNfX1BVUkVfXyovW10uY29uY2F0KGJhc2VQbGFjZW1lbnRzLCBbYXV0b10pLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIGFjYy5jb25jYXQoW3BsYWNlbWVudCwgcGxhY2VtZW50ICsgXCItXCIgKyBzdGFydCwgcGxhY2VtZW50ICsgXCItXCIgKyBlbmRdKTtcbn0sIFtdKTsgLy8gbW9kaWZpZXJzIHRoYXQgbmVlZCB0byByZWFkIHRoZSBET01cblxuZXhwb3J0IHZhciBiZWZvcmVSZWFkID0gJ2JlZm9yZVJlYWQnO1xuZXhwb3J0IHZhciByZWFkID0gJ3JlYWQnO1xuZXhwb3J0IHZhciBhZnRlclJlYWQgPSAnYWZ0ZXJSZWFkJzsgLy8gcHVyZS1sb2dpYyBtb2RpZmllcnNcblxuZXhwb3J0IHZhciBiZWZvcmVNYWluID0gJ2JlZm9yZU1haW4nO1xuZXhwb3J0IHZhciBtYWluID0gJ21haW4nO1xuZXhwb3J0IHZhciBhZnRlck1haW4gPSAnYWZ0ZXJNYWluJzsgLy8gbW9kaWZpZXIgd2l0aCB0aGUgcHVycG9zZSB0byB3cml0ZSB0byB0aGUgRE9NIChvciB3cml0ZSBpbnRvIGEgZnJhbWV3b3JrIHN0YXRlKVxuXG5leHBvcnQgdmFyIGJlZm9yZVdyaXRlID0gJ2JlZm9yZVdyaXRlJztcbmV4cG9ydCB2YXIgd3JpdGUgPSAnd3JpdGUnO1xuZXhwb3J0IHZhciBhZnRlcldyaXRlID0gJ2FmdGVyV3JpdGUnO1xuZXhwb3J0IHZhciBtb2RpZmllclBoYXNlcyA9IFtiZWZvcmVSZWFkLCByZWFkLCBhZnRlclJlYWQsIGJlZm9yZU1haW4sIG1haW4sIGFmdGVyTWFpbiwgYmVmb3JlV3JpdGUsIHdyaXRlLCBhZnRlcldyaXRlXTsiLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXROb2RlTmFtZShlbGVtZW50KSB7XG4gIHJldHVybiBlbGVtZW50ID8gKGVsZW1lbnQubm9kZU5hbWUgfHwgJycpLnRvTG93ZXJDYXNlKCkgOiBudWxsO1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldFdpbmRvdyhub2RlKSB7XG4gIGlmIChub2RlID09IG51bGwpIHtcbiAgICByZXR1cm4gd2luZG93O1xuICB9XG5cbiAgaWYgKG5vZGUudG9TdHJpbmcoKSAhPT0gJ1tvYmplY3QgV2luZG93XScpIHtcbiAgICB2YXIgb3duZXJEb2N1bWVudCA9IG5vZGUub3duZXJEb2N1bWVudDtcbiAgICByZXR1cm4gb3duZXJEb2N1bWVudCA/IG93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcgfHwgd2luZG93IDogd2luZG93O1xuICB9XG5cbiAgcmV0dXJuIG5vZGU7XG59IiwiaW1wb3J0IGdldFdpbmRvdyBmcm9tIFwiLi9nZXRXaW5kb3cuanNcIjtcblxuZnVuY3Rpb24gaXNFbGVtZW50KG5vZGUpIHtcbiAgdmFyIE93bkVsZW1lbnQgPSBnZXRXaW5kb3cobm9kZSkuRWxlbWVudDtcbiAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBPd25FbGVtZW50IHx8IG5vZGUgaW5zdGFuY2VvZiBFbGVtZW50O1xufVxuXG5mdW5jdGlvbiBpc0hUTUxFbGVtZW50KG5vZGUpIHtcbiAgdmFyIE93bkVsZW1lbnQgPSBnZXRXaW5kb3cobm9kZSkuSFRNTEVsZW1lbnQ7XG4gIHJldHVybiBub2RlIGluc3RhbmNlb2YgT3duRWxlbWVudCB8fCBub2RlIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQ7XG59XG5cbmZ1bmN0aW9uIGlzU2hhZG93Um9vdChub2RlKSB7XG4gIC8vIElFIDExIGhhcyBubyBTaGFkb3dSb290XG4gIGlmICh0eXBlb2YgU2hhZG93Um9vdCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgT3duRWxlbWVudCA9IGdldFdpbmRvdyhub2RlKS5TaGFkb3dSb290O1xuICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIE93bkVsZW1lbnQgfHwgbm9kZSBpbnN0YW5jZW9mIFNoYWRvd1Jvb3Q7XG59XG5cbmV4cG9ydCB7IGlzRWxlbWVudCwgaXNIVE1MRWxlbWVudCwgaXNTaGFkb3dSb290IH07IiwiaW1wb3J0IGdldE5vZGVOYW1lIGZyb20gXCIuLi9kb20tdXRpbHMvZ2V0Tm9kZU5hbWUuanNcIjtcbmltcG9ydCB7IGlzSFRNTEVsZW1lbnQgfSBmcm9tIFwiLi4vZG9tLXV0aWxzL2luc3RhbmNlT2YuanNcIjsgLy8gVGhpcyBtb2RpZmllciB0YWtlcyB0aGUgc3R5bGVzIHByZXBhcmVkIGJ5IHRoZSBgY29tcHV0ZVN0eWxlc2AgbW9kaWZpZXJcbi8vIGFuZCBhcHBsaWVzIHRoZW0gdG8gdGhlIEhUTUxFbGVtZW50cyBzdWNoIGFzIHBvcHBlciBhbmQgYXJyb3dcblxuZnVuY3Rpb24gYXBwbHlTdHlsZXMoX3JlZikge1xuICB2YXIgc3RhdGUgPSBfcmVmLnN0YXRlO1xuICBPYmplY3Qua2V5cyhzdGF0ZS5lbGVtZW50cykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgIHZhciBzdHlsZSA9IHN0YXRlLnN0eWxlc1tuYW1lXSB8fCB7fTtcbiAgICB2YXIgYXR0cmlidXRlcyA9IHN0YXRlLmF0dHJpYnV0ZXNbbmFtZV0gfHwge307XG4gICAgdmFyIGVsZW1lbnQgPSBzdGF0ZS5lbGVtZW50c1tuYW1lXTsgLy8gYXJyb3cgaXMgb3B0aW9uYWwgKyB2aXJ0dWFsIGVsZW1lbnRzXG5cbiAgICBpZiAoIWlzSFRNTEVsZW1lbnQoZWxlbWVudCkgfHwgIWdldE5vZGVOYW1lKGVsZW1lbnQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBGbG93IGRvZXNuJ3Qgc3VwcG9ydCB0byBleHRlbmQgdGhpcyBwcm9wZXJ0eSwgYnV0IGl0J3MgdGhlIG1vc3RcbiAgICAvLyBlZmZlY3RpdmUgd2F5IHRvIGFwcGx5IHN0eWxlcyB0byBhbiBIVE1MRWxlbWVudFxuICAgIC8vICRGbG93Rml4TWVbY2Fubm90LXdyaXRlXVxuXG5cbiAgICBPYmplY3QuYXNzaWduKGVsZW1lbnQuc3R5bGUsIHN0eWxlKTtcbiAgICBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICB2YXIgdmFsdWUgPSBhdHRyaWJ1dGVzW25hbWVdO1xuXG4gICAgICBpZiAodmFsdWUgPT09IGZhbHNlKSB7XG4gICAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUgPT09IHRydWUgPyAnJyA6IHZhbHVlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGVmZmVjdChfcmVmMikge1xuICB2YXIgc3RhdGUgPSBfcmVmMi5zdGF0ZTtcbiAgdmFyIGluaXRpYWxTdHlsZXMgPSB7XG4gICAgcG9wcGVyOiB7XG4gICAgICBwb3NpdGlvbjogc3RhdGUub3B0aW9ucy5zdHJhdGVneSxcbiAgICAgIGxlZnQ6ICcwJyxcbiAgICAgIHRvcDogJzAnLFxuICAgICAgbWFyZ2luOiAnMCdcbiAgICB9LFxuICAgIGFycm93OiB7XG4gICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJ1xuICAgIH0sXG4gICAgcmVmZXJlbmNlOiB7fVxuICB9O1xuICBPYmplY3QuYXNzaWduKHN0YXRlLmVsZW1lbnRzLnBvcHBlci5zdHlsZSwgaW5pdGlhbFN0eWxlcy5wb3BwZXIpO1xuICBzdGF0ZS5zdHlsZXMgPSBpbml0aWFsU3R5bGVzO1xuXG4gIGlmIChzdGF0ZS5lbGVtZW50cy5hcnJvdykge1xuICAgIE9iamVjdC5hc3NpZ24oc3RhdGUuZWxlbWVudHMuYXJyb3cuc3R5bGUsIGluaXRpYWxTdHlsZXMuYXJyb3cpO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBPYmplY3Qua2V5cyhzdGF0ZS5lbGVtZW50cykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgdmFyIGVsZW1lbnQgPSBzdGF0ZS5lbGVtZW50c1tuYW1lXTtcbiAgICAgIHZhciBhdHRyaWJ1dGVzID0gc3RhdGUuYXR0cmlidXRlc1tuYW1lXSB8fCB7fTtcbiAgICAgIHZhciBzdHlsZVByb3BlcnRpZXMgPSBPYmplY3Qua2V5cyhzdGF0ZS5zdHlsZXMuaGFzT3duUHJvcGVydHkobmFtZSkgPyBzdGF0ZS5zdHlsZXNbbmFtZV0gOiBpbml0aWFsU3R5bGVzW25hbWVdKTsgLy8gU2V0IGFsbCB2YWx1ZXMgdG8gYW4gZW1wdHkgc3RyaW5nIHRvIHVuc2V0IHRoZW1cblxuICAgICAgdmFyIHN0eWxlID0gc3R5bGVQcm9wZXJ0aWVzLnJlZHVjZShmdW5jdGlvbiAoc3R5bGUsIHByb3BlcnR5KSB7XG4gICAgICAgIHN0eWxlW3Byb3BlcnR5XSA9ICcnO1xuICAgICAgICByZXR1cm4gc3R5bGU7XG4gICAgICB9LCB7fSk7IC8vIGFycm93IGlzIG9wdGlvbmFsICsgdmlydHVhbCBlbGVtZW50c1xuXG4gICAgICBpZiAoIWlzSFRNTEVsZW1lbnQoZWxlbWVudCkgfHwgIWdldE5vZGVOYW1lKGVsZW1lbnQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgT2JqZWN0LmFzc2lnbihlbGVtZW50LnN0eWxlLCBzdHlsZSk7XG4gICAgICBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyaWJ1dGUpIHtcbiAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoYXR0cmlidXRlKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xufSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnYXBwbHlTdHlsZXMnLFxuICBlbmFibGVkOiB0cnVlLFxuICBwaGFzZTogJ3dyaXRlJyxcbiAgZm46IGFwcGx5U3R5bGVzLFxuICBlZmZlY3Q6IGVmZmVjdCxcbiAgcmVxdWlyZXM6IFsnY29tcHV0ZVN0eWxlcyddXG59OyIsImltcG9ydCB7IGF1dG8gfSBmcm9tIFwiLi4vZW51bXMuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldEJhc2VQbGFjZW1lbnQocGxhY2VtZW50KSB7XG4gIHJldHVybiBwbGFjZW1lbnQuc3BsaXQoJy0nKVswXTtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudCkge1xuICB2YXIgcmVjdCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIHJldHVybiB7XG4gICAgd2lkdGg6IHJlY3Qud2lkdGgsXG4gICAgaGVpZ2h0OiByZWN0LmhlaWdodCxcbiAgICB0b3A6IHJlY3QudG9wLFxuICAgIHJpZ2h0OiByZWN0LnJpZ2h0LFxuICAgIGJvdHRvbTogcmVjdC5ib3R0b20sXG4gICAgbGVmdDogcmVjdC5sZWZ0LFxuICAgIHg6IHJlY3QubGVmdCxcbiAgICB5OiByZWN0LnRvcFxuICB9O1xufSIsImltcG9ydCBnZXRCb3VuZGluZ0NsaWVudFJlY3QgZnJvbSBcIi4vZ2V0Qm91bmRpbmdDbGllbnRSZWN0LmpzXCI7IC8vIFJldHVybnMgdGhlIGxheW91dCByZWN0IG9mIGFuIGVsZW1lbnQgcmVsYXRpdmUgdG8gaXRzIG9mZnNldFBhcmVudC4gTGF5b3V0XG4vLyBtZWFucyBpdCBkb2Vzbid0IHRha2UgaW50byBhY2NvdW50IHRyYW5zZm9ybXMuXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldExheW91dFJlY3QoZWxlbWVudCkge1xuICB2YXIgY2xpZW50UmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChlbGVtZW50KTsgLy8gVXNlIHRoZSBjbGllbnRSZWN0IHNpemVzIGlmIGl0J3Mgbm90IGJlZW4gdHJhbnNmb3JtZWQuXG4gIC8vIEZpeGVzIGh0dHBzOi8vZ2l0aHViLmNvbS9wb3BwZXJqcy9wb3BwZXItY29yZS9pc3N1ZXMvMTIyM1xuXG4gIHZhciB3aWR0aCA9IGVsZW1lbnQub2Zmc2V0V2lkdGg7XG4gIHZhciBoZWlnaHQgPSBlbGVtZW50Lm9mZnNldEhlaWdodDtcblxuICBpZiAoTWF0aC5hYnMoY2xpZW50UmVjdC53aWR0aCAtIHdpZHRoKSA8PSAxKSB7XG4gICAgd2lkdGggPSBjbGllbnRSZWN0LndpZHRoO1xuICB9XG5cbiAgaWYgKE1hdGguYWJzKGNsaWVudFJlY3QuaGVpZ2h0IC0gaGVpZ2h0KSA8PSAxKSB7XG4gICAgaGVpZ2h0ID0gY2xpZW50UmVjdC5oZWlnaHQ7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHg6IGVsZW1lbnQub2Zmc2V0TGVmdCxcbiAgICB5OiBlbGVtZW50Lm9mZnNldFRvcCxcbiAgICB3aWR0aDogd2lkdGgsXG4gICAgaGVpZ2h0OiBoZWlnaHRcbiAgfTtcbn0iLCJpbXBvcnQgeyBpc1NoYWRvd1Jvb3QgfSBmcm9tIFwiLi9pbnN0YW5jZU9mLmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjb250YWlucyhwYXJlbnQsIGNoaWxkKSB7XG4gIHZhciByb290Tm9kZSA9IGNoaWxkLmdldFJvb3ROb2RlICYmIGNoaWxkLmdldFJvb3ROb2RlKCk7IC8vIEZpcnN0LCBhdHRlbXB0IHdpdGggZmFzdGVyIG5hdGl2ZSBtZXRob2RcblxuICBpZiAocGFyZW50LmNvbnRhaW5zKGNoaWxkKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IC8vIHRoZW4gZmFsbGJhY2sgdG8gY3VzdG9tIGltcGxlbWVudGF0aW9uIHdpdGggU2hhZG93IERPTSBzdXBwb3J0XG4gIGVsc2UgaWYgKHJvb3ROb2RlICYmIGlzU2hhZG93Um9vdChyb290Tm9kZSkpIHtcbiAgICAgIHZhciBuZXh0ID0gY2hpbGQ7XG5cbiAgICAgIGRvIHtcbiAgICAgICAgaWYgKG5leHQgJiYgcGFyZW50LmlzU2FtZU5vZGUobmV4dCkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ106IG5lZWQgYSBiZXR0ZXIgd2F5IHRvIGhhbmRsZSB0aGlzLi4uXG5cblxuICAgICAgICBuZXh0ID0gbmV4dC5wYXJlbnROb2RlIHx8IG5leHQuaG9zdDtcbiAgICAgIH0gd2hpbGUgKG5leHQpO1xuICAgIH0gLy8gR2l2ZSB1cCwgdGhlIHJlc3VsdCBpcyBmYWxzZVxuXG5cbiAgcmV0dXJuIGZhbHNlO1xufSIsImltcG9ydCBnZXRXaW5kb3cgZnJvbSBcIi4vZ2V0V2luZG93LmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpIHtcbiAgcmV0dXJuIGdldFdpbmRvdyhlbGVtZW50KS5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xufSIsImltcG9ydCBnZXROb2RlTmFtZSBmcm9tIFwiLi9nZXROb2RlTmFtZS5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaXNUYWJsZUVsZW1lbnQoZWxlbWVudCkge1xuICByZXR1cm4gWyd0YWJsZScsICd0ZCcsICd0aCddLmluZGV4T2YoZ2V0Tm9kZU5hbWUoZWxlbWVudCkpID49IDA7XG59IiwiaW1wb3J0IHsgaXNFbGVtZW50IH0gZnJvbSBcIi4vaW5zdGFuY2VPZi5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpIHtcbiAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtcmV0dXJuXTogYXNzdW1lIGJvZHkgaXMgYWx3YXlzIGF2YWlsYWJsZVxuICByZXR1cm4gKChpc0VsZW1lbnQoZWxlbWVudCkgPyBlbGVtZW50Lm93bmVyRG9jdW1lbnQgOiAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cbiAgZWxlbWVudC5kb2N1bWVudCkgfHwgd2luZG93LmRvY3VtZW50KS5kb2N1bWVudEVsZW1lbnQ7XG59IiwiaW1wb3J0IGdldE5vZGVOYW1lIGZyb20gXCIuL2dldE5vZGVOYW1lLmpzXCI7XG5pbXBvcnQgZ2V0RG9jdW1lbnRFbGVtZW50IGZyb20gXCIuL2dldERvY3VtZW50RWxlbWVudC5qc1wiO1xuaW1wb3J0IHsgaXNTaGFkb3dSb290IH0gZnJvbSBcIi4vaW5zdGFuY2VPZi5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0UGFyZW50Tm9kZShlbGVtZW50KSB7XG4gIGlmIChnZXROb2RlTmFtZShlbGVtZW50KSA9PT0gJ2h0bWwnKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cblxuICByZXR1cm4gKC8vIHRoaXMgaXMgYSBxdWlja2VyIChidXQgbGVzcyB0eXBlIHNhZmUpIHdheSB0byBzYXZlIHF1aXRlIHNvbWUgYnl0ZXMgZnJvbSB0aGUgYnVuZGxlXG4gICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtcmV0dXJuXVxuICAgIC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuICAgIGVsZW1lbnQuYXNzaWduZWRTbG90IHx8IC8vIHN0ZXAgaW50byB0aGUgc2hhZG93IERPTSBvZiB0aGUgcGFyZW50IG9mIGEgc2xvdHRlZCBub2RlXG4gICAgZWxlbWVudC5wYXJlbnROb2RlIHx8ICggLy8gRE9NIEVsZW1lbnQgZGV0ZWN0ZWRcbiAgICBpc1NoYWRvd1Jvb3QoZWxlbWVudCkgPyBlbGVtZW50Lmhvc3QgOiBudWxsKSB8fCAvLyBTaGFkb3dSb290IGRldGVjdGVkXG4gICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtY2FsbF06IEhUTUxFbGVtZW50IGlzIGEgTm9kZVxuICAgIGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KSAvLyBmYWxsYmFja1xuXG4gICk7XG59IiwiaW1wb3J0IGdldFdpbmRvdyBmcm9tIFwiLi9nZXRXaW5kb3cuanNcIjtcbmltcG9ydCBnZXROb2RlTmFtZSBmcm9tIFwiLi9nZXROb2RlTmFtZS5qc1wiO1xuaW1wb3J0IGdldENvbXB1dGVkU3R5bGUgZnJvbSBcIi4vZ2V0Q29tcHV0ZWRTdHlsZS5qc1wiO1xuaW1wb3J0IHsgaXNIVE1MRWxlbWVudCB9IGZyb20gXCIuL2luc3RhbmNlT2YuanNcIjtcbmltcG9ydCBpc1RhYmxlRWxlbWVudCBmcm9tIFwiLi9pc1RhYmxlRWxlbWVudC5qc1wiO1xuaW1wb3J0IGdldFBhcmVudE5vZGUgZnJvbSBcIi4vZ2V0UGFyZW50Tm9kZS5qc1wiO1xuXG5mdW5jdGlvbiBnZXRUcnVlT2Zmc2V0UGFyZW50KGVsZW1lbnQpIHtcbiAgaWYgKCFpc0hUTUxFbGVtZW50KGVsZW1lbnQpIHx8IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wb3BwZXJqcy9wb3BwZXItY29yZS9pc3N1ZXMvODM3XG4gIGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkucG9zaXRpb24gPT09ICdmaXhlZCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiBlbGVtZW50Lm9mZnNldFBhcmVudDtcbn0gLy8gYC5vZmZzZXRQYXJlbnRgIHJlcG9ydHMgYG51bGxgIGZvciBmaXhlZCBlbGVtZW50cywgd2hpbGUgYWJzb2x1dGUgZWxlbWVudHNcbi8vIHJldHVybiB0aGUgY29udGFpbmluZyBibG9ja1xuXG5cbmZ1bmN0aW9uIGdldENvbnRhaW5pbmdCbG9jayhlbGVtZW50KSB7XG4gIHZhciBpc0ZpcmVmb3ggPSBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkuaW5kZXhPZignZmlyZWZveCcpICE9PSAtMTtcbiAgdmFyIGlzSUUgPSBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ1RyaWRlbnQnKSAhPT0gLTE7XG5cbiAgaWYgKGlzSUUgJiYgaXNIVE1MRWxlbWVudChlbGVtZW50KSkge1xuICAgIC8vIEluIElFIDksIDEwIGFuZCAxMSBmaXhlZCBlbGVtZW50cyBjb250YWluaW5nIGJsb2NrIGlzIGFsd2F5cyBlc3RhYmxpc2hlZCBieSB0aGUgdmlld3BvcnRcbiAgICB2YXIgZWxlbWVudENzcyA9IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG5cbiAgICBpZiAoZWxlbWVudENzcy5wb3NpdGlvbiA9PT0gJ2ZpeGVkJykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgdmFyIGN1cnJlbnROb2RlID0gZ2V0UGFyZW50Tm9kZShlbGVtZW50KTtcblxuICB3aGlsZSAoaXNIVE1MRWxlbWVudChjdXJyZW50Tm9kZSkgJiYgWydodG1sJywgJ2JvZHknXS5pbmRleE9mKGdldE5vZGVOYW1lKGN1cnJlbnROb2RlKSkgPCAwKSB7XG4gICAgdmFyIGNzcyA9IGdldENvbXB1dGVkU3R5bGUoY3VycmVudE5vZGUpOyAvLyBUaGlzIGlzIG5vbi1leGhhdXN0aXZlIGJ1dCBjb3ZlcnMgdGhlIG1vc3QgY29tbW9uIENTUyBwcm9wZXJ0aWVzIHRoYXRcbiAgICAvLyBjcmVhdGUgYSBjb250YWluaW5nIGJsb2NrLlxuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy9Db250YWluaW5nX2Jsb2NrI2lkZW50aWZ5aW5nX3RoZV9jb250YWluaW5nX2Jsb2NrXG5cbiAgICBpZiAoY3NzLnRyYW5zZm9ybSAhPT0gJ25vbmUnIHx8IGNzcy5wZXJzcGVjdGl2ZSAhPT0gJ25vbmUnIHx8IGNzcy5jb250YWluID09PSAncGFpbnQnIHx8IFsndHJhbnNmb3JtJywgJ3BlcnNwZWN0aXZlJ10uaW5kZXhPZihjc3Mud2lsbENoYW5nZSkgIT09IC0xIHx8IGlzRmlyZWZveCAmJiBjc3Mud2lsbENoYW5nZSA9PT0gJ2ZpbHRlcicgfHwgaXNGaXJlZm94ICYmIGNzcy5maWx0ZXIgJiYgY3NzLmZpbHRlciAhPT0gJ25vbmUnKSB7XG4gICAgICByZXR1cm4gY3VycmVudE5vZGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cnJlbnROb2RlID0gY3VycmVudE5vZGUucGFyZW50Tm9kZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn0gLy8gR2V0cyB0aGUgY2xvc2VzdCBhbmNlc3RvciBwb3NpdGlvbmVkIGVsZW1lbnQuIEhhbmRsZXMgc29tZSBlZGdlIGNhc2VzLFxuLy8gc3VjaCBhcyB0YWJsZSBhbmNlc3RvcnMgYW5kIGNyb3NzIGJyb3dzZXIgYnVncy5cblxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRPZmZzZXRQYXJlbnQoZWxlbWVudCkge1xuICB2YXIgd2luZG93ID0gZ2V0V2luZG93KGVsZW1lbnQpO1xuICB2YXIgb2Zmc2V0UGFyZW50ID0gZ2V0VHJ1ZU9mZnNldFBhcmVudChlbGVtZW50KTtcblxuICB3aGlsZSAob2Zmc2V0UGFyZW50ICYmIGlzVGFibGVFbGVtZW50KG9mZnNldFBhcmVudCkgJiYgZ2V0Q29tcHV0ZWRTdHlsZShvZmZzZXRQYXJlbnQpLnBvc2l0aW9uID09PSAnc3RhdGljJykge1xuICAgIG9mZnNldFBhcmVudCA9IGdldFRydWVPZmZzZXRQYXJlbnQob2Zmc2V0UGFyZW50KTtcbiAgfVxuXG4gIGlmIChvZmZzZXRQYXJlbnQgJiYgKGdldE5vZGVOYW1lKG9mZnNldFBhcmVudCkgPT09ICdodG1sJyB8fCBnZXROb2RlTmFtZShvZmZzZXRQYXJlbnQpID09PSAnYm9keScgJiYgZ2V0Q29tcHV0ZWRTdHlsZShvZmZzZXRQYXJlbnQpLnBvc2l0aW9uID09PSAnc3RhdGljJykpIHtcbiAgICByZXR1cm4gd2luZG93O1xuICB9XG5cbiAgcmV0dXJuIG9mZnNldFBhcmVudCB8fCBnZXRDb250YWluaW5nQmxvY2soZWxlbWVudCkgfHwgd2luZG93O1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldE1haW5BeGlzRnJvbVBsYWNlbWVudChwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIFsndG9wJywgJ2JvdHRvbSddLmluZGV4T2YocGxhY2VtZW50KSA+PSAwID8gJ3gnIDogJ3knO1xufSIsImV4cG9ydCB2YXIgbWF4ID0gTWF0aC5tYXg7XG5leHBvcnQgdmFyIG1pbiA9IE1hdGgubWluO1xuZXhwb3J0IHZhciByb3VuZCA9IE1hdGgucm91bmQ7IiwiaW1wb3J0IHsgbWF4IGFzIG1hdGhNYXgsIG1pbiBhcyBtYXRoTWluIH0gZnJvbSBcIi4vbWF0aC5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gd2l0aGluKG1pbiwgdmFsdWUsIG1heCkge1xuICByZXR1cm4gbWF0aE1heChtaW4sIG1hdGhNaW4odmFsdWUsIG1heCkpO1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldEZyZXNoU2lkZU9iamVjdCgpIHtcbiAgcmV0dXJuIHtcbiAgICB0b3A6IDAsXG4gICAgcmlnaHQ6IDAsXG4gICAgYm90dG9tOiAwLFxuICAgIGxlZnQ6IDBcbiAgfTtcbn0iLCJpbXBvcnQgZ2V0RnJlc2hTaWRlT2JqZWN0IGZyb20gXCIuL2dldEZyZXNoU2lkZU9iamVjdC5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbWVyZ2VQYWRkaW5nT2JqZWN0KHBhZGRpbmdPYmplY3QpIHtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIGdldEZyZXNoU2lkZU9iamVjdCgpLCBwYWRkaW5nT2JqZWN0KTtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBleHBhbmRUb0hhc2hNYXAodmFsdWUsIGtleXMpIHtcbiAgcmV0dXJuIGtleXMucmVkdWNlKGZ1bmN0aW9uIChoYXNoTWFwLCBrZXkpIHtcbiAgICBoYXNoTWFwW2tleV0gPSB2YWx1ZTtcbiAgICByZXR1cm4gaGFzaE1hcDtcbiAgfSwge30pO1xufSIsImltcG9ydCBnZXRCYXNlUGxhY2VtZW50IGZyb20gXCIuLi91dGlscy9nZXRCYXNlUGxhY2VtZW50LmpzXCI7XG5pbXBvcnQgZ2V0TGF5b3V0UmVjdCBmcm9tIFwiLi4vZG9tLXV0aWxzL2dldExheW91dFJlY3QuanNcIjtcbmltcG9ydCBjb250YWlucyBmcm9tIFwiLi4vZG9tLXV0aWxzL2NvbnRhaW5zLmpzXCI7XG5pbXBvcnQgZ2V0T2Zmc2V0UGFyZW50IGZyb20gXCIuLi9kb20tdXRpbHMvZ2V0T2Zmc2V0UGFyZW50LmpzXCI7XG5pbXBvcnQgZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50IGZyb20gXCIuLi91dGlscy9nZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQuanNcIjtcbmltcG9ydCB3aXRoaW4gZnJvbSBcIi4uL3V0aWxzL3dpdGhpbi5qc1wiO1xuaW1wb3J0IG1lcmdlUGFkZGluZ09iamVjdCBmcm9tIFwiLi4vdXRpbHMvbWVyZ2VQYWRkaW5nT2JqZWN0LmpzXCI7XG5pbXBvcnQgZXhwYW5kVG9IYXNoTWFwIGZyb20gXCIuLi91dGlscy9leHBhbmRUb0hhc2hNYXAuanNcIjtcbmltcG9ydCB7IGxlZnQsIHJpZ2h0LCBiYXNlUGxhY2VtZW50cywgdG9wLCBib3R0b20gfSBmcm9tIFwiLi4vZW51bXMuanNcIjtcbmltcG9ydCB7IGlzSFRNTEVsZW1lbnQgfSBmcm9tIFwiLi4vZG9tLXV0aWxzL2luc3RhbmNlT2YuanNcIjsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG52YXIgdG9QYWRkaW5nT2JqZWN0ID0gZnVuY3Rpb24gdG9QYWRkaW5nT2JqZWN0KHBhZGRpbmcsIHN0YXRlKSB7XG4gIHBhZGRpbmcgPSB0eXBlb2YgcGFkZGluZyA9PT0gJ2Z1bmN0aW9uJyA/IHBhZGRpbmcoT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUucmVjdHMsIHtcbiAgICBwbGFjZW1lbnQ6IHN0YXRlLnBsYWNlbWVudFxuICB9KSkgOiBwYWRkaW5nO1xuICByZXR1cm4gbWVyZ2VQYWRkaW5nT2JqZWN0KHR5cGVvZiBwYWRkaW5nICE9PSAnbnVtYmVyJyA/IHBhZGRpbmcgOiBleHBhbmRUb0hhc2hNYXAocGFkZGluZywgYmFzZVBsYWNlbWVudHMpKTtcbn07XG5cbmZ1bmN0aW9uIGFycm93KF9yZWYpIHtcbiAgdmFyIF9zdGF0ZSRtb2RpZmllcnNEYXRhJDtcblxuICB2YXIgc3RhdGUgPSBfcmVmLnN0YXRlLFxuICAgICAgbmFtZSA9IF9yZWYubmFtZSxcbiAgICAgIG9wdGlvbnMgPSBfcmVmLm9wdGlvbnM7XG4gIHZhciBhcnJvd0VsZW1lbnQgPSBzdGF0ZS5lbGVtZW50cy5hcnJvdztcbiAgdmFyIHBvcHBlck9mZnNldHMgPSBzdGF0ZS5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHM7XG4gIHZhciBiYXNlUGxhY2VtZW50ID0gZ2V0QmFzZVBsYWNlbWVudChzdGF0ZS5wbGFjZW1lbnQpO1xuICB2YXIgYXhpcyA9IGdldE1haW5BeGlzRnJvbVBsYWNlbWVudChiYXNlUGxhY2VtZW50KTtcbiAgdmFyIGlzVmVydGljYWwgPSBbbGVmdCwgcmlnaHRdLmluZGV4T2YoYmFzZVBsYWNlbWVudCkgPj0gMDtcbiAgdmFyIGxlbiA9IGlzVmVydGljYWwgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG5cbiAgaWYgKCFhcnJvd0VsZW1lbnQgfHwgIXBvcHBlck9mZnNldHMpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgcGFkZGluZ09iamVjdCA9IHRvUGFkZGluZ09iamVjdChvcHRpb25zLnBhZGRpbmcsIHN0YXRlKTtcbiAgdmFyIGFycm93UmVjdCA9IGdldExheW91dFJlY3QoYXJyb3dFbGVtZW50KTtcbiAgdmFyIG1pblByb3AgPSBheGlzID09PSAneScgPyB0b3AgOiBsZWZ0O1xuICB2YXIgbWF4UHJvcCA9IGF4aXMgPT09ICd5JyA/IGJvdHRvbSA6IHJpZ2h0O1xuICB2YXIgZW5kRGlmZiA9IHN0YXRlLnJlY3RzLnJlZmVyZW5jZVtsZW5dICsgc3RhdGUucmVjdHMucmVmZXJlbmNlW2F4aXNdIC0gcG9wcGVyT2Zmc2V0c1theGlzXSAtIHN0YXRlLnJlY3RzLnBvcHBlcltsZW5dO1xuICB2YXIgc3RhcnREaWZmID0gcG9wcGVyT2Zmc2V0c1theGlzXSAtIHN0YXRlLnJlY3RzLnJlZmVyZW5jZVtheGlzXTtcbiAgdmFyIGFycm93T2Zmc2V0UGFyZW50ID0gZ2V0T2Zmc2V0UGFyZW50KGFycm93RWxlbWVudCk7XG4gIHZhciBjbGllbnRTaXplID0gYXJyb3dPZmZzZXRQYXJlbnQgPyBheGlzID09PSAneScgPyBhcnJvd09mZnNldFBhcmVudC5jbGllbnRIZWlnaHQgfHwgMCA6IGFycm93T2Zmc2V0UGFyZW50LmNsaWVudFdpZHRoIHx8IDAgOiAwO1xuICB2YXIgY2VudGVyVG9SZWZlcmVuY2UgPSBlbmREaWZmIC8gMiAtIHN0YXJ0RGlmZiAvIDI7IC8vIE1ha2Ugc3VyZSB0aGUgYXJyb3cgZG9lc24ndCBvdmVyZmxvdyB0aGUgcG9wcGVyIGlmIHRoZSBjZW50ZXIgcG9pbnQgaXNcbiAgLy8gb3V0c2lkZSBvZiB0aGUgcG9wcGVyIGJvdW5kc1xuXG4gIHZhciBtaW4gPSBwYWRkaW5nT2JqZWN0W21pblByb3BdO1xuICB2YXIgbWF4ID0gY2xpZW50U2l6ZSAtIGFycm93UmVjdFtsZW5dIC0gcGFkZGluZ09iamVjdFttYXhQcm9wXTtcbiAgdmFyIGNlbnRlciA9IGNsaWVudFNpemUgLyAyIC0gYXJyb3dSZWN0W2xlbl0gLyAyICsgY2VudGVyVG9SZWZlcmVuY2U7XG4gIHZhciBvZmZzZXQgPSB3aXRoaW4obWluLCBjZW50ZXIsIG1heCk7IC8vIFByZXZlbnRzIGJyZWFraW5nIHN5bnRheCBoaWdobGlnaHRpbmcuLi5cblxuICB2YXIgYXhpc1Byb3AgPSBheGlzO1xuICBzdGF0ZS5tb2RpZmllcnNEYXRhW25hbWVdID0gKF9zdGF0ZSRtb2RpZmllcnNEYXRhJCA9IHt9LCBfc3RhdGUkbW9kaWZpZXJzRGF0YSRbYXhpc1Byb3BdID0gb2Zmc2V0LCBfc3RhdGUkbW9kaWZpZXJzRGF0YSQuY2VudGVyT2Zmc2V0ID0gb2Zmc2V0IC0gY2VudGVyLCBfc3RhdGUkbW9kaWZpZXJzRGF0YSQpO1xufVxuXG5mdW5jdGlvbiBlZmZlY3QoX3JlZjIpIHtcbiAgdmFyIHN0YXRlID0gX3JlZjIuc3RhdGUsXG4gICAgICBvcHRpb25zID0gX3JlZjIub3B0aW9ucztcbiAgdmFyIF9vcHRpb25zJGVsZW1lbnQgPSBvcHRpb25zLmVsZW1lbnQsXG4gICAgICBhcnJvd0VsZW1lbnQgPSBfb3B0aW9ucyRlbGVtZW50ID09PSB2b2lkIDAgPyAnW2RhdGEtcG9wcGVyLWFycm93XScgOiBfb3B0aW9ucyRlbGVtZW50O1xuXG4gIGlmIChhcnJvd0VsZW1lbnQgPT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfSAvLyBDU1Mgc2VsZWN0b3JcblxuXG4gIGlmICh0eXBlb2YgYXJyb3dFbGVtZW50ID09PSAnc3RyaW5nJykge1xuICAgIGFycm93RWxlbWVudCA9IHN0YXRlLmVsZW1lbnRzLnBvcHBlci5xdWVyeVNlbGVjdG9yKGFycm93RWxlbWVudCk7XG5cbiAgICBpZiAoIWFycm93RWxlbWVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBpZiAoIWlzSFRNTEVsZW1lbnQoYXJyb3dFbGVtZW50KSkge1xuICAgICAgY29uc29sZS5lcnJvcihbJ1BvcHBlcjogXCJhcnJvd1wiIGVsZW1lbnQgbXVzdCBiZSBhbiBIVE1MRWxlbWVudCAobm90IGFuIFNWR0VsZW1lbnQpLicsICdUbyB1c2UgYW4gU1ZHIGFycm93LCB3cmFwIGl0IGluIGFuIEhUTUxFbGVtZW50IHRoYXQgd2lsbCBiZSB1c2VkIGFzJywgJ3RoZSBhcnJvdy4nXS5qb2luKCcgJykpO1xuICAgIH1cbiAgfVxuXG4gIGlmICghY29udGFpbnMoc3RhdGUuZWxlbWVudHMucG9wcGVyLCBhcnJvd0VsZW1lbnQpKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgY29uc29sZS5lcnJvcihbJ1BvcHBlcjogXCJhcnJvd1wiIG1vZGlmaWVyXFwncyBgZWxlbWVudGAgbXVzdCBiZSBhIGNoaWxkIG9mIHRoZSBwb3BwZXInLCAnZWxlbWVudC4nXS5qb2luKCcgJykpO1xuICAgIH1cblxuICAgIHJldHVybjtcbiAgfVxuXG4gIHN0YXRlLmVsZW1lbnRzLmFycm93ID0gYXJyb3dFbGVtZW50O1xufSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnYXJyb3cnLFxuICBlbmFibGVkOiB0cnVlLFxuICBwaGFzZTogJ21haW4nLFxuICBmbjogYXJyb3csXG4gIGVmZmVjdDogZWZmZWN0LFxuICByZXF1aXJlczogWydwb3BwZXJPZmZzZXRzJ10sXG4gIHJlcXVpcmVzSWZFeGlzdHM6IFsncHJldmVudE92ZXJmbG93J11cbn07IiwiaW1wb3J0IHsgdG9wLCBsZWZ0LCByaWdodCwgYm90dG9tIH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7XG5pbXBvcnQgZ2V0T2Zmc2V0UGFyZW50IGZyb20gXCIuLi9kb20tdXRpbHMvZ2V0T2Zmc2V0UGFyZW50LmpzXCI7XG5pbXBvcnQgZ2V0V2luZG93IGZyb20gXCIuLi9kb20tdXRpbHMvZ2V0V2luZG93LmpzXCI7XG5pbXBvcnQgZ2V0RG9jdW1lbnRFbGVtZW50IGZyb20gXCIuLi9kb20tdXRpbHMvZ2V0RG9jdW1lbnRFbGVtZW50LmpzXCI7XG5pbXBvcnQgZ2V0Q29tcHV0ZWRTdHlsZSBmcm9tIFwiLi4vZG9tLXV0aWxzL2dldENvbXB1dGVkU3R5bGUuanNcIjtcbmltcG9ydCBnZXRCYXNlUGxhY2VtZW50IGZyb20gXCIuLi91dGlscy9nZXRCYXNlUGxhY2VtZW50LmpzXCI7XG5pbXBvcnQgeyByb3VuZCB9IGZyb20gXCIuLi91dGlscy9tYXRoLmpzXCI7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxudmFyIHVuc2V0U2lkZXMgPSB7XG4gIHRvcDogJ2F1dG8nLFxuICByaWdodDogJ2F1dG8nLFxuICBib3R0b206ICdhdXRvJyxcbiAgbGVmdDogJ2F1dG8nXG59OyAvLyBSb3VuZCB0aGUgb2Zmc2V0cyB0byB0aGUgbmVhcmVzdCBzdWl0YWJsZSBzdWJwaXhlbCBiYXNlZCBvbiB0aGUgRFBSLlxuLy8gWm9vbWluZyBjYW4gY2hhbmdlIHRoZSBEUFIsIGJ1dCBpdCBzZWVtcyB0byByZXBvcnQgYSB2YWx1ZSB0aGF0IHdpbGxcbi8vIGNsZWFubHkgZGl2aWRlIHRoZSB2YWx1ZXMgaW50byB0aGUgYXBwcm9wcmlhdGUgc3VicGl4ZWxzLlxuXG5mdW5jdGlvbiByb3VuZE9mZnNldHNCeURQUihfcmVmKSB7XG4gIHZhciB4ID0gX3JlZi54LFxuICAgICAgeSA9IF9yZWYueTtcbiAgdmFyIHdpbiA9IHdpbmRvdztcbiAgdmFyIGRwciA9IHdpbi5kZXZpY2VQaXhlbFJhdGlvIHx8IDE7XG4gIHJldHVybiB7XG4gICAgeDogcm91bmQocm91bmQoeCAqIGRwcikgLyBkcHIpIHx8IDAsXG4gICAgeTogcm91bmQocm91bmQoeSAqIGRwcikgLyBkcHIpIHx8IDBcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1hcFRvU3R5bGVzKF9yZWYyKSB7XG4gIHZhciBfT2JqZWN0JGFzc2lnbjI7XG5cbiAgdmFyIHBvcHBlciA9IF9yZWYyLnBvcHBlcixcbiAgICAgIHBvcHBlclJlY3QgPSBfcmVmMi5wb3BwZXJSZWN0LFxuICAgICAgcGxhY2VtZW50ID0gX3JlZjIucGxhY2VtZW50LFxuICAgICAgb2Zmc2V0cyA9IF9yZWYyLm9mZnNldHMsXG4gICAgICBwb3NpdGlvbiA9IF9yZWYyLnBvc2l0aW9uLFxuICAgICAgZ3B1QWNjZWxlcmF0aW9uID0gX3JlZjIuZ3B1QWNjZWxlcmF0aW9uLFxuICAgICAgYWRhcHRpdmUgPSBfcmVmMi5hZGFwdGl2ZSxcbiAgICAgIHJvdW5kT2Zmc2V0cyA9IF9yZWYyLnJvdW5kT2Zmc2V0cztcblxuICB2YXIgX3JlZjMgPSByb3VuZE9mZnNldHMgPT09IHRydWUgPyByb3VuZE9mZnNldHNCeURQUihvZmZzZXRzKSA6IHR5cGVvZiByb3VuZE9mZnNldHMgPT09ICdmdW5jdGlvbicgPyByb3VuZE9mZnNldHMob2Zmc2V0cykgOiBvZmZzZXRzLFxuICAgICAgX3JlZjMkeCA9IF9yZWYzLngsXG4gICAgICB4ID0gX3JlZjMkeCA9PT0gdm9pZCAwID8gMCA6IF9yZWYzJHgsXG4gICAgICBfcmVmMyR5ID0gX3JlZjMueSxcbiAgICAgIHkgPSBfcmVmMyR5ID09PSB2b2lkIDAgPyAwIDogX3JlZjMkeTtcblxuICB2YXIgaGFzWCA9IG9mZnNldHMuaGFzT3duUHJvcGVydHkoJ3gnKTtcbiAgdmFyIGhhc1kgPSBvZmZzZXRzLmhhc093blByb3BlcnR5KCd5Jyk7XG4gIHZhciBzaWRlWCA9IGxlZnQ7XG4gIHZhciBzaWRlWSA9IHRvcDtcbiAgdmFyIHdpbiA9IHdpbmRvdztcblxuICBpZiAoYWRhcHRpdmUpIHtcbiAgICB2YXIgb2Zmc2V0UGFyZW50ID0gZ2V0T2Zmc2V0UGFyZW50KHBvcHBlcik7XG4gICAgdmFyIGhlaWdodFByb3AgPSAnY2xpZW50SGVpZ2h0JztcbiAgICB2YXIgd2lkdGhQcm9wID0gJ2NsaWVudFdpZHRoJztcblxuICAgIGlmIChvZmZzZXRQYXJlbnQgPT09IGdldFdpbmRvdyhwb3BwZXIpKSB7XG4gICAgICBvZmZzZXRQYXJlbnQgPSBnZXREb2N1bWVudEVsZW1lbnQocG9wcGVyKTtcblxuICAgICAgaWYgKGdldENvbXB1dGVkU3R5bGUob2Zmc2V0UGFyZW50KS5wb3NpdGlvbiAhPT0gJ3N0YXRpYycpIHtcbiAgICAgICAgaGVpZ2h0UHJvcCA9ICdzY3JvbGxIZWlnaHQnO1xuICAgICAgICB3aWR0aFByb3AgPSAnc2Nyb2xsV2lkdGgnO1xuICAgICAgfVxuICAgIH0gLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtY2FzdF06IGZvcmNlIHR5cGUgcmVmaW5lbWVudCwgd2UgY29tcGFyZSBvZmZzZXRQYXJlbnQgd2l0aCB3aW5kb3cgYWJvdmUsIGJ1dCBGbG93IGRvZXNuJ3QgZGV0ZWN0IGl0XG5cblxuICAgIG9mZnNldFBhcmVudCA9IG9mZnNldFBhcmVudDtcblxuICAgIGlmIChwbGFjZW1lbnQgPT09IHRvcCkge1xuICAgICAgc2lkZVkgPSBib3R0b207IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuXG4gICAgICB5IC09IG9mZnNldFBhcmVudFtoZWlnaHRQcm9wXSAtIHBvcHBlclJlY3QuaGVpZ2h0O1xuICAgICAgeSAqPSBncHVBY2NlbGVyYXRpb24gPyAxIDogLTE7XG4gICAgfVxuXG4gICAgaWYgKHBsYWNlbWVudCA9PT0gbGVmdCkge1xuICAgICAgc2lkZVggPSByaWdodDsgLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG5cbiAgICAgIHggLT0gb2Zmc2V0UGFyZW50W3dpZHRoUHJvcF0gLSBwb3BwZXJSZWN0LndpZHRoO1xuICAgICAgeCAqPSBncHVBY2NlbGVyYXRpb24gPyAxIDogLTE7XG4gICAgfVxuICB9XG5cbiAgdmFyIGNvbW1vblN0eWxlcyA9IE9iamVjdC5hc3NpZ24oe1xuICAgIHBvc2l0aW9uOiBwb3NpdGlvblxuICB9LCBhZGFwdGl2ZSAmJiB1bnNldFNpZGVzKTtcblxuICBpZiAoZ3B1QWNjZWxlcmF0aW9uKSB7XG4gICAgdmFyIF9PYmplY3QkYXNzaWduO1xuXG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIGNvbW1vblN0eWxlcywgKF9PYmplY3QkYXNzaWduID0ge30sIF9PYmplY3QkYXNzaWduW3NpZGVZXSA9IGhhc1kgPyAnMCcgOiAnJywgX09iamVjdCRhc3NpZ25bc2lkZVhdID0gaGFzWCA/ICcwJyA6ICcnLCBfT2JqZWN0JGFzc2lnbi50cmFuc2Zvcm0gPSAod2luLmRldmljZVBpeGVsUmF0aW8gfHwgMSkgPCAyID8gXCJ0cmFuc2xhdGUoXCIgKyB4ICsgXCJweCwgXCIgKyB5ICsgXCJweClcIiA6IFwidHJhbnNsYXRlM2QoXCIgKyB4ICsgXCJweCwgXCIgKyB5ICsgXCJweCwgMClcIiwgX09iamVjdCRhc3NpZ24pKTtcbiAgfVxuXG4gIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBjb21tb25TdHlsZXMsIChfT2JqZWN0JGFzc2lnbjIgPSB7fSwgX09iamVjdCRhc3NpZ24yW3NpZGVZXSA9IGhhc1kgPyB5ICsgXCJweFwiIDogJycsIF9PYmplY3QkYXNzaWduMltzaWRlWF0gPSBoYXNYID8geCArIFwicHhcIiA6ICcnLCBfT2JqZWN0JGFzc2lnbjIudHJhbnNmb3JtID0gJycsIF9PYmplY3QkYXNzaWduMikpO1xufVxuXG5mdW5jdGlvbiBjb21wdXRlU3R5bGVzKF9yZWY0KSB7XG4gIHZhciBzdGF0ZSA9IF9yZWY0LnN0YXRlLFxuICAgICAgb3B0aW9ucyA9IF9yZWY0Lm9wdGlvbnM7XG4gIHZhciBfb3B0aW9ucyRncHVBY2NlbGVyYXQgPSBvcHRpb25zLmdwdUFjY2VsZXJhdGlvbixcbiAgICAgIGdwdUFjY2VsZXJhdGlvbiA9IF9vcHRpb25zJGdwdUFjY2VsZXJhdCA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJGdwdUFjY2VsZXJhdCxcbiAgICAgIF9vcHRpb25zJGFkYXB0aXZlID0gb3B0aW9ucy5hZGFwdGl2ZSxcbiAgICAgIGFkYXB0aXZlID0gX29wdGlvbnMkYWRhcHRpdmUgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRhZGFwdGl2ZSxcbiAgICAgIF9vcHRpb25zJHJvdW5kT2Zmc2V0cyA9IG9wdGlvbnMucm91bmRPZmZzZXRzLFxuICAgICAgcm91bmRPZmZzZXRzID0gX29wdGlvbnMkcm91bmRPZmZzZXRzID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkcm91bmRPZmZzZXRzO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICB2YXIgdHJhbnNpdGlvblByb3BlcnR5ID0gZ2V0Q29tcHV0ZWRTdHlsZShzdGF0ZS5lbGVtZW50cy5wb3BwZXIpLnRyYW5zaXRpb25Qcm9wZXJ0eSB8fCAnJztcblxuICAgIGlmIChhZGFwdGl2ZSAmJiBbJ3RyYW5zZm9ybScsICd0b3AnLCAncmlnaHQnLCAnYm90dG9tJywgJ2xlZnQnXS5zb21lKGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xuICAgICAgcmV0dXJuIHRyYW5zaXRpb25Qcm9wZXJ0eS5pbmRleE9mKHByb3BlcnR5KSA+PSAwO1xuICAgIH0pKSB7XG4gICAgICBjb25zb2xlLndhcm4oWydQb3BwZXI6IERldGVjdGVkIENTUyB0cmFuc2l0aW9ucyBvbiBhdCBsZWFzdCBvbmUgb2YgdGhlIGZvbGxvd2luZycsICdDU1MgcHJvcGVydGllczogXCJ0cmFuc2Zvcm1cIiwgXCJ0b3BcIiwgXCJyaWdodFwiLCBcImJvdHRvbVwiLCBcImxlZnRcIi4nLCAnXFxuXFxuJywgJ0Rpc2FibGUgdGhlIFwiY29tcHV0ZVN0eWxlc1wiIG1vZGlmaWVyXFwncyBgYWRhcHRpdmVgIG9wdGlvbiB0byBhbGxvdycsICdmb3Igc21vb3RoIHRyYW5zaXRpb25zLCBvciByZW1vdmUgdGhlc2UgcHJvcGVydGllcyBmcm9tIHRoZSBDU1MnLCAndHJhbnNpdGlvbiBkZWNsYXJhdGlvbiBvbiB0aGUgcG9wcGVyIGVsZW1lbnQgaWYgb25seSB0cmFuc2l0aW9uaW5nJywgJ29wYWNpdHkgb3IgYmFja2dyb3VuZC1jb2xvciBmb3IgZXhhbXBsZS4nLCAnXFxuXFxuJywgJ1dlIHJlY29tbWVuZCB1c2luZyB0aGUgcG9wcGVyIGVsZW1lbnQgYXMgYSB3cmFwcGVyIGFyb3VuZCBhbiBpbm5lcicsICdlbGVtZW50IHRoYXQgY2FuIGhhdmUgYW55IENTUyBwcm9wZXJ0eSB0cmFuc2l0aW9uZWQgZm9yIGFuaW1hdGlvbnMuJ10uam9pbignICcpKTtcbiAgICB9XG4gIH1cblxuICB2YXIgY29tbW9uU3R5bGVzID0ge1xuICAgIHBsYWNlbWVudDogZ2V0QmFzZVBsYWNlbWVudChzdGF0ZS5wbGFjZW1lbnQpLFxuICAgIHBvcHBlcjogc3RhdGUuZWxlbWVudHMucG9wcGVyLFxuICAgIHBvcHBlclJlY3Q6IHN0YXRlLnJlY3RzLnBvcHBlcixcbiAgICBncHVBY2NlbGVyYXRpb246IGdwdUFjY2VsZXJhdGlvblxuICB9O1xuXG4gIGlmIChzdGF0ZS5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHMgIT0gbnVsbCkge1xuICAgIHN0YXRlLnN0eWxlcy5wb3BwZXIgPSBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZS5zdHlsZXMucG9wcGVyLCBtYXBUb1N0eWxlcyhPYmplY3QuYXNzaWduKHt9LCBjb21tb25TdHlsZXMsIHtcbiAgICAgIG9mZnNldHM6IHN0YXRlLm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cyxcbiAgICAgIHBvc2l0aW9uOiBzdGF0ZS5vcHRpb25zLnN0cmF0ZWd5LFxuICAgICAgYWRhcHRpdmU6IGFkYXB0aXZlLFxuICAgICAgcm91bmRPZmZzZXRzOiByb3VuZE9mZnNldHNcbiAgICB9KSkpO1xuICB9XG5cbiAgaWYgKHN0YXRlLm1vZGlmaWVyc0RhdGEuYXJyb3cgIT0gbnVsbCkge1xuICAgIHN0YXRlLnN0eWxlcy5hcnJvdyA9IE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLnN0eWxlcy5hcnJvdywgbWFwVG9TdHlsZXMoT2JqZWN0LmFzc2lnbih7fSwgY29tbW9uU3R5bGVzLCB7XG4gICAgICBvZmZzZXRzOiBzdGF0ZS5tb2RpZmllcnNEYXRhLmFycm93LFxuICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICBhZGFwdGl2ZTogZmFsc2UsXG4gICAgICByb3VuZE9mZnNldHM6IHJvdW5kT2Zmc2V0c1xuICAgIH0pKSk7XG4gIH1cblxuICBzdGF0ZS5hdHRyaWJ1dGVzLnBvcHBlciA9IE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLmF0dHJpYnV0ZXMucG9wcGVyLCB7XG4gICAgJ2RhdGEtcG9wcGVyLXBsYWNlbWVudCc6IHN0YXRlLnBsYWNlbWVudFxuICB9KTtcbn0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ2NvbXB1dGVTdHlsZXMnLFxuICBlbmFibGVkOiB0cnVlLFxuICBwaGFzZTogJ2JlZm9yZVdyaXRlJyxcbiAgZm46IGNvbXB1dGVTdHlsZXMsXG4gIGRhdGE6IHt9XG59OyIsImltcG9ydCBnZXRXaW5kb3cgZnJvbSBcIi4uL2RvbS11dGlscy9nZXRXaW5kb3cuanNcIjsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG52YXIgcGFzc2l2ZSA9IHtcbiAgcGFzc2l2ZTogdHJ1ZVxufTtcblxuZnVuY3Rpb24gZWZmZWN0KF9yZWYpIHtcbiAgdmFyIHN0YXRlID0gX3JlZi5zdGF0ZSxcbiAgICAgIGluc3RhbmNlID0gX3JlZi5pbnN0YW5jZSxcbiAgICAgIG9wdGlvbnMgPSBfcmVmLm9wdGlvbnM7XG4gIHZhciBfb3B0aW9ucyRzY3JvbGwgPSBvcHRpb25zLnNjcm9sbCxcbiAgICAgIHNjcm9sbCA9IF9vcHRpb25zJHNjcm9sbCA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJHNjcm9sbCxcbiAgICAgIF9vcHRpb25zJHJlc2l6ZSA9IG9wdGlvbnMucmVzaXplLFxuICAgICAgcmVzaXplID0gX29wdGlvbnMkcmVzaXplID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkcmVzaXplO1xuICB2YXIgd2luZG93ID0gZ2V0V2luZG93KHN0YXRlLmVsZW1lbnRzLnBvcHBlcik7XG4gIHZhciBzY3JvbGxQYXJlbnRzID0gW10uY29uY2F0KHN0YXRlLnNjcm9sbFBhcmVudHMucmVmZXJlbmNlLCBzdGF0ZS5zY3JvbGxQYXJlbnRzLnBvcHBlcik7XG5cbiAgaWYgKHNjcm9sbCkge1xuICAgIHNjcm9sbFBhcmVudHMuZm9yRWFjaChmdW5jdGlvbiAoc2Nyb2xsUGFyZW50KSB7XG4gICAgICBzY3JvbGxQYXJlbnQuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgaW5zdGFuY2UudXBkYXRlLCBwYXNzaXZlKTtcbiAgICB9KTtcbiAgfVxuXG4gIGlmIChyZXNpemUpIHtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgaW5zdGFuY2UudXBkYXRlLCBwYXNzaXZlKTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHNjcm9sbCkge1xuICAgICAgc2Nyb2xsUGFyZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChzY3JvbGxQYXJlbnQpIHtcbiAgICAgICAgc2Nyb2xsUGFyZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIGluc3RhbmNlLnVwZGF0ZSwgcGFzc2l2ZSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAocmVzaXplKSB7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgaW5zdGFuY2UudXBkYXRlLCBwYXNzaXZlKTtcbiAgICB9XG4gIH07XG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdldmVudExpc3RlbmVycycsXG4gIGVuYWJsZWQ6IHRydWUsXG4gIHBoYXNlOiAnd3JpdGUnLFxuICBmbjogZnVuY3Rpb24gZm4oKSB7fSxcbiAgZWZmZWN0OiBlZmZlY3QsXG4gIGRhdGE6IHt9XG59OyIsInZhciBoYXNoID0ge1xuICBsZWZ0OiAncmlnaHQnLFxuICByaWdodDogJ2xlZnQnLFxuICBib3R0b206ICd0b3AnLFxuICB0b3A6ICdib3R0b20nXG59O1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQocGxhY2VtZW50KSB7XG4gIHJldHVybiBwbGFjZW1lbnQucmVwbGFjZSgvbGVmdHxyaWdodHxib3R0b218dG9wL2csIGZ1bmN0aW9uIChtYXRjaGVkKSB7XG4gICAgcmV0dXJuIGhhc2hbbWF0Y2hlZF07XG4gIH0pO1xufSIsInZhciBoYXNoID0ge1xuICBzdGFydDogJ2VuZCcsXG4gIGVuZDogJ3N0YXJ0J1xufTtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldE9wcG9zaXRlVmFyaWF0aW9uUGxhY2VtZW50KHBsYWNlbWVudCkge1xuICByZXR1cm4gcGxhY2VtZW50LnJlcGxhY2UoL3N0YXJ0fGVuZC9nLCBmdW5jdGlvbiAobWF0Y2hlZCkge1xuICAgIHJldHVybiBoYXNoW21hdGNoZWRdO1xuICB9KTtcbn0iLCJpbXBvcnQgZ2V0V2luZG93IGZyb20gXCIuL2dldFdpbmRvdy5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0V2luZG93U2Nyb2xsKG5vZGUpIHtcbiAgdmFyIHdpbiA9IGdldFdpbmRvdyhub2RlKTtcbiAgdmFyIHNjcm9sbExlZnQgPSB3aW4ucGFnZVhPZmZzZXQ7XG4gIHZhciBzY3JvbGxUb3AgPSB3aW4ucGFnZVlPZmZzZXQ7XG4gIHJldHVybiB7XG4gICAgc2Nyb2xsTGVmdDogc2Nyb2xsTGVmdCxcbiAgICBzY3JvbGxUb3A6IHNjcm9sbFRvcFxuICB9O1xufSIsImltcG9ydCBnZXRCb3VuZGluZ0NsaWVudFJlY3QgZnJvbSBcIi4vZ2V0Qm91bmRpbmdDbGllbnRSZWN0LmpzXCI7XG5pbXBvcnQgZ2V0RG9jdW1lbnRFbGVtZW50IGZyb20gXCIuL2dldERvY3VtZW50RWxlbWVudC5qc1wiO1xuaW1wb3J0IGdldFdpbmRvd1Njcm9sbCBmcm9tIFwiLi9nZXRXaW5kb3dTY3JvbGwuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldFdpbmRvd1Njcm9sbEJhclgoZWxlbWVudCkge1xuICAvLyBJZiA8aHRtbD4gaGFzIGEgQ1NTIHdpZHRoIGdyZWF0ZXIgdGhhbiB0aGUgdmlld3BvcnQsIHRoZW4gdGhpcyB3aWxsIGJlXG4gIC8vIGluY29ycmVjdCBmb3IgUlRMLlxuICAvLyBQb3BwZXIgMSBpcyBicm9rZW4gaW4gdGhpcyBjYXNlIGFuZCBuZXZlciBoYWQgYSBidWcgcmVwb3J0IHNvIGxldCdzIGFzc3VtZVxuICAvLyBpdCdzIG5vdCBhbiBpc3N1ZS4gSSBkb24ndCB0aGluayBhbnlvbmUgZXZlciBzcGVjaWZpZXMgd2lkdGggb24gPGh0bWw+XG4gIC8vIGFueXdheS5cbiAgLy8gQnJvd3NlcnMgd2hlcmUgdGhlIGxlZnQgc2Nyb2xsYmFyIGRvZXNuJ3QgY2F1c2UgYW4gaXNzdWUgcmVwb3J0IGAwYCBmb3JcbiAgLy8gdGhpcyAoZS5nLiBFZGdlIDIwMTksIElFMTEsIFNhZmFyaSlcbiAgcmV0dXJuIGdldEJvdW5kaW5nQ2xpZW50UmVjdChnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCkpLmxlZnQgKyBnZXRXaW5kb3dTY3JvbGwoZWxlbWVudCkuc2Nyb2xsTGVmdDtcbn0iLCJpbXBvcnQgZ2V0V2luZG93IGZyb20gXCIuL2dldFdpbmRvdy5qc1wiO1xuaW1wb3J0IGdldERvY3VtZW50RWxlbWVudCBmcm9tIFwiLi9nZXREb2N1bWVudEVsZW1lbnQuanNcIjtcbmltcG9ydCBnZXRXaW5kb3dTY3JvbGxCYXJYIGZyb20gXCIuL2dldFdpbmRvd1Njcm9sbEJhclguanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldFZpZXdwb3J0UmVjdChlbGVtZW50KSB7XG4gIHZhciB3aW4gPSBnZXRXaW5kb3coZWxlbWVudCk7XG4gIHZhciBodG1sID0gZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpO1xuICB2YXIgdmlzdWFsVmlld3BvcnQgPSB3aW4udmlzdWFsVmlld3BvcnQ7XG4gIHZhciB3aWR0aCA9IGh0bWwuY2xpZW50V2lkdGg7XG4gIHZhciBoZWlnaHQgPSBodG1sLmNsaWVudEhlaWdodDtcbiAgdmFyIHggPSAwO1xuICB2YXIgeSA9IDA7IC8vIE5COiBUaGlzIGlzbid0IHN1cHBvcnRlZCBvbiBpT1MgPD0gMTIuIElmIHRoZSBrZXlib2FyZCBpcyBvcGVuLCB0aGUgcG9wcGVyXG4gIC8vIGNhbiBiZSBvYnNjdXJlZCB1bmRlcm5lYXRoIGl0LlxuICAvLyBBbHNvLCBgaHRtbC5jbGllbnRIZWlnaHRgIGFkZHMgdGhlIGJvdHRvbSBiYXIgaGVpZ2h0IGluIFNhZmFyaSBpT1MsIGV2ZW5cbiAgLy8gaWYgaXQgaXNuJ3Qgb3Blbiwgc28gaWYgdGhpcyBpc24ndCBhdmFpbGFibGUsIHRoZSBwb3BwZXIgd2lsbCBiZSBkZXRlY3RlZFxuICAvLyB0byBvdmVyZmxvdyB0aGUgYm90dG9tIG9mIHRoZSBzY3JlZW4gdG9vIGVhcmx5LlxuXG4gIGlmICh2aXN1YWxWaWV3cG9ydCkge1xuICAgIHdpZHRoID0gdmlzdWFsVmlld3BvcnQud2lkdGg7XG4gICAgaGVpZ2h0ID0gdmlzdWFsVmlld3BvcnQuaGVpZ2h0OyAvLyBVc2VzIExheW91dCBWaWV3cG9ydCAobGlrZSBDaHJvbWU7IFNhZmFyaSBkb2VzIG5vdCBjdXJyZW50bHkpXG4gICAgLy8gSW4gQ2hyb21lLCBpdCByZXR1cm5zIGEgdmFsdWUgdmVyeSBjbG9zZSB0byAwICgrLy0pIGJ1dCBjb250YWlucyByb3VuZGluZ1xuICAgIC8vIGVycm9ycyBkdWUgdG8gZmxvYXRpbmcgcG9pbnQgbnVtYmVycywgc28gd2UgbmVlZCB0byBjaGVjayBwcmVjaXNpb24uXG4gICAgLy8gU2FmYXJpIHJldHVybnMgYSBudW1iZXIgPD0gMCwgdXN1YWxseSA8IC0xIHdoZW4gcGluY2gtem9vbWVkXG4gICAgLy8gRmVhdHVyZSBkZXRlY3Rpb24gZmFpbHMgaW4gbW9iaWxlIGVtdWxhdGlvbiBtb2RlIGluIENocm9tZS5cbiAgICAvLyBNYXRoLmFicyh3aW4uaW5uZXJXaWR0aCAvIHZpc3VhbFZpZXdwb3J0LnNjYWxlIC0gdmlzdWFsVmlld3BvcnQud2lkdGgpIDxcbiAgICAvLyAwLjAwMVxuICAgIC8vIEZhbGxiYWNrIGhlcmU6IFwiTm90IFNhZmFyaVwiIHVzZXJBZ2VudFxuXG4gICAgaWYgKCEvXigoPyFjaHJvbWV8YW5kcm9pZCkuKSpzYWZhcmkvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpKSB7XG4gICAgICB4ID0gdmlzdWFsVmlld3BvcnQub2Zmc2V0TGVmdDtcbiAgICAgIHkgPSB2aXN1YWxWaWV3cG9ydC5vZmZzZXRUb3A7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogd2lkdGgsXG4gICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgeDogeCArIGdldFdpbmRvd1Njcm9sbEJhclgoZWxlbWVudCksXG4gICAgeTogeVxuICB9O1xufSIsImltcG9ydCBnZXREb2N1bWVudEVsZW1lbnQgZnJvbSBcIi4vZ2V0RG9jdW1lbnRFbGVtZW50LmpzXCI7XG5pbXBvcnQgZ2V0Q29tcHV0ZWRTdHlsZSBmcm9tIFwiLi9nZXRDb21wdXRlZFN0eWxlLmpzXCI7XG5pbXBvcnQgZ2V0V2luZG93U2Nyb2xsQmFyWCBmcm9tIFwiLi9nZXRXaW5kb3dTY3JvbGxCYXJYLmpzXCI7XG5pbXBvcnQgZ2V0V2luZG93U2Nyb2xsIGZyb20gXCIuL2dldFdpbmRvd1Njcm9sbC5qc1wiO1xuaW1wb3J0IHsgbWF4IH0gZnJvbSBcIi4uL3V0aWxzL21hdGguanNcIjsgLy8gR2V0cyB0aGUgZW50aXJlIHNpemUgb2YgdGhlIHNjcm9sbGFibGUgZG9jdW1lbnQgYXJlYSwgZXZlbiBleHRlbmRpbmcgb3V0c2lkZVxuLy8gb2YgdGhlIGA8aHRtbD5gIGFuZCBgPGJvZHk+YCByZWN0IGJvdW5kcyBpZiBob3Jpem9udGFsbHkgc2Nyb2xsYWJsZVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXREb2N1bWVudFJlY3QoZWxlbWVudCkge1xuICB2YXIgX2VsZW1lbnQkb3duZXJEb2N1bWVuO1xuXG4gIHZhciBodG1sID0gZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpO1xuICB2YXIgd2luU2Nyb2xsID0gZ2V0V2luZG93U2Nyb2xsKGVsZW1lbnQpO1xuICB2YXIgYm9keSA9IChfZWxlbWVudCRvd25lckRvY3VtZW4gPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfZWxlbWVudCRvd25lckRvY3VtZW4uYm9keTtcbiAgdmFyIHdpZHRoID0gbWF4KGh0bWwuc2Nyb2xsV2lkdGgsIGh0bWwuY2xpZW50V2lkdGgsIGJvZHkgPyBib2R5LnNjcm9sbFdpZHRoIDogMCwgYm9keSA/IGJvZHkuY2xpZW50V2lkdGggOiAwKTtcbiAgdmFyIGhlaWdodCA9IG1heChodG1sLnNjcm9sbEhlaWdodCwgaHRtbC5jbGllbnRIZWlnaHQsIGJvZHkgPyBib2R5LnNjcm9sbEhlaWdodCA6IDAsIGJvZHkgPyBib2R5LmNsaWVudEhlaWdodCA6IDApO1xuICB2YXIgeCA9IC13aW5TY3JvbGwuc2Nyb2xsTGVmdCArIGdldFdpbmRvd1Njcm9sbEJhclgoZWxlbWVudCk7XG4gIHZhciB5ID0gLXdpblNjcm9sbC5zY3JvbGxUb3A7XG5cbiAgaWYgKGdldENvbXB1dGVkU3R5bGUoYm9keSB8fCBodG1sKS5kaXJlY3Rpb24gPT09ICdydGwnKSB7XG4gICAgeCArPSBtYXgoaHRtbC5jbGllbnRXaWR0aCwgYm9keSA/IGJvZHkuY2xpZW50V2lkdGggOiAwKSAtIHdpZHRoO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogd2lkdGgsXG4gICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgeDogeCxcbiAgICB5OiB5XG4gIH07XG59IiwiaW1wb3J0IGdldENvbXB1dGVkU3R5bGUgZnJvbSBcIi4vZ2V0Q29tcHV0ZWRTdHlsZS5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaXNTY3JvbGxQYXJlbnQoZWxlbWVudCkge1xuICAvLyBGaXJlZm94IHdhbnRzIHVzIHRvIGNoZWNrIGAteGAgYW5kIGAteWAgdmFyaWF0aW9ucyBhcyB3ZWxsXG4gIHZhciBfZ2V0Q29tcHV0ZWRTdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCksXG4gICAgICBvdmVyZmxvdyA9IF9nZXRDb21wdXRlZFN0eWxlLm92ZXJmbG93LFxuICAgICAgb3ZlcmZsb3dYID0gX2dldENvbXB1dGVkU3R5bGUub3ZlcmZsb3dYLFxuICAgICAgb3ZlcmZsb3dZID0gX2dldENvbXB1dGVkU3R5bGUub3ZlcmZsb3dZO1xuXG4gIHJldHVybiAvYXV0b3xzY3JvbGx8b3ZlcmxheXxoaWRkZW4vLnRlc3Qob3ZlcmZsb3cgKyBvdmVyZmxvd1kgKyBvdmVyZmxvd1gpO1xufSIsImltcG9ydCBnZXRQYXJlbnROb2RlIGZyb20gXCIuL2dldFBhcmVudE5vZGUuanNcIjtcbmltcG9ydCBpc1Njcm9sbFBhcmVudCBmcm9tIFwiLi9pc1Njcm9sbFBhcmVudC5qc1wiO1xuaW1wb3J0IGdldE5vZGVOYW1lIGZyb20gXCIuL2dldE5vZGVOYW1lLmpzXCI7XG5pbXBvcnQgeyBpc0hUTUxFbGVtZW50IH0gZnJvbSBcIi4vaW5zdGFuY2VPZi5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0U2Nyb2xsUGFyZW50KG5vZGUpIHtcbiAgaWYgKFsnaHRtbCcsICdib2R5JywgJyNkb2N1bWVudCddLmluZGV4T2YoZ2V0Tm9kZU5hbWUobm9kZSkpID49IDApIHtcbiAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dOiBhc3N1bWUgYm9keSBpcyBhbHdheXMgYXZhaWxhYmxlXG4gICAgcmV0dXJuIG5vZGUub3duZXJEb2N1bWVudC5ib2R5O1xuICB9XG5cbiAgaWYgKGlzSFRNTEVsZW1lbnQobm9kZSkgJiYgaXNTY3JvbGxQYXJlbnQobm9kZSkpIHtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIHJldHVybiBnZXRTY3JvbGxQYXJlbnQoZ2V0UGFyZW50Tm9kZShub2RlKSk7XG59IiwiaW1wb3J0IGdldFNjcm9sbFBhcmVudCBmcm9tIFwiLi9nZXRTY3JvbGxQYXJlbnQuanNcIjtcbmltcG9ydCBnZXRQYXJlbnROb2RlIGZyb20gXCIuL2dldFBhcmVudE5vZGUuanNcIjtcbmltcG9ydCBnZXRXaW5kb3cgZnJvbSBcIi4vZ2V0V2luZG93LmpzXCI7XG5pbXBvcnQgaXNTY3JvbGxQYXJlbnQgZnJvbSBcIi4vaXNTY3JvbGxQYXJlbnQuanNcIjtcbi8qXG5naXZlbiBhIERPTSBlbGVtZW50LCByZXR1cm4gdGhlIGxpc3Qgb2YgYWxsIHNjcm9sbCBwYXJlbnRzLCB1cCB0aGUgbGlzdCBvZiBhbmNlc29yc1xudW50aWwgd2UgZ2V0IHRvIHRoZSB0b3Agd2luZG93IG9iamVjdC4gVGhpcyBsaXN0IGlzIHdoYXQgd2UgYXR0YWNoIHNjcm9sbCBsaXN0ZW5lcnNcbnRvLCBiZWNhdXNlIGlmIGFueSBvZiB0aGVzZSBwYXJlbnQgZWxlbWVudHMgc2Nyb2xsLCB3ZSdsbCBuZWVkIHRvIHJlLWNhbGN1bGF0ZSB0aGVcbnJlZmVyZW5jZSBlbGVtZW50J3MgcG9zaXRpb24uXG4qL1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBsaXN0U2Nyb2xsUGFyZW50cyhlbGVtZW50LCBsaXN0KSB7XG4gIHZhciBfZWxlbWVudCRvd25lckRvY3VtZW47XG5cbiAgaWYgKGxpc3QgPT09IHZvaWQgMCkge1xuICAgIGxpc3QgPSBbXTtcbiAgfVxuXG4gIHZhciBzY3JvbGxQYXJlbnQgPSBnZXRTY3JvbGxQYXJlbnQoZWxlbWVudCk7XG4gIHZhciBpc0JvZHkgPSBzY3JvbGxQYXJlbnQgPT09ICgoX2VsZW1lbnQkb3duZXJEb2N1bWVuID0gZWxlbWVudC5vd25lckRvY3VtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2VsZW1lbnQkb3duZXJEb2N1bWVuLmJvZHkpO1xuICB2YXIgd2luID0gZ2V0V2luZG93KHNjcm9sbFBhcmVudCk7XG4gIHZhciB0YXJnZXQgPSBpc0JvZHkgPyBbd2luXS5jb25jYXQod2luLnZpc3VhbFZpZXdwb3J0IHx8IFtdLCBpc1Njcm9sbFBhcmVudChzY3JvbGxQYXJlbnQpID8gc2Nyb2xsUGFyZW50IDogW10pIDogc2Nyb2xsUGFyZW50O1xuICB2YXIgdXBkYXRlZExpc3QgPSBsaXN0LmNvbmNhdCh0YXJnZXQpO1xuICByZXR1cm4gaXNCb2R5ID8gdXBkYXRlZExpc3QgOiAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1jYWxsXTogaXNCb2R5IHRlbGxzIHVzIHRhcmdldCB3aWxsIGJlIGFuIEhUTUxFbGVtZW50IGhlcmVcbiAgdXBkYXRlZExpc3QuY29uY2F0KGxpc3RTY3JvbGxQYXJlbnRzKGdldFBhcmVudE5vZGUodGFyZ2V0KSkpO1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHJlY3RUb0NsaWVudFJlY3QocmVjdCkge1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgcmVjdCwge1xuICAgIGxlZnQ6IHJlY3QueCxcbiAgICB0b3A6IHJlY3QueSxcbiAgICByaWdodDogcmVjdC54ICsgcmVjdC53aWR0aCxcbiAgICBib3R0b206IHJlY3QueSArIHJlY3QuaGVpZ2h0XG4gIH0pO1xufSIsImltcG9ydCB7IHZpZXdwb3J0IH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7XG5pbXBvcnQgZ2V0Vmlld3BvcnRSZWN0IGZyb20gXCIuL2dldFZpZXdwb3J0UmVjdC5qc1wiO1xuaW1wb3J0IGdldERvY3VtZW50UmVjdCBmcm9tIFwiLi9nZXREb2N1bWVudFJlY3QuanNcIjtcbmltcG9ydCBsaXN0U2Nyb2xsUGFyZW50cyBmcm9tIFwiLi9saXN0U2Nyb2xsUGFyZW50cy5qc1wiO1xuaW1wb3J0IGdldE9mZnNldFBhcmVudCBmcm9tIFwiLi9nZXRPZmZzZXRQYXJlbnQuanNcIjtcbmltcG9ydCBnZXREb2N1bWVudEVsZW1lbnQgZnJvbSBcIi4vZ2V0RG9jdW1lbnRFbGVtZW50LmpzXCI7XG5pbXBvcnQgZ2V0Q29tcHV0ZWRTdHlsZSBmcm9tIFwiLi9nZXRDb21wdXRlZFN0eWxlLmpzXCI7XG5pbXBvcnQgeyBpc0VsZW1lbnQsIGlzSFRNTEVsZW1lbnQgfSBmcm9tIFwiLi9pbnN0YW5jZU9mLmpzXCI7XG5pbXBvcnQgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IGZyb20gXCIuL2dldEJvdW5kaW5nQ2xpZW50UmVjdC5qc1wiO1xuaW1wb3J0IGdldFBhcmVudE5vZGUgZnJvbSBcIi4vZ2V0UGFyZW50Tm9kZS5qc1wiO1xuaW1wb3J0IGNvbnRhaW5zIGZyb20gXCIuL2NvbnRhaW5zLmpzXCI7XG5pbXBvcnQgZ2V0Tm9kZU5hbWUgZnJvbSBcIi4vZ2V0Tm9kZU5hbWUuanNcIjtcbmltcG9ydCByZWN0VG9DbGllbnRSZWN0IGZyb20gXCIuLi91dGlscy9yZWN0VG9DbGllbnRSZWN0LmpzXCI7XG5pbXBvcnQgeyBtYXgsIG1pbiB9IGZyb20gXCIuLi91dGlscy9tYXRoLmpzXCI7XG5cbmZ1bmN0aW9uIGdldElubmVyQm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnQpIHtcbiAgdmFyIHJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudCk7XG4gIHJlY3QudG9wID0gcmVjdC50b3AgKyBlbGVtZW50LmNsaWVudFRvcDtcbiAgcmVjdC5sZWZ0ID0gcmVjdC5sZWZ0ICsgZWxlbWVudC5jbGllbnRMZWZ0O1xuICByZWN0LmJvdHRvbSA9IHJlY3QudG9wICsgZWxlbWVudC5jbGllbnRIZWlnaHQ7XG4gIHJlY3QucmlnaHQgPSByZWN0LmxlZnQgKyBlbGVtZW50LmNsaWVudFdpZHRoO1xuICByZWN0LndpZHRoID0gZWxlbWVudC5jbGllbnRXaWR0aDtcbiAgcmVjdC5oZWlnaHQgPSBlbGVtZW50LmNsaWVudEhlaWdodDtcbiAgcmVjdC54ID0gcmVjdC5sZWZ0O1xuICByZWN0LnkgPSByZWN0LnRvcDtcbiAgcmV0dXJuIHJlY3Q7XG59XG5cbmZ1bmN0aW9uIGdldENsaWVudFJlY3RGcm9tTWl4ZWRUeXBlKGVsZW1lbnQsIGNsaXBwaW5nUGFyZW50KSB7XG4gIHJldHVybiBjbGlwcGluZ1BhcmVudCA9PT0gdmlld3BvcnQgPyByZWN0VG9DbGllbnRSZWN0KGdldFZpZXdwb3J0UmVjdChlbGVtZW50KSkgOiBpc0hUTUxFbGVtZW50KGNsaXBwaW5nUGFyZW50KSA/IGdldElubmVyQm91bmRpbmdDbGllbnRSZWN0KGNsaXBwaW5nUGFyZW50KSA6IHJlY3RUb0NsaWVudFJlY3QoZ2V0RG9jdW1lbnRSZWN0KGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KSkpO1xufSAvLyBBIFwiY2xpcHBpbmcgcGFyZW50XCIgaXMgYW4gb3ZlcmZsb3dhYmxlIGNvbnRhaW5lciB3aXRoIHRoZSBjaGFyYWN0ZXJpc3RpYyBvZlxuLy8gY2xpcHBpbmcgKG9yIGhpZGluZykgb3ZlcmZsb3dpbmcgZWxlbWVudHMgd2l0aCBhIHBvc2l0aW9uIGRpZmZlcmVudCBmcm9tXG4vLyBgaW5pdGlhbGBcblxuXG5mdW5jdGlvbiBnZXRDbGlwcGluZ1BhcmVudHMoZWxlbWVudCkge1xuICB2YXIgY2xpcHBpbmdQYXJlbnRzID0gbGlzdFNjcm9sbFBhcmVudHMoZ2V0UGFyZW50Tm9kZShlbGVtZW50KSk7XG4gIHZhciBjYW5Fc2NhcGVDbGlwcGluZyA9IFsnYWJzb2x1dGUnLCAnZml4ZWQnXS5pbmRleE9mKGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkucG9zaXRpb24pID49IDA7XG4gIHZhciBjbGlwcGVyRWxlbWVudCA9IGNhbkVzY2FwZUNsaXBwaW5nICYmIGlzSFRNTEVsZW1lbnQoZWxlbWVudCkgPyBnZXRPZmZzZXRQYXJlbnQoZWxlbWVudCkgOiBlbGVtZW50O1xuXG4gIGlmICghaXNFbGVtZW50KGNsaXBwZXJFbGVtZW50KSkge1xuICAgIHJldHVybiBbXTtcbiAgfSAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dOiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svZmxvdy9pc3N1ZXMvMTQxNFxuXG5cbiAgcmV0dXJuIGNsaXBwaW5nUGFyZW50cy5maWx0ZXIoZnVuY3Rpb24gKGNsaXBwaW5nUGFyZW50KSB7XG4gICAgcmV0dXJuIGlzRWxlbWVudChjbGlwcGluZ1BhcmVudCkgJiYgY29udGFpbnMoY2xpcHBpbmdQYXJlbnQsIGNsaXBwZXJFbGVtZW50KSAmJiBnZXROb2RlTmFtZShjbGlwcGluZ1BhcmVudCkgIT09ICdib2R5JztcbiAgfSk7XG59IC8vIEdldHMgdGhlIG1heGltdW0gYXJlYSB0aGF0IHRoZSBlbGVtZW50IGlzIHZpc2libGUgaW4gZHVlIHRvIGFueSBudW1iZXIgb2Zcbi8vIGNsaXBwaW5nIHBhcmVudHNcblxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRDbGlwcGluZ1JlY3QoZWxlbWVudCwgYm91bmRhcnksIHJvb3RCb3VuZGFyeSkge1xuICB2YXIgbWFpbkNsaXBwaW5nUGFyZW50cyA9IGJvdW5kYXJ5ID09PSAnY2xpcHBpbmdQYXJlbnRzJyA/IGdldENsaXBwaW5nUGFyZW50cyhlbGVtZW50KSA6IFtdLmNvbmNhdChib3VuZGFyeSk7XG4gIHZhciBjbGlwcGluZ1BhcmVudHMgPSBbXS5jb25jYXQobWFpbkNsaXBwaW5nUGFyZW50cywgW3Jvb3RCb3VuZGFyeV0pO1xuICB2YXIgZmlyc3RDbGlwcGluZ1BhcmVudCA9IGNsaXBwaW5nUGFyZW50c1swXTtcbiAgdmFyIGNsaXBwaW5nUmVjdCA9IGNsaXBwaW5nUGFyZW50cy5yZWR1Y2UoZnVuY3Rpb24gKGFjY1JlY3QsIGNsaXBwaW5nUGFyZW50KSB7XG4gICAgdmFyIHJlY3QgPSBnZXRDbGllbnRSZWN0RnJvbU1peGVkVHlwZShlbGVtZW50LCBjbGlwcGluZ1BhcmVudCk7XG4gICAgYWNjUmVjdC50b3AgPSBtYXgocmVjdC50b3AsIGFjY1JlY3QudG9wKTtcbiAgICBhY2NSZWN0LnJpZ2h0ID0gbWluKHJlY3QucmlnaHQsIGFjY1JlY3QucmlnaHQpO1xuICAgIGFjY1JlY3QuYm90dG9tID0gbWluKHJlY3QuYm90dG9tLCBhY2NSZWN0LmJvdHRvbSk7XG4gICAgYWNjUmVjdC5sZWZ0ID0gbWF4KHJlY3QubGVmdCwgYWNjUmVjdC5sZWZ0KTtcbiAgICByZXR1cm4gYWNjUmVjdDtcbiAgfSwgZ2V0Q2xpZW50UmVjdEZyb21NaXhlZFR5cGUoZWxlbWVudCwgZmlyc3RDbGlwcGluZ1BhcmVudCkpO1xuICBjbGlwcGluZ1JlY3Qud2lkdGggPSBjbGlwcGluZ1JlY3QucmlnaHQgLSBjbGlwcGluZ1JlY3QubGVmdDtcbiAgY2xpcHBpbmdSZWN0LmhlaWdodCA9IGNsaXBwaW5nUmVjdC5ib3R0b20gLSBjbGlwcGluZ1JlY3QudG9wO1xuICBjbGlwcGluZ1JlY3QueCA9IGNsaXBwaW5nUmVjdC5sZWZ0O1xuICBjbGlwcGluZ1JlY3QueSA9IGNsaXBwaW5nUmVjdC50b3A7XG4gIHJldHVybiBjbGlwcGluZ1JlY3Q7XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0VmFyaWF0aW9uKHBsYWNlbWVudCkge1xuICByZXR1cm4gcGxhY2VtZW50LnNwbGl0KCctJylbMV07XG59IiwiaW1wb3J0IGdldEJhc2VQbGFjZW1lbnQgZnJvbSBcIi4vZ2V0QmFzZVBsYWNlbWVudC5qc1wiO1xuaW1wb3J0IGdldFZhcmlhdGlvbiBmcm9tIFwiLi9nZXRWYXJpYXRpb24uanNcIjtcbmltcG9ydCBnZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQgZnJvbSBcIi4vZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50LmpzXCI7XG5pbXBvcnQgeyB0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnQsIHN0YXJ0LCBlbmQgfSBmcm9tIFwiLi4vZW51bXMuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNvbXB1dGVPZmZzZXRzKF9yZWYpIHtcbiAgdmFyIHJlZmVyZW5jZSA9IF9yZWYucmVmZXJlbmNlLFxuICAgICAgZWxlbWVudCA9IF9yZWYuZWxlbWVudCxcbiAgICAgIHBsYWNlbWVudCA9IF9yZWYucGxhY2VtZW50O1xuICB2YXIgYmFzZVBsYWNlbWVudCA9IHBsYWNlbWVudCA/IGdldEJhc2VQbGFjZW1lbnQocGxhY2VtZW50KSA6IG51bGw7XG4gIHZhciB2YXJpYXRpb24gPSBwbGFjZW1lbnQgPyBnZXRWYXJpYXRpb24ocGxhY2VtZW50KSA6IG51bGw7XG4gIHZhciBjb21tb25YID0gcmVmZXJlbmNlLnggKyByZWZlcmVuY2Uud2lkdGggLyAyIC0gZWxlbWVudC53aWR0aCAvIDI7XG4gIHZhciBjb21tb25ZID0gcmVmZXJlbmNlLnkgKyByZWZlcmVuY2UuaGVpZ2h0IC8gMiAtIGVsZW1lbnQuaGVpZ2h0IC8gMjtcbiAgdmFyIG9mZnNldHM7XG5cbiAgc3dpdGNoIChiYXNlUGxhY2VtZW50KSB7XG4gICAgY2FzZSB0b3A6XG4gICAgICBvZmZzZXRzID0ge1xuICAgICAgICB4OiBjb21tb25YLFxuICAgICAgICB5OiByZWZlcmVuY2UueSAtIGVsZW1lbnQuaGVpZ2h0XG4gICAgICB9O1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIGJvdHRvbTpcbiAgICAgIG9mZnNldHMgPSB7XG4gICAgICAgIHg6IGNvbW1vblgsXG4gICAgICAgIHk6IHJlZmVyZW5jZS55ICsgcmVmZXJlbmNlLmhlaWdodFxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSByaWdodDpcbiAgICAgIG9mZnNldHMgPSB7XG4gICAgICAgIHg6IHJlZmVyZW5jZS54ICsgcmVmZXJlbmNlLndpZHRoLFxuICAgICAgICB5OiBjb21tb25ZXG4gICAgICB9O1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIGxlZnQ6XG4gICAgICBvZmZzZXRzID0ge1xuICAgICAgICB4OiByZWZlcmVuY2UueCAtIGVsZW1lbnQud2lkdGgsXG4gICAgICAgIHk6IGNvbW1vbllcbiAgICAgIH07XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICBvZmZzZXRzID0ge1xuICAgICAgICB4OiByZWZlcmVuY2UueCxcbiAgICAgICAgeTogcmVmZXJlbmNlLnlcbiAgICAgIH07XG4gIH1cblxuICB2YXIgbWFpbkF4aXMgPSBiYXNlUGxhY2VtZW50ID8gZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50KGJhc2VQbGFjZW1lbnQpIDogbnVsbDtcblxuICBpZiAobWFpbkF4aXMgIT0gbnVsbCkge1xuICAgIHZhciBsZW4gPSBtYWluQXhpcyA9PT0gJ3knID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xuXG4gICAgc3dpdGNoICh2YXJpYXRpb24pIHtcbiAgICAgIGNhc2Ugc3RhcnQ6XG4gICAgICAgIG9mZnNldHNbbWFpbkF4aXNdID0gb2Zmc2V0c1ttYWluQXhpc10gLSAocmVmZXJlbmNlW2xlbl0gLyAyIC0gZWxlbWVudFtsZW5dIC8gMik7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIGVuZDpcbiAgICAgICAgb2Zmc2V0c1ttYWluQXhpc10gPSBvZmZzZXRzW21haW5BeGlzXSArIChyZWZlcmVuY2VbbGVuXSAvIDIgLSBlbGVtZW50W2xlbl0gLyAyKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9mZnNldHM7XG59IiwiaW1wb3J0IGdldEJvdW5kaW5nQ2xpZW50UmVjdCBmcm9tIFwiLi4vZG9tLXV0aWxzL2dldEJvdW5kaW5nQ2xpZW50UmVjdC5qc1wiO1xuaW1wb3J0IGdldENsaXBwaW5nUmVjdCBmcm9tIFwiLi4vZG9tLXV0aWxzL2dldENsaXBwaW5nUmVjdC5qc1wiO1xuaW1wb3J0IGdldERvY3VtZW50RWxlbWVudCBmcm9tIFwiLi4vZG9tLXV0aWxzL2dldERvY3VtZW50RWxlbWVudC5qc1wiO1xuaW1wb3J0IGNvbXB1dGVPZmZzZXRzIGZyb20gXCIuL2NvbXB1dGVPZmZzZXRzLmpzXCI7XG5pbXBvcnQgcmVjdFRvQ2xpZW50UmVjdCBmcm9tIFwiLi9yZWN0VG9DbGllbnRSZWN0LmpzXCI7XG5pbXBvcnQgeyBjbGlwcGluZ1BhcmVudHMsIHJlZmVyZW5jZSwgcG9wcGVyLCBib3R0b20sIHRvcCwgcmlnaHQsIGJhc2VQbGFjZW1lbnRzLCB2aWV3cG9ydCB9IGZyb20gXCIuLi9lbnVtcy5qc1wiO1xuaW1wb3J0IHsgaXNFbGVtZW50IH0gZnJvbSBcIi4uL2RvbS11dGlscy9pbnN0YW5jZU9mLmpzXCI7XG5pbXBvcnQgbWVyZ2VQYWRkaW5nT2JqZWN0IGZyb20gXCIuL21lcmdlUGFkZGluZ09iamVjdC5qc1wiO1xuaW1wb3J0IGV4cGFuZFRvSGFzaE1hcCBmcm9tIFwiLi9leHBhbmRUb0hhc2hNYXAuanNcIjsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBkZXRlY3RPdmVyZmxvdyhzdGF0ZSwgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgdmFyIF9vcHRpb25zID0gb3B0aW9ucyxcbiAgICAgIF9vcHRpb25zJHBsYWNlbWVudCA9IF9vcHRpb25zLnBsYWNlbWVudCxcbiAgICAgIHBsYWNlbWVudCA9IF9vcHRpb25zJHBsYWNlbWVudCA9PT0gdm9pZCAwID8gc3RhdGUucGxhY2VtZW50IDogX29wdGlvbnMkcGxhY2VtZW50LFxuICAgICAgX29wdGlvbnMkYm91bmRhcnkgPSBfb3B0aW9ucy5ib3VuZGFyeSxcbiAgICAgIGJvdW5kYXJ5ID0gX29wdGlvbnMkYm91bmRhcnkgPT09IHZvaWQgMCA/IGNsaXBwaW5nUGFyZW50cyA6IF9vcHRpb25zJGJvdW5kYXJ5LFxuICAgICAgX29wdGlvbnMkcm9vdEJvdW5kYXJ5ID0gX29wdGlvbnMucm9vdEJvdW5kYXJ5LFxuICAgICAgcm9vdEJvdW5kYXJ5ID0gX29wdGlvbnMkcm9vdEJvdW5kYXJ5ID09PSB2b2lkIDAgPyB2aWV3cG9ydCA6IF9vcHRpb25zJHJvb3RCb3VuZGFyeSxcbiAgICAgIF9vcHRpb25zJGVsZW1lbnRDb250ZSA9IF9vcHRpb25zLmVsZW1lbnRDb250ZXh0LFxuICAgICAgZWxlbWVudENvbnRleHQgPSBfb3B0aW9ucyRlbGVtZW50Q29udGUgPT09IHZvaWQgMCA/IHBvcHBlciA6IF9vcHRpb25zJGVsZW1lbnRDb250ZSxcbiAgICAgIF9vcHRpb25zJGFsdEJvdW5kYXJ5ID0gX29wdGlvbnMuYWx0Qm91bmRhcnksXG4gICAgICBhbHRCb3VuZGFyeSA9IF9vcHRpb25zJGFsdEJvdW5kYXJ5ID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zJGFsdEJvdW5kYXJ5LFxuICAgICAgX29wdGlvbnMkcGFkZGluZyA9IF9vcHRpb25zLnBhZGRpbmcsXG4gICAgICBwYWRkaW5nID0gX29wdGlvbnMkcGFkZGluZyA9PT0gdm9pZCAwID8gMCA6IF9vcHRpb25zJHBhZGRpbmc7XG4gIHZhciBwYWRkaW5nT2JqZWN0ID0gbWVyZ2VQYWRkaW5nT2JqZWN0KHR5cGVvZiBwYWRkaW5nICE9PSAnbnVtYmVyJyA/IHBhZGRpbmcgOiBleHBhbmRUb0hhc2hNYXAocGFkZGluZywgYmFzZVBsYWNlbWVudHMpKTtcbiAgdmFyIGFsdENvbnRleHQgPSBlbGVtZW50Q29udGV4dCA9PT0gcG9wcGVyID8gcmVmZXJlbmNlIDogcG9wcGVyO1xuICB2YXIgcmVmZXJlbmNlRWxlbWVudCA9IHN0YXRlLmVsZW1lbnRzLnJlZmVyZW5jZTtcbiAgdmFyIHBvcHBlclJlY3QgPSBzdGF0ZS5yZWN0cy5wb3BwZXI7XG4gIHZhciBlbGVtZW50ID0gc3RhdGUuZWxlbWVudHNbYWx0Qm91bmRhcnkgPyBhbHRDb250ZXh0IDogZWxlbWVudENvbnRleHRdO1xuICB2YXIgY2xpcHBpbmdDbGllbnRSZWN0ID0gZ2V0Q2xpcHBpbmdSZWN0KGlzRWxlbWVudChlbGVtZW50KSA/IGVsZW1lbnQgOiBlbGVtZW50LmNvbnRleHRFbGVtZW50IHx8IGdldERvY3VtZW50RWxlbWVudChzdGF0ZS5lbGVtZW50cy5wb3BwZXIpLCBib3VuZGFyeSwgcm9vdEJvdW5kYXJ5KTtcbiAgdmFyIHJlZmVyZW5jZUNsaWVudFJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QocmVmZXJlbmNlRWxlbWVudCk7XG4gIHZhciBwb3BwZXJPZmZzZXRzID0gY29tcHV0ZU9mZnNldHMoe1xuICAgIHJlZmVyZW5jZTogcmVmZXJlbmNlQ2xpZW50UmVjdCxcbiAgICBlbGVtZW50OiBwb3BwZXJSZWN0LFxuICAgIHN0cmF0ZWd5OiAnYWJzb2x1dGUnLFxuICAgIHBsYWNlbWVudDogcGxhY2VtZW50XG4gIH0pO1xuICB2YXIgcG9wcGVyQ2xpZW50UmVjdCA9IHJlY3RUb0NsaWVudFJlY3QoT2JqZWN0LmFzc2lnbih7fSwgcG9wcGVyUmVjdCwgcG9wcGVyT2Zmc2V0cykpO1xuICB2YXIgZWxlbWVudENsaWVudFJlY3QgPSBlbGVtZW50Q29udGV4dCA9PT0gcG9wcGVyID8gcG9wcGVyQ2xpZW50UmVjdCA6IHJlZmVyZW5jZUNsaWVudFJlY3Q7IC8vIHBvc2l0aXZlID0gb3ZlcmZsb3dpbmcgdGhlIGNsaXBwaW5nIHJlY3RcbiAgLy8gMCBvciBuZWdhdGl2ZSA9IHdpdGhpbiB0aGUgY2xpcHBpbmcgcmVjdFxuXG4gIHZhciBvdmVyZmxvd09mZnNldHMgPSB7XG4gICAgdG9wOiBjbGlwcGluZ0NsaWVudFJlY3QudG9wIC0gZWxlbWVudENsaWVudFJlY3QudG9wICsgcGFkZGluZ09iamVjdC50b3AsXG4gICAgYm90dG9tOiBlbGVtZW50Q2xpZW50UmVjdC5ib3R0b20gLSBjbGlwcGluZ0NsaWVudFJlY3QuYm90dG9tICsgcGFkZGluZ09iamVjdC5ib3R0b20sXG4gICAgbGVmdDogY2xpcHBpbmdDbGllbnRSZWN0LmxlZnQgLSBlbGVtZW50Q2xpZW50UmVjdC5sZWZ0ICsgcGFkZGluZ09iamVjdC5sZWZ0LFxuICAgIHJpZ2h0OiBlbGVtZW50Q2xpZW50UmVjdC5yaWdodCAtIGNsaXBwaW5nQ2xpZW50UmVjdC5yaWdodCArIHBhZGRpbmdPYmplY3QucmlnaHRcbiAgfTtcbiAgdmFyIG9mZnNldERhdGEgPSBzdGF0ZS5tb2RpZmllcnNEYXRhLm9mZnNldDsgLy8gT2Zmc2V0cyBjYW4gYmUgYXBwbGllZCBvbmx5IHRvIHRoZSBwb3BwZXIgZWxlbWVudFxuXG4gIGlmIChlbGVtZW50Q29udGV4dCA9PT0gcG9wcGVyICYmIG9mZnNldERhdGEpIHtcbiAgICB2YXIgb2Zmc2V0ID0gb2Zmc2V0RGF0YVtwbGFjZW1lbnRdO1xuICAgIE9iamVjdC5rZXlzKG92ZXJmbG93T2Zmc2V0cykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICB2YXIgbXVsdGlwbHkgPSBbcmlnaHQsIGJvdHRvbV0uaW5kZXhPZihrZXkpID49IDAgPyAxIDogLTE7XG4gICAgICB2YXIgYXhpcyA9IFt0b3AsIGJvdHRvbV0uaW5kZXhPZihrZXkpID49IDAgPyAneScgOiAneCc7XG4gICAgICBvdmVyZmxvd09mZnNldHNba2V5XSArPSBvZmZzZXRbYXhpc10gKiBtdWx0aXBseTtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBvdmVyZmxvd09mZnNldHM7XG59IiwiaW1wb3J0IGdldFZhcmlhdGlvbiBmcm9tIFwiLi9nZXRWYXJpYXRpb24uanNcIjtcbmltcG9ydCB7IHZhcmlhdGlvblBsYWNlbWVudHMsIGJhc2VQbGFjZW1lbnRzLCBwbGFjZW1lbnRzIGFzIGFsbFBsYWNlbWVudHMgfSBmcm9tIFwiLi4vZW51bXMuanNcIjtcbmltcG9ydCBkZXRlY3RPdmVyZmxvdyBmcm9tIFwiLi9kZXRlY3RPdmVyZmxvdy5qc1wiO1xuaW1wb3J0IGdldEJhc2VQbGFjZW1lbnQgZnJvbSBcIi4vZ2V0QmFzZVBsYWNlbWVudC5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY29tcHV0ZUF1dG9QbGFjZW1lbnQoc3RhdGUsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIHZhciBfb3B0aW9ucyA9IG9wdGlvbnMsXG4gICAgICBwbGFjZW1lbnQgPSBfb3B0aW9ucy5wbGFjZW1lbnQsXG4gICAgICBib3VuZGFyeSA9IF9vcHRpb25zLmJvdW5kYXJ5LFxuICAgICAgcm9vdEJvdW5kYXJ5ID0gX29wdGlvbnMucm9vdEJvdW5kYXJ5LFxuICAgICAgcGFkZGluZyA9IF9vcHRpb25zLnBhZGRpbmcsXG4gICAgICBmbGlwVmFyaWF0aW9ucyA9IF9vcHRpb25zLmZsaXBWYXJpYXRpb25zLFxuICAgICAgX29wdGlvbnMkYWxsb3dlZEF1dG9QID0gX29wdGlvbnMuYWxsb3dlZEF1dG9QbGFjZW1lbnRzLFxuICAgICAgYWxsb3dlZEF1dG9QbGFjZW1lbnRzID0gX29wdGlvbnMkYWxsb3dlZEF1dG9QID09PSB2b2lkIDAgPyBhbGxQbGFjZW1lbnRzIDogX29wdGlvbnMkYWxsb3dlZEF1dG9QO1xuICB2YXIgdmFyaWF0aW9uID0gZ2V0VmFyaWF0aW9uKHBsYWNlbWVudCk7XG4gIHZhciBwbGFjZW1lbnRzID0gdmFyaWF0aW9uID8gZmxpcFZhcmlhdGlvbnMgPyB2YXJpYXRpb25QbGFjZW1lbnRzIDogdmFyaWF0aW9uUGxhY2VtZW50cy5maWx0ZXIoZnVuY3Rpb24gKHBsYWNlbWVudCkge1xuICAgIHJldHVybiBnZXRWYXJpYXRpb24ocGxhY2VtZW50KSA9PT0gdmFyaWF0aW9uO1xuICB9KSA6IGJhc2VQbGFjZW1lbnRzO1xuICB2YXIgYWxsb3dlZFBsYWNlbWVudHMgPSBwbGFjZW1lbnRzLmZpbHRlcihmdW5jdGlvbiAocGxhY2VtZW50KSB7XG4gICAgcmV0dXJuIGFsbG93ZWRBdXRvUGxhY2VtZW50cy5pbmRleE9mKHBsYWNlbWVudCkgPj0gMDtcbiAgfSk7XG5cbiAgaWYgKGFsbG93ZWRQbGFjZW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIGFsbG93ZWRQbGFjZW1lbnRzID0gcGxhY2VtZW50cztcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoWydQb3BwZXI6IFRoZSBgYWxsb3dlZEF1dG9QbGFjZW1lbnRzYCBvcHRpb24gZGlkIG5vdCBhbGxvdyBhbnknLCAncGxhY2VtZW50cy4gRW5zdXJlIHRoZSBgcGxhY2VtZW50YCBvcHRpb24gbWF0Y2hlcyB0aGUgdmFyaWF0aW9uJywgJ29mIHRoZSBhbGxvd2VkIHBsYWNlbWVudHMuJywgJ0ZvciBleGFtcGxlLCBcImF1dG9cIiBjYW5ub3QgYmUgdXNlZCB0byBhbGxvdyBcImJvdHRvbS1zdGFydFwiLicsICdVc2UgXCJhdXRvLXN0YXJ0XCIgaW5zdGVhZC4nXS5qb2luKCcgJykpO1xuICAgIH1cbiAgfSAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS10eXBlXTogRmxvdyBzZWVtcyB0byBoYXZlIHByb2JsZW1zIHdpdGggdHdvIGFycmF5IHVuaW9ucy4uLlxuXG5cbiAgdmFyIG92ZXJmbG93cyA9IGFsbG93ZWRQbGFjZW1lbnRzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBwbGFjZW1lbnQpIHtcbiAgICBhY2NbcGxhY2VtZW50XSA9IGRldGVjdE92ZXJmbG93KHN0YXRlLCB7XG4gICAgICBwbGFjZW1lbnQ6IHBsYWNlbWVudCxcbiAgICAgIGJvdW5kYXJ5OiBib3VuZGFyeSxcbiAgICAgIHJvb3RCb3VuZGFyeTogcm9vdEJvdW5kYXJ5LFxuICAgICAgcGFkZGluZzogcGFkZGluZ1xuICAgIH0pW2dldEJhc2VQbGFjZW1lbnQocGxhY2VtZW50KV07XG4gICAgcmV0dXJuIGFjYztcbiAgfSwge30pO1xuICByZXR1cm4gT2JqZWN0LmtleXMob3ZlcmZsb3dzKS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIG92ZXJmbG93c1thXSAtIG92ZXJmbG93c1tiXTtcbiAgfSk7XG59IiwiaW1wb3J0IGdldE9wcG9zaXRlUGxhY2VtZW50IGZyb20gXCIuLi91dGlscy9nZXRPcHBvc2l0ZVBsYWNlbWVudC5qc1wiO1xuaW1wb3J0IGdldEJhc2VQbGFjZW1lbnQgZnJvbSBcIi4uL3V0aWxzL2dldEJhc2VQbGFjZW1lbnQuanNcIjtcbmltcG9ydCBnZXRPcHBvc2l0ZVZhcmlhdGlvblBsYWNlbWVudCBmcm9tIFwiLi4vdXRpbHMvZ2V0T3Bwb3NpdGVWYXJpYXRpb25QbGFjZW1lbnQuanNcIjtcbmltcG9ydCBkZXRlY3RPdmVyZmxvdyBmcm9tIFwiLi4vdXRpbHMvZGV0ZWN0T3ZlcmZsb3cuanNcIjtcbmltcG9ydCBjb21wdXRlQXV0b1BsYWNlbWVudCBmcm9tIFwiLi4vdXRpbHMvY29tcHV0ZUF1dG9QbGFjZW1lbnQuanNcIjtcbmltcG9ydCB7IGJvdHRvbSwgdG9wLCBzdGFydCwgcmlnaHQsIGxlZnQsIGF1dG8gfSBmcm9tIFwiLi4vZW51bXMuanNcIjtcbmltcG9ydCBnZXRWYXJpYXRpb24gZnJvbSBcIi4uL3V0aWxzL2dldFZhcmlhdGlvbi5qc1wiOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cbmZ1bmN0aW9uIGdldEV4cGFuZGVkRmFsbGJhY2tQbGFjZW1lbnRzKHBsYWNlbWVudCkge1xuICBpZiAoZ2V0QmFzZVBsYWNlbWVudChwbGFjZW1lbnQpID09PSBhdXRvKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgdmFyIG9wcG9zaXRlUGxhY2VtZW50ID0gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQocGxhY2VtZW50KTtcbiAgcmV0dXJuIFtnZXRPcHBvc2l0ZVZhcmlhdGlvblBsYWNlbWVudChwbGFjZW1lbnQpLCBvcHBvc2l0ZVBsYWNlbWVudCwgZ2V0T3Bwb3NpdGVWYXJpYXRpb25QbGFjZW1lbnQob3Bwb3NpdGVQbGFjZW1lbnQpXTtcbn1cblxuZnVuY3Rpb24gZmxpcChfcmVmKSB7XG4gIHZhciBzdGF0ZSA9IF9yZWYuc3RhdGUsXG4gICAgICBvcHRpb25zID0gX3JlZi5vcHRpb25zLFxuICAgICAgbmFtZSA9IF9yZWYubmFtZTtcblxuICBpZiAoc3RhdGUubW9kaWZpZXJzRGF0YVtuYW1lXS5fc2tpcCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBfb3B0aW9ucyRtYWluQXhpcyA9IG9wdGlvbnMubWFpbkF4aXMsXG4gICAgICBjaGVja01haW5BeGlzID0gX29wdGlvbnMkbWFpbkF4aXMgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRtYWluQXhpcyxcbiAgICAgIF9vcHRpb25zJGFsdEF4aXMgPSBvcHRpb25zLmFsdEF4aXMsXG4gICAgICBjaGVja0FsdEF4aXMgPSBfb3B0aW9ucyRhbHRBeGlzID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkYWx0QXhpcyxcbiAgICAgIHNwZWNpZmllZEZhbGxiYWNrUGxhY2VtZW50cyA9IG9wdGlvbnMuZmFsbGJhY2tQbGFjZW1lbnRzLFxuICAgICAgcGFkZGluZyA9IG9wdGlvbnMucGFkZGluZyxcbiAgICAgIGJvdW5kYXJ5ID0gb3B0aW9ucy5ib3VuZGFyeSxcbiAgICAgIHJvb3RCb3VuZGFyeSA9IG9wdGlvbnMucm9vdEJvdW5kYXJ5LFxuICAgICAgYWx0Qm91bmRhcnkgPSBvcHRpb25zLmFsdEJvdW5kYXJ5LFxuICAgICAgX29wdGlvbnMkZmxpcFZhcmlhdGlvID0gb3B0aW9ucy5mbGlwVmFyaWF0aW9ucyxcbiAgICAgIGZsaXBWYXJpYXRpb25zID0gX29wdGlvbnMkZmxpcFZhcmlhdGlvID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkZmxpcFZhcmlhdGlvLFxuICAgICAgYWxsb3dlZEF1dG9QbGFjZW1lbnRzID0gb3B0aW9ucy5hbGxvd2VkQXV0b1BsYWNlbWVudHM7XG4gIHZhciBwcmVmZXJyZWRQbGFjZW1lbnQgPSBzdGF0ZS5vcHRpb25zLnBsYWNlbWVudDtcbiAgdmFyIGJhc2VQbGFjZW1lbnQgPSBnZXRCYXNlUGxhY2VtZW50KHByZWZlcnJlZFBsYWNlbWVudCk7XG4gIHZhciBpc0Jhc2VQbGFjZW1lbnQgPSBiYXNlUGxhY2VtZW50ID09PSBwcmVmZXJyZWRQbGFjZW1lbnQ7XG4gIHZhciBmYWxsYmFja1BsYWNlbWVudHMgPSBzcGVjaWZpZWRGYWxsYmFja1BsYWNlbWVudHMgfHwgKGlzQmFzZVBsYWNlbWVudCB8fCAhZmxpcFZhcmlhdGlvbnMgPyBbZ2V0T3Bwb3NpdGVQbGFjZW1lbnQocHJlZmVycmVkUGxhY2VtZW50KV0gOiBnZXRFeHBhbmRlZEZhbGxiYWNrUGxhY2VtZW50cyhwcmVmZXJyZWRQbGFjZW1lbnQpKTtcbiAgdmFyIHBsYWNlbWVudHMgPSBbcHJlZmVycmVkUGxhY2VtZW50XS5jb25jYXQoZmFsbGJhY2tQbGFjZW1lbnRzKS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgcGxhY2VtZW50KSB7XG4gICAgcmV0dXJuIGFjYy5jb25jYXQoZ2V0QmFzZVBsYWNlbWVudChwbGFjZW1lbnQpID09PSBhdXRvID8gY29tcHV0ZUF1dG9QbGFjZW1lbnQoc3RhdGUsIHtcbiAgICAgIHBsYWNlbWVudDogcGxhY2VtZW50LFxuICAgICAgYm91bmRhcnk6IGJvdW5kYXJ5LFxuICAgICAgcm9vdEJvdW5kYXJ5OiByb290Qm91bmRhcnksXG4gICAgICBwYWRkaW5nOiBwYWRkaW5nLFxuICAgICAgZmxpcFZhcmlhdGlvbnM6IGZsaXBWYXJpYXRpb25zLFxuICAgICAgYWxsb3dlZEF1dG9QbGFjZW1lbnRzOiBhbGxvd2VkQXV0b1BsYWNlbWVudHNcbiAgICB9KSA6IHBsYWNlbWVudCk7XG4gIH0sIFtdKTtcbiAgdmFyIHJlZmVyZW5jZVJlY3QgPSBzdGF0ZS5yZWN0cy5yZWZlcmVuY2U7XG4gIHZhciBwb3BwZXJSZWN0ID0gc3RhdGUucmVjdHMucG9wcGVyO1xuICB2YXIgY2hlY2tzTWFwID0gbmV3IE1hcCgpO1xuICB2YXIgbWFrZUZhbGxiYWNrQ2hlY2tzID0gdHJ1ZTtcbiAgdmFyIGZpcnN0Rml0dGluZ1BsYWNlbWVudCA9IHBsYWNlbWVudHNbMF07XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwbGFjZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHBsYWNlbWVudCA9IHBsYWNlbWVudHNbaV07XG5cbiAgICB2YXIgX2Jhc2VQbGFjZW1lbnQgPSBnZXRCYXNlUGxhY2VtZW50KHBsYWNlbWVudCk7XG5cbiAgICB2YXIgaXNTdGFydFZhcmlhdGlvbiA9IGdldFZhcmlhdGlvbihwbGFjZW1lbnQpID09PSBzdGFydDtcbiAgICB2YXIgaXNWZXJ0aWNhbCA9IFt0b3AsIGJvdHRvbV0uaW5kZXhPZihfYmFzZVBsYWNlbWVudCkgPj0gMDtcbiAgICB2YXIgbGVuID0gaXNWZXJ0aWNhbCA/ICd3aWR0aCcgOiAnaGVpZ2h0JztcbiAgICB2YXIgb3ZlcmZsb3cgPSBkZXRlY3RPdmVyZmxvdyhzdGF0ZSwge1xuICAgICAgcGxhY2VtZW50OiBwbGFjZW1lbnQsXG4gICAgICBib3VuZGFyeTogYm91bmRhcnksXG4gICAgICByb290Qm91bmRhcnk6IHJvb3RCb3VuZGFyeSxcbiAgICAgIGFsdEJvdW5kYXJ5OiBhbHRCb3VuZGFyeSxcbiAgICAgIHBhZGRpbmc6IHBhZGRpbmdcbiAgICB9KTtcbiAgICB2YXIgbWFpblZhcmlhdGlvblNpZGUgPSBpc1ZlcnRpY2FsID8gaXNTdGFydFZhcmlhdGlvbiA/IHJpZ2h0IDogbGVmdCA6IGlzU3RhcnRWYXJpYXRpb24gPyBib3R0b20gOiB0b3A7XG5cbiAgICBpZiAocmVmZXJlbmNlUmVjdFtsZW5dID4gcG9wcGVyUmVjdFtsZW5dKSB7XG4gICAgICBtYWluVmFyaWF0aW9uU2lkZSA9IGdldE9wcG9zaXRlUGxhY2VtZW50KG1haW5WYXJpYXRpb25TaWRlKTtcbiAgICB9XG5cbiAgICB2YXIgYWx0VmFyaWF0aW9uU2lkZSA9IGdldE9wcG9zaXRlUGxhY2VtZW50KG1haW5WYXJpYXRpb25TaWRlKTtcbiAgICB2YXIgY2hlY2tzID0gW107XG5cbiAgICBpZiAoY2hlY2tNYWluQXhpcykge1xuICAgICAgY2hlY2tzLnB1c2gob3ZlcmZsb3dbX2Jhc2VQbGFjZW1lbnRdIDw9IDApO1xuICAgIH1cblxuICAgIGlmIChjaGVja0FsdEF4aXMpIHtcbiAgICAgIGNoZWNrcy5wdXNoKG92ZXJmbG93W21haW5WYXJpYXRpb25TaWRlXSA8PSAwLCBvdmVyZmxvd1thbHRWYXJpYXRpb25TaWRlXSA8PSAwKTtcbiAgICB9XG5cbiAgICBpZiAoY2hlY2tzLmV2ZXJ5KGZ1bmN0aW9uIChjaGVjaykge1xuICAgICAgcmV0dXJuIGNoZWNrO1xuICAgIH0pKSB7XG4gICAgICBmaXJzdEZpdHRpbmdQbGFjZW1lbnQgPSBwbGFjZW1lbnQ7XG4gICAgICBtYWtlRmFsbGJhY2tDaGVja3MgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGNoZWNrc01hcC5zZXQocGxhY2VtZW50LCBjaGVja3MpO1xuICB9XG5cbiAgaWYgKG1ha2VGYWxsYmFja0NoZWNrcykge1xuICAgIC8vIGAyYCBtYXkgYmUgZGVzaXJlZCBpbiBzb21lIGNhc2VzIOKAkyByZXNlYXJjaCBsYXRlclxuICAgIHZhciBudW1iZXJPZkNoZWNrcyA9IGZsaXBWYXJpYXRpb25zID8gMyA6IDE7XG5cbiAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcChfaSkge1xuICAgICAgdmFyIGZpdHRpbmdQbGFjZW1lbnQgPSBwbGFjZW1lbnRzLmZpbmQoZnVuY3Rpb24gKHBsYWNlbWVudCkge1xuICAgICAgICB2YXIgY2hlY2tzID0gY2hlY2tzTWFwLmdldChwbGFjZW1lbnQpO1xuXG4gICAgICAgIGlmIChjaGVja3MpIHtcbiAgICAgICAgICByZXR1cm4gY2hlY2tzLnNsaWNlKDAsIF9pKS5ldmVyeShmdW5jdGlvbiAoY2hlY2spIHtcbiAgICAgICAgICAgIHJldHVybiBjaGVjaztcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmIChmaXR0aW5nUGxhY2VtZW50KSB7XG4gICAgICAgIGZpcnN0Rml0dGluZ1BsYWNlbWVudCA9IGZpdHRpbmdQbGFjZW1lbnQ7XG4gICAgICAgIHJldHVybiBcImJyZWFrXCI7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGZvciAodmFyIF9pID0gbnVtYmVyT2ZDaGVja3M7IF9pID4gMDsgX2ktLSkge1xuICAgICAgdmFyIF9yZXQgPSBfbG9vcChfaSk7XG5cbiAgICAgIGlmIChfcmV0ID09PSBcImJyZWFrXCIpIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGlmIChzdGF0ZS5wbGFjZW1lbnQgIT09IGZpcnN0Rml0dGluZ1BsYWNlbWVudCkge1xuICAgIHN0YXRlLm1vZGlmaWVyc0RhdGFbbmFtZV0uX3NraXAgPSB0cnVlO1xuICAgIHN0YXRlLnBsYWNlbWVudCA9IGZpcnN0Rml0dGluZ1BsYWNlbWVudDtcbiAgICBzdGF0ZS5yZXNldCA9IHRydWU7XG4gIH1cbn0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ2ZsaXAnLFxuICBlbmFibGVkOiB0cnVlLFxuICBwaGFzZTogJ21haW4nLFxuICBmbjogZmxpcCxcbiAgcmVxdWlyZXNJZkV4aXN0czogWydvZmZzZXQnXSxcbiAgZGF0YToge1xuICAgIF9za2lwOiBmYWxzZVxuICB9XG59OyIsImltcG9ydCB7IHRvcCwgYm90dG9tLCBsZWZ0LCByaWdodCB9IGZyb20gXCIuLi9lbnVtcy5qc1wiO1xuaW1wb3J0IGRldGVjdE92ZXJmbG93IGZyb20gXCIuLi91dGlscy9kZXRlY3RPdmVyZmxvdy5qc1wiO1xuXG5mdW5jdGlvbiBnZXRTaWRlT2Zmc2V0cyhvdmVyZmxvdywgcmVjdCwgcHJldmVudGVkT2Zmc2V0cykge1xuICBpZiAocHJldmVudGVkT2Zmc2V0cyA9PT0gdm9pZCAwKSB7XG4gICAgcHJldmVudGVkT2Zmc2V0cyA9IHtcbiAgICAgIHg6IDAsXG4gICAgICB5OiAwXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdG9wOiBvdmVyZmxvdy50b3AgLSByZWN0LmhlaWdodCAtIHByZXZlbnRlZE9mZnNldHMueSxcbiAgICByaWdodDogb3ZlcmZsb3cucmlnaHQgLSByZWN0LndpZHRoICsgcHJldmVudGVkT2Zmc2V0cy54LFxuICAgIGJvdHRvbTogb3ZlcmZsb3cuYm90dG9tIC0gcmVjdC5oZWlnaHQgKyBwcmV2ZW50ZWRPZmZzZXRzLnksXG4gICAgbGVmdDogb3ZlcmZsb3cubGVmdCAtIHJlY3Qud2lkdGggLSBwcmV2ZW50ZWRPZmZzZXRzLnhcbiAgfTtcbn1cblxuZnVuY3Rpb24gaXNBbnlTaWRlRnVsbHlDbGlwcGVkKG92ZXJmbG93KSB7XG4gIHJldHVybiBbdG9wLCByaWdodCwgYm90dG9tLCBsZWZ0XS5zb21lKGZ1bmN0aW9uIChzaWRlKSB7XG4gICAgcmV0dXJuIG92ZXJmbG93W3NpZGVdID49IDA7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBoaWRlKF9yZWYpIHtcbiAgdmFyIHN0YXRlID0gX3JlZi5zdGF0ZSxcbiAgICAgIG5hbWUgPSBfcmVmLm5hbWU7XG4gIHZhciByZWZlcmVuY2VSZWN0ID0gc3RhdGUucmVjdHMucmVmZXJlbmNlO1xuICB2YXIgcG9wcGVyUmVjdCA9IHN0YXRlLnJlY3RzLnBvcHBlcjtcbiAgdmFyIHByZXZlbnRlZE9mZnNldHMgPSBzdGF0ZS5tb2RpZmllcnNEYXRhLnByZXZlbnRPdmVyZmxvdztcbiAgdmFyIHJlZmVyZW5jZU92ZXJmbG93ID0gZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIHtcbiAgICBlbGVtZW50Q29udGV4dDogJ3JlZmVyZW5jZSdcbiAgfSk7XG4gIHZhciBwb3BwZXJBbHRPdmVyZmxvdyA9IGRldGVjdE92ZXJmbG93KHN0YXRlLCB7XG4gICAgYWx0Qm91bmRhcnk6IHRydWVcbiAgfSk7XG4gIHZhciByZWZlcmVuY2VDbGlwcGluZ09mZnNldHMgPSBnZXRTaWRlT2Zmc2V0cyhyZWZlcmVuY2VPdmVyZmxvdywgcmVmZXJlbmNlUmVjdCk7XG4gIHZhciBwb3BwZXJFc2NhcGVPZmZzZXRzID0gZ2V0U2lkZU9mZnNldHMocG9wcGVyQWx0T3ZlcmZsb3csIHBvcHBlclJlY3QsIHByZXZlbnRlZE9mZnNldHMpO1xuICB2YXIgaXNSZWZlcmVuY2VIaWRkZW4gPSBpc0FueVNpZGVGdWxseUNsaXBwZWQocmVmZXJlbmNlQ2xpcHBpbmdPZmZzZXRzKTtcbiAgdmFyIGhhc1BvcHBlckVzY2FwZWQgPSBpc0FueVNpZGVGdWxseUNsaXBwZWQocG9wcGVyRXNjYXBlT2Zmc2V0cyk7XG4gIHN0YXRlLm1vZGlmaWVyc0RhdGFbbmFtZV0gPSB7XG4gICAgcmVmZXJlbmNlQ2xpcHBpbmdPZmZzZXRzOiByZWZlcmVuY2VDbGlwcGluZ09mZnNldHMsXG4gICAgcG9wcGVyRXNjYXBlT2Zmc2V0czogcG9wcGVyRXNjYXBlT2Zmc2V0cyxcbiAgICBpc1JlZmVyZW5jZUhpZGRlbjogaXNSZWZlcmVuY2VIaWRkZW4sXG4gICAgaGFzUG9wcGVyRXNjYXBlZDogaGFzUG9wcGVyRXNjYXBlZFxuICB9O1xuICBzdGF0ZS5hdHRyaWJ1dGVzLnBvcHBlciA9IE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLmF0dHJpYnV0ZXMucG9wcGVyLCB7XG4gICAgJ2RhdGEtcG9wcGVyLXJlZmVyZW5jZS1oaWRkZW4nOiBpc1JlZmVyZW5jZUhpZGRlbixcbiAgICAnZGF0YS1wb3BwZXItZXNjYXBlZCc6IGhhc1BvcHBlckVzY2FwZWRcbiAgfSk7XG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdoaWRlJyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICdtYWluJyxcbiAgcmVxdWlyZXNJZkV4aXN0czogWydwcmV2ZW50T3ZlcmZsb3cnXSxcbiAgZm46IGhpZGVcbn07IiwiaW1wb3J0IGdldEJhc2VQbGFjZW1lbnQgZnJvbSBcIi4uL3V0aWxzL2dldEJhc2VQbGFjZW1lbnQuanNcIjtcbmltcG9ydCB7IHRvcCwgbGVmdCwgcmlnaHQsIHBsYWNlbWVudHMgfSBmcm9tIFwiLi4vZW51bXMuanNcIjtcbmV4cG9ydCBmdW5jdGlvbiBkaXN0YW5jZUFuZFNraWRkaW5nVG9YWShwbGFjZW1lbnQsIHJlY3RzLCBvZmZzZXQpIHtcbiAgdmFyIGJhc2VQbGFjZW1lbnQgPSBnZXRCYXNlUGxhY2VtZW50KHBsYWNlbWVudCk7XG4gIHZhciBpbnZlcnREaXN0YW5jZSA9IFtsZWZ0LCB0b3BdLmluZGV4T2YoYmFzZVBsYWNlbWVudCkgPj0gMCA/IC0xIDogMTtcblxuICB2YXIgX3JlZiA9IHR5cGVvZiBvZmZzZXQgPT09ICdmdW5jdGlvbicgPyBvZmZzZXQoT2JqZWN0LmFzc2lnbih7fSwgcmVjdHMsIHtcbiAgICBwbGFjZW1lbnQ6IHBsYWNlbWVudFxuICB9KSkgOiBvZmZzZXQsXG4gICAgICBza2lkZGluZyA9IF9yZWZbMF0sXG4gICAgICBkaXN0YW5jZSA9IF9yZWZbMV07XG5cbiAgc2tpZGRpbmcgPSBza2lkZGluZyB8fCAwO1xuICBkaXN0YW5jZSA9IChkaXN0YW5jZSB8fCAwKSAqIGludmVydERpc3RhbmNlO1xuICByZXR1cm4gW2xlZnQsIHJpZ2h0XS5pbmRleE9mKGJhc2VQbGFjZW1lbnQpID49IDAgPyB7XG4gICAgeDogZGlzdGFuY2UsXG4gICAgeTogc2tpZGRpbmdcbiAgfSA6IHtcbiAgICB4OiBza2lkZGluZyxcbiAgICB5OiBkaXN0YW5jZVxuICB9O1xufVxuXG5mdW5jdGlvbiBvZmZzZXQoX3JlZjIpIHtcbiAgdmFyIHN0YXRlID0gX3JlZjIuc3RhdGUsXG4gICAgICBvcHRpb25zID0gX3JlZjIub3B0aW9ucyxcbiAgICAgIG5hbWUgPSBfcmVmMi5uYW1lO1xuICB2YXIgX29wdGlvbnMkb2Zmc2V0ID0gb3B0aW9ucy5vZmZzZXQsXG4gICAgICBvZmZzZXQgPSBfb3B0aW9ucyRvZmZzZXQgPT09IHZvaWQgMCA/IFswLCAwXSA6IF9vcHRpb25zJG9mZnNldDtcbiAgdmFyIGRhdGEgPSBwbGFjZW1lbnRzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBwbGFjZW1lbnQpIHtcbiAgICBhY2NbcGxhY2VtZW50XSA9IGRpc3RhbmNlQW5kU2tpZGRpbmdUb1hZKHBsYWNlbWVudCwgc3RhdGUucmVjdHMsIG9mZnNldCk7XG4gICAgcmV0dXJuIGFjYztcbiAgfSwge30pO1xuICB2YXIgX2RhdGEkc3RhdGUkcGxhY2VtZW50ID0gZGF0YVtzdGF0ZS5wbGFjZW1lbnRdLFxuICAgICAgeCA9IF9kYXRhJHN0YXRlJHBsYWNlbWVudC54LFxuICAgICAgeSA9IF9kYXRhJHN0YXRlJHBsYWNlbWVudC55O1xuXG4gIGlmIChzdGF0ZS5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHMgIT0gbnVsbCkge1xuICAgIHN0YXRlLm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cy54ICs9IHg7XG4gICAgc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzLnkgKz0geTtcbiAgfVxuXG4gIHN0YXRlLm1vZGlmaWVyc0RhdGFbbmFtZV0gPSBkYXRhO1xufSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnb2Zmc2V0JyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICdtYWluJyxcbiAgcmVxdWlyZXM6IFsncG9wcGVyT2Zmc2V0cyddLFxuICBmbjogb2Zmc2V0XG59OyIsImltcG9ydCBjb21wdXRlT2Zmc2V0cyBmcm9tIFwiLi4vdXRpbHMvY29tcHV0ZU9mZnNldHMuanNcIjtcblxuZnVuY3Rpb24gcG9wcGVyT2Zmc2V0cyhfcmVmKSB7XG4gIHZhciBzdGF0ZSA9IF9yZWYuc3RhdGUsXG4gICAgICBuYW1lID0gX3JlZi5uYW1lO1xuICAvLyBPZmZzZXRzIGFyZSB0aGUgYWN0dWFsIHBvc2l0aW9uIHRoZSBwb3BwZXIgbmVlZHMgdG8gaGF2ZSB0byBiZVxuICAvLyBwcm9wZXJseSBwb3NpdGlvbmVkIG5lYXIgaXRzIHJlZmVyZW5jZSBlbGVtZW50XG4gIC8vIFRoaXMgaXMgdGhlIG1vc3QgYmFzaWMgcGxhY2VtZW50LCBhbmQgd2lsbCBiZSBhZGp1c3RlZCBieVxuICAvLyB0aGUgbW9kaWZpZXJzIGluIHRoZSBuZXh0IHN0ZXBcbiAgc3RhdGUubW9kaWZpZXJzRGF0YVtuYW1lXSA9IGNvbXB1dGVPZmZzZXRzKHtcbiAgICByZWZlcmVuY2U6IHN0YXRlLnJlY3RzLnJlZmVyZW5jZSxcbiAgICBlbGVtZW50OiBzdGF0ZS5yZWN0cy5wb3BwZXIsXG4gICAgc3RyYXRlZ3k6ICdhYnNvbHV0ZScsXG4gICAgcGxhY2VtZW50OiBzdGF0ZS5wbGFjZW1lbnRcbiAgfSk7XG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdwb3BwZXJPZmZzZXRzJyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICdyZWFkJyxcbiAgZm46IHBvcHBlck9mZnNldHMsXG4gIGRhdGE6IHt9XG59OyIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldEFsdEF4aXMoYXhpcykge1xuICByZXR1cm4gYXhpcyA9PT0gJ3gnID8gJ3knIDogJ3gnO1xufSIsImltcG9ydCB7IHRvcCwgbGVmdCwgcmlnaHQsIGJvdHRvbSwgc3RhcnQgfSBmcm9tIFwiLi4vZW51bXMuanNcIjtcbmltcG9ydCBnZXRCYXNlUGxhY2VtZW50IGZyb20gXCIuLi91dGlscy9nZXRCYXNlUGxhY2VtZW50LmpzXCI7XG5pbXBvcnQgZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50IGZyb20gXCIuLi91dGlscy9nZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQuanNcIjtcbmltcG9ydCBnZXRBbHRBeGlzIGZyb20gXCIuLi91dGlscy9nZXRBbHRBeGlzLmpzXCI7XG5pbXBvcnQgd2l0aGluIGZyb20gXCIuLi91dGlscy93aXRoaW4uanNcIjtcbmltcG9ydCBnZXRMYXlvdXRSZWN0IGZyb20gXCIuLi9kb20tdXRpbHMvZ2V0TGF5b3V0UmVjdC5qc1wiO1xuaW1wb3J0IGdldE9mZnNldFBhcmVudCBmcm9tIFwiLi4vZG9tLXV0aWxzL2dldE9mZnNldFBhcmVudC5qc1wiO1xuaW1wb3J0IGRldGVjdE92ZXJmbG93IGZyb20gXCIuLi91dGlscy9kZXRlY3RPdmVyZmxvdy5qc1wiO1xuaW1wb3J0IGdldFZhcmlhdGlvbiBmcm9tIFwiLi4vdXRpbHMvZ2V0VmFyaWF0aW9uLmpzXCI7XG5pbXBvcnQgZ2V0RnJlc2hTaWRlT2JqZWN0IGZyb20gXCIuLi91dGlscy9nZXRGcmVzaFNpZGVPYmplY3QuanNcIjtcbmltcG9ydCB7IG1heCBhcyBtYXRoTWF4LCBtaW4gYXMgbWF0aE1pbiB9IGZyb20gXCIuLi91dGlscy9tYXRoLmpzXCI7XG5cbmZ1bmN0aW9uIHByZXZlbnRPdmVyZmxvdyhfcmVmKSB7XG4gIHZhciBzdGF0ZSA9IF9yZWYuc3RhdGUsXG4gICAgICBvcHRpb25zID0gX3JlZi5vcHRpb25zLFxuICAgICAgbmFtZSA9IF9yZWYubmFtZTtcbiAgdmFyIF9vcHRpb25zJG1haW5BeGlzID0gb3B0aW9ucy5tYWluQXhpcyxcbiAgICAgIGNoZWNrTWFpbkF4aXMgPSBfb3B0aW9ucyRtYWluQXhpcyA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJG1haW5BeGlzLFxuICAgICAgX29wdGlvbnMkYWx0QXhpcyA9IG9wdGlvbnMuYWx0QXhpcyxcbiAgICAgIGNoZWNrQWx0QXhpcyA9IF9vcHRpb25zJGFsdEF4aXMgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnMkYWx0QXhpcyxcbiAgICAgIGJvdW5kYXJ5ID0gb3B0aW9ucy5ib3VuZGFyeSxcbiAgICAgIHJvb3RCb3VuZGFyeSA9IG9wdGlvbnMucm9vdEJvdW5kYXJ5LFxuICAgICAgYWx0Qm91bmRhcnkgPSBvcHRpb25zLmFsdEJvdW5kYXJ5LFxuICAgICAgcGFkZGluZyA9IG9wdGlvbnMucGFkZGluZyxcbiAgICAgIF9vcHRpb25zJHRldGhlciA9IG9wdGlvbnMudGV0aGVyLFxuICAgICAgdGV0aGVyID0gX29wdGlvbnMkdGV0aGVyID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkdGV0aGVyLFxuICAgICAgX29wdGlvbnMkdGV0aGVyT2Zmc2V0ID0gb3B0aW9ucy50ZXRoZXJPZmZzZXQsXG4gICAgICB0ZXRoZXJPZmZzZXQgPSBfb3B0aW9ucyR0ZXRoZXJPZmZzZXQgPT09IHZvaWQgMCA/IDAgOiBfb3B0aW9ucyR0ZXRoZXJPZmZzZXQ7XG4gIHZhciBvdmVyZmxvdyA9IGRldGVjdE92ZXJmbG93KHN0YXRlLCB7XG4gICAgYm91bmRhcnk6IGJvdW5kYXJ5LFxuICAgIHJvb3RCb3VuZGFyeTogcm9vdEJvdW5kYXJ5LFxuICAgIHBhZGRpbmc6IHBhZGRpbmcsXG4gICAgYWx0Qm91bmRhcnk6IGFsdEJvdW5kYXJ5XG4gIH0pO1xuICB2YXIgYmFzZVBsYWNlbWVudCA9IGdldEJhc2VQbGFjZW1lbnQoc3RhdGUucGxhY2VtZW50KTtcbiAgdmFyIHZhcmlhdGlvbiA9IGdldFZhcmlhdGlvbihzdGF0ZS5wbGFjZW1lbnQpO1xuICB2YXIgaXNCYXNlUGxhY2VtZW50ID0gIXZhcmlhdGlvbjtcbiAgdmFyIG1haW5BeGlzID0gZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50KGJhc2VQbGFjZW1lbnQpO1xuICB2YXIgYWx0QXhpcyA9IGdldEFsdEF4aXMobWFpbkF4aXMpO1xuICB2YXIgcG9wcGVyT2Zmc2V0cyA9IHN0YXRlLm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cztcbiAgdmFyIHJlZmVyZW5jZVJlY3QgPSBzdGF0ZS5yZWN0cy5yZWZlcmVuY2U7XG4gIHZhciBwb3BwZXJSZWN0ID0gc3RhdGUucmVjdHMucG9wcGVyO1xuICB2YXIgdGV0aGVyT2Zmc2V0VmFsdWUgPSB0eXBlb2YgdGV0aGVyT2Zmc2V0ID09PSAnZnVuY3Rpb24nID8gdGV0aGVyT2Zmc2V0KE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLnJlY3RzLCB7XG4gICAgcGxhY2VtZW50OiBzdGF0ZS5wbGFjZW1lbnRcbiAgfSkpIDogdGV0aGVyT2Zmc2V0O1xuICB2YXIgZGF0YSA9IHtcbiAgICB4OiAwLFxuICAgIHk6IDBcbiAgfTtcblxuICBpZiAoIXBvcHBlck9mZnNldHMpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoY2hlY2tNYWluQXhpcyB8fCBjaGVja0FsdEF4aXMpIHtcbiAgICB2YXIgbWFpblNpZGUgPSBtYWluQXhpcyA9PT0gJ3knID8gdG9wIDogbGVmdDtcbiAgICB2YXIgYWx0U2lkZSA9IG1haW5BeGlzID09PSAneScgPyBib3R0b20gOiByaWdodDtcbiAgICB2YXIgbGVuID0gbWFpbkF4aXMgPT09ICd5JyA/ICdoZWlnaHQnIDogJ3dpZHRoJztcbiAgICB2YXIgb2Zmc2V0ID0gcG9wcGVyT2Zmc2V0c1ttYWluQXhpc107XG4gICAgdmFyIG1pbiA9IHBvcHBlck9mZnNldHNbbWFpbkF4aXNdICsgb3ZlcmZsb3dbbWFpblNpZGVdO1xuICAgIHZhciBtYXggPSBwb3BwZXJPZmZzZXRzW21haW5BeGlzXSAtIG92ZXJmbG93W2FsdFNpZGVdO1xuICAgIHZhciBhZGRpdGl2ZSA9IHRldGhlciA/IC1wb3BwZXJSZWN0W2xlbl0gLyAyIDogMDtcbiAgICB2YXIgbWluTGVuID0gdmFyaWF0aW9uID09PSBzdGFydCA/IHJlZmVyZW5jZVJlY3RbbGVuXSA6IHBvcHBlclJlY3RbbGVuXTtcbiAgICB2YXIgbWF4TGVuID0gdmFyaWF0aW9uID09PSBzdGFydCA/IC1wb3BwZXJSZWN0W2xlbl0gOiAtcmVmZXJlbmNlUmVjdFtsZW5dOyAvLyBXZSBuZWVkIHRvIGluY2x1ZGUgdGhlIGFycm93IGluIHRoZSBjYWxjdWxhdGlvbiBzbyB0aGUgYXJyb3cgZG9lc24ndCBnb1xuICAgIC8vIG91dHNpZGUgdGhlIHJlZmVyZW5jZSBib3VuZHNcblxuICAgIHZhciBhcnJvd0VsZW1lbnQgPSBzdGF0ZS5lbGVtZW50cy5hcnJvdztcbiAgICB2YXIgYXJyb3dSZWN0ID0gdGV0aGVyICYmIGFycm93RWxlbWVudCA/IGdldExheW91dFJlY3QoYXJyb3dFbGVtZW50KSA6IHtcbiAgICAgIHdpZHRoOiAwLFxuICAgICAgaGVpZ2h0OiAwXG4gICAgfTtcbiAgICB2YXIgYXJyb3dQYWRkaW5nT2JqZWN0ID0gc3RhdGUubW9kaWZpZXJzRGF0YVsnYXJyb3cjcGVyc2lzdGVudCddID8gc3RhdGUubW9kaWZpZXJzRGF0YVsnYXJyb3cjcGVyc2lzdGVudCddLnBhZGRpbmcgOiBnZXRGcmVzaFNpZGVPYmplY3QoKTtcbiAgICB2YXIgYXJyb3dQYWRkaW5nTWluID0gYXJyb3dQYWRkaW5nT2JqZWN0W21haW5TaWRlXTtcbiAgICB2YXIgYXJyb3dQYWRkaW5nTWF4ID0gYXJyb3dQYWRkaW5nT2JqZWN0W2FsdFNpZGVdOyAvLyBJZiB0aGUgcmVmZXJlbmNlIGxlbmd0aCBpcyBzbWFsbGVyIHRoYW4gdGhlIGFycm93IGxlbmd0aCwgd2UgZG9uJ3Qgd2FudFxuICAgIC8vIHRvIGluY2x1ZGUgaXRzIGZ1bGwgc2l6ZSBpbiB0aGUgY2FsY3VsYXRpb24uIElmIHRoZSByZWZlcmVuY2UgaXMgc21hbGxcbiAgICAvLyBhbmQgbmVhciB0aGUgZWRnZSBvZiBhIGJvdW5kYXJ5LCB0aGUgcG9wcGVyIGNhbiBvdmVyZmxvdyBldmVuIGlmIHRoZVxuICAgIC8vIHJlZmVyZW5jZSBpcyBub3Qgb3ZlcmZsb3dpbmcgYXMgd2VsbCAoZS5nLiB2aXJ0dWFsIGVsZW1lbnRzIHdpdGggbm9cbiAgICAvLyB3aWR0aCBvciBoZWlnaHQpXG5cbiAgICB2YXIgYXJyb3dMZW4gPSB3aXRoaW4oMCwgcmVmZXJlbmNlUmVjdFtsZW5dLCBhcnJvd1JlY3RbbGVuXSk7XG4gICAgdmFyIG1pbk9mZnNldCA9IGlzQmFzZVBsYWNlbWVudCA/IHJlZmVyZW5jZVJlY3RbbGVuXSAvIDIgLSBhZGRpdGl2ZSAtIGFycm93TGVuIC0gYXJyb3dQYWRkaW5nTWluIC0gdGV0aGVyT2Zmc2V0VmFsdWUgOiBtaW5MZW4gLSBhcnJvd0xlbiAtIGFycm93UGFkZGluZ01pbiAtIHRldGhlck9mZnNldFZhbHVlO1xuICAgIHZhciBtYXhPZmZzZXQgPSBpc0Jhc2VQbGFjZW1lbnQgPyAtcmVmZXJlbmNlUmVjdFtsZW5dIC8gMiArIGFkZGl0aXZlICsgYXJyb3dMZW4gKyBhcnJvd1BhZGRpbmdNYXggKyB0ZXRoZXJPZmZzZXRWYWx1ZSA6IG1heExlbiArIGFycm93TGVuICsgYXJyb3dQYWRkaW5nTWF4ICsgdGV0aGVyT2Zmc2V0VmFsdWU7XG4gICAgdmFyIGFycm93T2Zmc2V0UGFyZW50ID0gc3RhdGUuZWxlbWVudHMuYXJyb3cgJiYgZ2V0T2Zmc2V0UGFyZW50KHN0YXRlLmVsZW1lbnRzLmFycm93KTtcbiAgICB2YXIgY2xpZW50T2Zmc2V0ID0gYXJyb3dPZmZzZXRQYXJlbnQgPyBtYWluQXhpcyA9PT0gJ3knID8gYXJyb3dPZmZzZXRQYXJlbnQuY2xpZW50VG9wIHx8IDAgOiBhcnJvd09mZnNldFBhcmVudC5jbGllbnRMZWZ0IHx8IDAgOiAwO1xuICAgIHZhciBvZmZzZXRNb2RpZmllclZhbHVlID0gc3RhdGUubW9kaWZpZXJzRGF0YS5vZmZzZXQgPyBzdGF0ZS5tb2RpZmllcnNEYXRhLm9mZnNldFtzdGF0ZS5wbGFjZW1lbnRdW21haW5BeGlzXSA6IDA7XG4gICAgdmFyIHRldGhlck1pbiA9IHBvcHBlck9mZnNldHNbbWFpbkF4aXNdICsgbWluT2Zmc2V0IC0gb2Zmc2V0TW9kaWZpZXJWYWx1ZSAtIGNsaWVudE9mZnNldDtcbiAgICB2YXIgdGV0aGVyTWF4ID0gcG9wcGVyT2Zmc2V0c1ttYWluQXhpc10gKyBtYXhPZmZzZXQgLSBvZmZzZXRNb2RpZmllclZhbHVlO1xuXG4gICAgaWYgKGNoZWNrTWFpbkF4aXMpIHtcbiAgICAgIHZhciBwcmV2ZW50ZWRPZmZzZXQgPSB3aXRoaW4odGV0aGVyID8gbWF0aE1pbihtaW4sIHRldGhlck1pbikgOiBtaW4sIG9mZnNldCwgdGV0aGVyID8gbWF0aE1heChtYXgsIHRldGhlck1heCkgOiBtYXgpO1xuICAgICAgcG9wcGVyT2Zmc2V0c1ttYWluQXhpc10gPSBwcmV2ZW50ZWRPZmZzZXQ7XG4gICAgICBkYXRhW21haW5BeGlzXSA9IHByZXZlbnRlZE9mZnNldCAtIG9mZnNldDtcbiAgICB9XG5cbiAgICBpZiAoY2hlY2tBbHRBeGlzKSB7XG4gICAgICB2YXIgX21haW5TaWRlID0gbWFpbkF4aXMgPT09ICd4JyA/IHRvcCA6IGxlZnQ7XG5cbiAgICAgIHZhciBfYWx0U2lkZSA9IG1haW5BeGlzID09PSAneCcgPyBib3R0b20gOiByaWdodDtcblxuICAgICAgdmFyIF9vZmZzZXQgPSBwb3BwZXJPZmZzZXRzW2FsdEF4aXNdO1xuXG4gICAgICB2YXIgX21pbiA9IF9vZmZzZXQgKyBvdmVyZmxvd1tfbWFpblNpZGVdO1xuXG4gICAgICB2YXIgX21heCA9IF9vZmZzZXQgLSBvdmVyZmxvd1tfYWx0U2lkZV07XG5cbiAgICAgIHZhciBfcHJldmVudGVkT2Zmc2V0ID0gd2l0aGluKHRldGhlciA/IG1hdGhNaW4oX21pbiwgdGV0aGVyTWluKSA6IF9taW4sIF9vZmZzZXQsIHRldGhlciA/IG1hdGhNYXgoX21heCwgdGV0aGVyTWF4KSA6IF9tYXgpO1xuXG4gICAgICBwb3BwZXJPZmZzZXRzW2FsdEF4aXNdID0gX3ByZXZlbnRlZE9mZnNldDtcbiAgICAgIGRhdGFbYWx0QXhpc10gPSBfcHJldmVudGVkT2Zmc2V0IC0gX29mZnNldDtcbiAgICB9XG4gIH1cblxuICBzdGF0ZS5tb2RpZmllcnNEYXRhW25hbWVdID0gZGF0YTtcbn0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ3ByZXZlbnRPdmVyZmxvdycsXG4gIGVuYWJsZWQ6IHRydWUsXG4gIHBoYXNlOiAnbWFpbicsXG4gIGZuOiBwcmV2ZW50T3ZlcmZsb3csXG4gIHJlcXVpcmVzSWZFeGlzdHM6IFsnb2Zmc2V0J11cbn07IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0SFRNTEVsZW1lbnRTY3JvbGwoZWxlbWVudCkge1xuICByZXR1cm4ge1xuICAgIHNjcm9sbExlZnQ6IGVsZW1lbnQuc2Nyb2xsTGVmdCxcbiAgICBzY3JvbGxUb3A6IGVsZW1lbnQuc2Nyb2xsVG9wXG4gIH07XG59IiwiaW1wb3J0IGdldFdpbmRvd1Njcm9sbCBmcm9tIFwiLi9nZXRXaW5kb3dTY3JvbGwuanNcIjtcbmltcG9ydCBnZXRXaW5kb3cgZnJvbSBcIi4vZ2V0V2luZG93LmpzXCI7XG5pbXBvcnQgeyBpc0hUTUxFbGVtZW50IH0gZnJvbSBcIi4vaW5zdGFuY2VPZi5qc1wiO1xuaW1wb3J0IGdldEhUTUxFbGVtZW50U2Nyb2xsIGZyb20gXCIuL2dldEhUTUxFbGVtZW50U2Nyb2xsLmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXROb2RlU2Nyb2xsKG5vZGUpIHtcbiAgaWYgKG5vZGUgPT09IGdldFdpbmRvdyhub2RlKSB8fCAhaXNIVE1MRWxlbWVudChub2RlKSkge1xuICAgIHJldHVybiBnZXRXaW5kb3dTY3JvbGwobm9kZSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGdldEhUTUxFbGVtZW50U2Nyb2xsKG5vZGUpO1xuICB9XG59IiwiaW1wb3J0IGdldEJvdW5kaW5nQ2xpZW50UmVjdCBmcm9tIFwiLi9nZXRCb3VuZGluZ0NsaWVudFJlY3QuanNcIjtcbmltcG9ydCBnZXROb2RlU2Nyb2xsIGZyb20gXCIuL2dldE5vZGVTY3JvbGwuanNcIjtcbmltcG9ydCBnZXROb2RlTmFtZSBmcm9tIFwiLi9nZXROb2RlTmFtZS5qc1wiO1xuaW1wb3J0IHsgaXNIVE1MRWxlbWVudCB9IGZyb20gXCIuL2luc3RhbmNlT2YuanNcIjtcbmltcG9ydCBnZXRXaW5kb3dTY3JvbGxCYXJYIGZyb20gXCIuL2dldFdpbmRvd1Njcm9sbEJhclguanNcIjtcbmltcG9ydCBnZXREb2N1bWVudEVsZW1lbnQgZnJvbSBcIi4vZ2V0RG9jdW1lbnRFbGVtZW50LmpzXCI7XG5pbXBvcnQgaXNTY3JvbGxQYXJlbnQgZnJvbSBcIi4vaXNTY3JvbGxQYXJlbnQuanNcIjsgLy8gUmV0dXJucyB0aGUgY29tcG9zaXRlIHJlY3Qgb2YgYW4gZWxlbWVudCByZWxhdGl2ZSB0byBpdHMgb2Zmc2V0UGFyZW50LlxuLy8gQ29tcG9zaXRlIG1lYW5zIGl0IHRha2VzIGludG8gYWNjb3VudCB0cmFuc2Zvcm1zIGFzIHdlbGwgYXMgbGF5b3V0LlxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRDb21wb3NpdGVSZWN0KGVsZW1lbnRPclZpcnR1YWxFbGVtZW50LCBvZmZzZXRQYXJlbnQsIGlzRml4ZWQpIHtcbiAgaWYgKGlzRml4ZWQgPT09IHZvaWQgMCkge1xuICAgIGlzRml4ZWQgPSBmYWxzZTtcbiAgfVxuXG4gIHZhciBkb2N1bWVudEVsZW1lbnQgPSBnZXREb2N1bWVudEVsZW1lbnQob2Zmc2V0UGFyZW50KTtcbiAgdmFyIHJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudE9yVmlydHVhbEVsZW1lbnQpO1xuICB2YXIgaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQgPSBpc0hUTUxFbGVtZW50KG9mZnNldFBhcmVudCk7XG4gIHZhciBzY3JvbGwgPSB7XG4gICAgc2Nyb2xsTGVmdDogMCxcbiAgICBzY3JvbGxUb3A6IDBcbiAgfTtcbiAgdmFyIG9mZnNldHMgPSB7XG4gICAgeDogMCxcbiAgICB5OiAwXG4gIH07XG5cbiAgaWYgKGlzT2Zmc2V0UGFyZW50QW5FbGVtZW50IHx8ICFpc09mZnNldFBhcmVudEFuRWxlbWVudCAmJiAhaXNGaXhlZCkge1xuICAgIGlmIChnZXROb2RlTmFtZShvZmZzZXRQYXJlbnQpICE9PSAnYm9keScgfHwgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BvcHBlcmpzL3BvcHBlci1jb3JlL2lzc3Vlcy8xMDc4XG4gICAgaXNTY3JvbGxQYXJlbnQoZG9jdW1lbnRFbGVtZW50KSkge1xuICAgICAgc2Nyb2xsID0gZ2V0Tm9kZVNjcm9sbChvZmZzZXRQYXJlbnQpO1xuICAgIH1cblxuICAgIGlmIChpc0hUTUxFbGVtZW50KG9mZnNldFBhcmVudCkpIHtcbiAgICAgIG9mZnNldHMgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3Qob2Zmc2V0UGFyZW50KTtcbiAgICAgIG9mZnNldHMueCArPSBvZmZzZXRQYXJlbnQuY2xpZW50TGVmdDtcbiAgICAgIG9mZnNldHMueSArPSBvZmZzZXRQYXJlbnQuY2xpZW50VG9wO1xuICAgIH0gZWxzZSBpZiAoZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgICBvZmZzZXRzLnggPSBnZXRXaW5kb3dTY3JvbGxCYXJYKGRvY3VtZW50RWxlbWVudCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB4OiByZWN0LmxlZnQgKyBzY3JvbGwuc2Nyb2xsTGVmdCAtIG9mZnNldHMueCxcbiAgICB5OiByZWN0LnRvcCArIHNjcm9sbC5zY3JvbGxUb3AgLSBvZmZzZXRzLnksXG4gICAgd2lkdGg6IHJlY3Qud2lkdGgsXG4gICAgaGVpZ2h0OiByZWN0LmhlaWdodFxuICB9O1xufSIsImltcG9ydCB7IG1vZGlmaWVyUGhhc2VzIH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7IC8vIHNvdXJjZTogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNDk4NzUyNTVcblxuZnVuY3Rpb24gb3JkZXIobW9kaWZpZXJzKSB7XG4gIHZhciBtYXAgPSBuZXcgTWFwKCk7XG4gIHZhciB2aXNpdGVkID0gbmV3IFNldCgpO1xuICB2YXIgcmVzdWx0ID0gW107XG4gIG1vZGlmaWVycy5mb3JFYWNoKGZ1bmN0aW9uIChtb2RpZmllcikge1xuICAgIG1hcC5zZXQobW9kaWZpZXIubmFtZSwgbW9kaWZpZXIpO1xuICB9KTsgLy8gT24gdmlzaXRpbmcgb2JqZWN0LCBjaGVjayBmb3IgaXRzIGRlcGVuZGVuY2llcyBhbmQgdmlzaXQgdGhlbSByZWN1cnNpdmVseVxuXG4gIGZ1bmN0aW9uIHNvcnQobW9kaWZpZXIpIHtcbiAgICB2aXNpdGVkLmFkZChtb2RpZmllci5uYW1lKTtcbiAgICB2YXIgcmVxdWlyZXMgPSBbXS5jb25jYXQobW9kaWZpZXIucmVxdWlyZXMgfHwgW10sIG1vZGlmaWVyLnJlcXVpcmVzSWZFeGlzdHMgfHwgW10pO1xuICAgIHJlcXVpcmVzLmZvckVhY2goZnVuY3Rpb24gKGRlcCkge1xuICAgICAgaWYgKCF2aXNpdGVkLmhhcyhkZXApKSB7XG4gICAgICAgIHZhciBkZXBNb2RpZmllciA9IG1hcC5nZXQoZGVwKTtcblxuICAgICAgICBpZiAoZGVwTW9kaWZpZXIpIHtcbiAgICAgICAgICBzb3J0KGRlcE1vZGlmaWVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHJlc3VsdC5wdXNoKG1vZGlmaWVyKTtcbiAgfVxuXG4gIG1vZGlmaWVycy5mb3JFYWNoKGZ1bmN0aW9uIChtb2RpZmllcikge1xuICAgIGlmICghdmlzaXRlZC5oYXMobW9kaWZpZXIubmFtZSkpIHtcbiAgICAgIC8vIGNoZWNrIGZvciB2aXNpdGVkIG9iamVjdFxuICAgICAgc29ydChtb2RpZmllcik7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gb3JkZXJNb2RpZmllcnMobW9kaWZpZXJzKSB7XG4gIC8vIG9yZGVyIGJhc2VkIG9uIGRlcGVuZGVuY2llc1xuICB2YXIgb3JkZXJlZE1vZGlmaWVycyA9IG9yZGVyKG1vZGlmaWVycyk7IC8vIG9yZGVyIGJhc2VkIG9uIHBoYXNlXG5cbiAgcmV0dXJuIG1vZGlmaWVyUGhhc2VzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBwaGFzZSkge1xuICAgIHJldHVybiBhY2MuY29uY2F0KG9yZGVyZWRNb2RpZmllcnMuZmlsdGVyKGZ1bmN0aW9uIChtb2RpZmllcikge1xuICAgICAgcmV0dXJuIG1vZGlmaWVyLnBoYXNlID09PSBwaGFzZTtcbiAgICB9KSk7XG4gIH0sIFtdKTtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBkZWJvdW5jZShmbikge1xuICB2YXIgcGVuZGluZztcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXBlbmRpbmcpIHtcbiAgICAgIHBlbmRpbmcgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBwZW5kaW5nID0gdW5kZWZpbmVkO1xuICAgICAgICAgIHJlc29sdmUoZm4oKSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBlbmRpbmc7XG4gIH07XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbWVyZ2VCeU5hbWUobW9kaWZpZXJzKSB7XG4gIHZhciBtZXJnZWQgPSBtb2RpZmllcnMucmVkdWNlKGZ1bmN0aW9uIChtZXJnZWQsIGN1cnJlbnQpIHtcbiAgICB2YXIgZXhpc3RpbmcgPSBtZXJnZWRbY3VycmVudC5uYW1lXTtcbiAgICBtZXJnZWRbY3VycmVudC5uYW1lXSA9IGV4aXN0aW5nID8gT2JqZWN0LmFzc2lnbih7fSwgZXhpc3RpbmcsIGN1cnJlbnQsIHtcbiAgICAgIG9wdGlvbnM6IE9iamVjdC5hc3NpZ24oe30sIGV4aXN0aW5nLm9wdGlvbnMsIGN1cnJlbnQub3B0aW9ucyksXG4gICAgICBkYXRhOiBPYmplY3QuYXNzaWduKHt9LCBleGlzdGluZy5kYXRhLCBjdXJyZW50LmRhdGEpXG4gICAgfSkgOiBjdXJyZW50O1xuICAgIHJldHVybiBtZXJnZWQ7XG4gIH0sIHt9KTsgLy8gSUUxMSBkb2VzIG5vdCBzdXBwb3J0IE9iamVjdC52YWx1ZXNcblxuICByZXR1cm4gT2JqZWN0LmtleXMobWVyZ2VkKS5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiBtZXJnZWRba2V5XTtcbiAgfSk7XG59IiwiaW1wb3J0IGdldENvbXBvc2l0ZVJlY3QgZnJvbSBcIi4vZG9tLXV0aWxzL2dldENvbXBvc2l0ZVJlY3QuanNcIjtcbmltcG9ydCBnZXRMYXlvdXRSZWN0IGZyb20gXCIuL2RvbS11dGlscy9nZXRMYXlvdXRSZWN0LmpzXCI7XG5pbXBvcnQgbGlzdFNjcm9sbFBhcmVudHMgZnJvbSBcIi4vZG9tLXV0aWxzL2xpc3RTY3JvbGxQYXJlbnRzLmpzXCI7XG5pbXBvcnQgZ2V0T2Zmc2V0UGFyZW50IGZyb20gXCIuL2RvbS11dGlscy9nZXRPZmZzZXRQYXJlbnQuanNcIjtcbmltcG9ydCBnZXRDb21wdXRlZFN0eWxlIGZyb20gXCIuL2RvbS11dGlscy9nZXRDb21wdXRlZFN0eWxlLmpzXCI7XG5pbXBvcnQgb3JkZXJNb2RpZmllcnMgZnJvbSBcIi4vdXRpbHMvb3JkZXJNb2RpZmllcnMuanNcIjtcbmltcG9ydCBkZWJvdW5jZSBmcm9tIFwiLi91dGlscy9kZWJvdW5jZS5qc1wiO1xuaW1wb3J0IHZhbGlkYXRlTW9kaWZpZXJzIGZyb20gXCIuL3V0aWxzL3ZhbGlkYXRlTW9kaWZpZXJzLmpzXCI7XG5pbXBvcnQgdW5pcXVlQnkgZnJvbSBcIi4vdXRpbHMvdW5pcXVlQnkuanNcIjtcbmltcG9ydCBnZXRCYXNlUGxhY2VtZW50IGZyb20gXCIuL3V0aWxzL2dldEJhc2VQbGFjZW1lbnQuanNcIjtcbmltcG9ydCBtZXJnZUJ5TmFtZSBmcm9tIFwiLi91dGlscy9tZXJnZUJ5TmFtZS5qc1wiO1xuaW1wb3J0IGRldGVjdE92ZXJmbG93IGZyb20gXCIuL3V0aWxzL2RldGVjdE92ZXJmbG93LmpzXCI7XG5pbXBvcnQgeyBpc0VsZW1lbnQgfSBmcm9tIFwiLi9kb20tdXRpbHMvaW5zdGFuY2VPZi5qc1wiO1xuaW1wb3J0IHsgYXV0byB9IGZyb20gXCIuL2VudW1zLmpzXCI7XG52YXIgSU5WQUxJRF9FTEVNRU5UX0VSUk9SID0gJ1BvcHBlcjogSW52YWxpZCByZWZlcmVuY2Ugb3IgcG9wcGVyIGFyZ3VtZW50IHByb3ZpZGVkLiBUaGV5IG11c3QgYmUgZWl0aGVyIGEgRE9NIGVsZW1lbnQgb3IgdmlydHVhbCBlbGVtZW50Lic7XG52YXIgSU5GSU5JVEVfTE9PUF9FUlJPUiA9ICdQb3BwZXI6IEFuIGluZmluaXRlIGxvb3AgaW4gdGhlIG1vZGlmaWVycyBjeWNsZSBoYXMgYmVlbiBkZXRlY3RlZCEgVGhlIGN5Y2xlIGhhcyBiZWVuIGludGVycnVwdGVkIHRvIHByZXZlbnQgYSBicm93c2VyIGNyYXNoLic7XG52YXIgREVGQVVMVF9PUFRJT05TID0ge1xuICBwbGFjZW1lbnQ6ICdib3R0b20nLFxuICBtb2RpZmllcnM6IFtdLFxuICBzdHJhdGVneTogJ2Fic29sdXRlJ1xufTtcblxuZnVuY3Rpb24gYXJlVmFsaWRFbGVtZW50cygpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIHJldHVybiAhYXJncy5zb21lKGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgcmV0dXJuICEoZWxlbWVudCAmJiB0eXBlb2YgZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QgPT09ICdmdW5jdGlvbicpO1xuICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBvcHBlckdlbmVyYXRvcihnZW5lcmF0b3JPcHRpb25zKSB7XG4gIGlmIChnZW5lcmF0b3JPcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBnZW5lcmF0b3JPcHRpb25zID0ge307XG4gIH1cblxuICB2YXIgX2dlbmVyYXRvck9wdGlvbnMgPSBnZW5lcmF0b3JPcHRpb25zLFxuICAgICAgX2dlbmVyYXRvck9wdGlvbnMkZGVmID0gX2dlbmVyYXRvck9wdGlvbnMuZGVmYXVsdE1vZGlmaWVycyxcbiAgICAgIGRlZmF1bHRNb2RpZmllcnMgPSBfZ2VuZXJhdG9yT3B0aW9ucyRkZWYgPT09IHZvaWQgMCA/IFtdIDogX2dlbmVyYXRvck9wdGlvbnMkZGVmLFxuICAgICAgX2dlbmVyYXRvck9wdGlvbnMkZGVmMiA9IF9nZW5lcmF0b3JPcHRpb25zLmRlZmF1bHRPcHRpb25zLFxuICAgICAgZGVmYXVsdE9wdGlvbnMgPSBfZ2VuZXJhdG9yT3B0aW9ucyRkZWYyID09PSB2b2lkIDAgPyBERUZBVUxUX09QVElPTlMgOiBfZ2VuZXJhdG9yT3B0aW9ucyRkZWYyO1xuICByZXR1cm4gZnVuY3Rpb24gY3JlYXRlUG9wcGVyKHJlZmVyZW5jZSwgcG9wcGVyLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgICAgb3B0aW9ucyA9IGRlZmF1bHRPcHRpb25zO1xuICAgIH1cblxuICAgIHZhciBzdGF0ZSA9IHtcbiAgICAgIHBsYWNlbWVudDogJ2JvdHRvbScsXG4gICAgICBvcmRlcmVkTW9kaWZpZXJzOiBbXSxcbiAgICAgIG9wdGlvbnM6IE9iamVjdC5hc3NpZ24oe30sIERFRkFVTFRfT1BUSU9OUywgZGVmYXVsdE9wdGlvbnMpLFxuICAgICAgbW9kaWZpZXJzRGF0YToge30sXG4gICAgICBlbGVtZW50czoge1xuICAgICAgICByZWZlcmVuY2U6IHJlZmVyZW5jZSxcbiAgICAgICAgcG9wcGVyOiBwb3BwZXJcbiAgICAgIH0sXG4gICAgICBhdHRyaWJ1dGVzOiB7fSxcbiAgICAgIHN0eWxlczoge31cbiAgICB9O1xuICAgIHZhciBlZmZlY3RDbGVhbnVwRm5zID0gW107XG4gICAgdmFyIGlzRGVzdHJveWVkID0gZmFsc2U7XG4gICAgdmFyIGluc3RhbmNlID0ge1xuICAgICAgc3RhdGU6IHN0YXRlLFxuICAgICAgc2V0T3B0aW9uczogZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICAgIGNsZWFudXBNb2RpZmllckVmZmVjdHMoKTtcbiAgICAgICAgc3RhdGUub3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRPcHRpb25zLCBzdGF0ZS5vcHRpb25zLCBvcHRpb25zKTtcbiAgICAgICAgc3RhdGUuc2Nyb2xsUGFyZW50cyA9IHtcbiAgICAgICAgICByZWZlcmVuY2U6IGlzRWxlbWVudChyZWZlcmVuY2UpID8gbGlzdFNjcm9sbFBhcmVudHMocmVmZXJlbmNlKSA6IHJlZmVyZW5jZS5jb250ZXh0RWxlbWVudCA/IGxpc3RTY3JvbGxQYXJlbnRzKHJlZmVyZW5jZS5jb250ZXh0RWxlbWVudCkgOiBbXSxcbiAgICAgICAgICBwb3BwZXI6IGxpc3RTY3JvbGxQYXJlbnRzKHBvcHBlcilcbiAgICAgICAgfTsgLy8gT3JkZXJzIHRoZSBtb2RpZmllcnMgYmFzZWQgb24gdGhlaXIgZGVwZW5kZW5jaWVzIGFuZCBgcGhhc2VgXG4gICAgICAgIC8vIHByb3BlcnRpZXNcblxuICAgICAgICB2YXIgb3JkZXJlZE1vZGlmaWVycyA9IG9yZGVyTW9kaWZpZXJzKG1lcmdlQnlOYW1lKFtdLmNvbmNhdChkZWZhdWx0TW9kaWZpZXJzLCBzdGF0ZS5vcHRpb25zLm1vZGlmaWVycykpKTsgLy8gU3RyaXAgb3V0IGRpc2FibGVkIG1vZGlmaWVyc1xuXG4gICAgICAgIHN0YXRlLm9yZGVyZWRNb2RpZmllcnMgPSBvcmRlcmVkTW9kaWZpZXJzLmZpbHRlcihmdW5jdGlvbiAobSkge1xuICAgICAgICAgIHJldHVybiBtLmVuYWJsZWQ7XG4gICAgICAgIH0pOyAvLyBWYWxpZGF0ZSB0aGUgcHJvdmlkZWQgbW9kaWZpZXJzIHNvIHRoYXQgdGhlIGNvbnN1bWVyIHdpbGwgZ2V0IHdhcm5lZFxuICAgICAgICAvLyBpZiBvbmUgb2YgdGhlIG1vZGlmaWVycyBpcyBpbnZhbGlkIGZvciBhbnkgcmVhc29uXG5cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgIHZhciBtb2RpZmllcnMgPSB1bmlxdWVCeShbXS5jb25jYXQob3JkZXJlZE1vZGlmaWVycywgc3RhdGUub3B0aW9ucy5tb2RpZmllcnMpLCBmdW5jdGlvbiAoX3JlZikge1xuICAgICAgICAgICAgdmFyIG5hbWUgPSBfcmVmLm5hbWU7XG4gICAgICAgICAgICByZXR1cm4gbmFtZTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB2YWxpZGF0ZU1vZGlmaWVycyhtb2RpZmllcnMpO1xuXG4gICAgICAgICAgaWYgKGdldEJhc2VQbGFjZW1lbnQoc3RhdGUub3B0aW9ucy5wbGFjZW1lbnQpID09PSBhdXRvKSB7XG4gICAgICAgICAgICB2YXIgZmxpcE1vZGlmaWVyID0gc3RhdGUub3JkZXJlZE1vZGlmaWVycy5maW5kKGZ1bmN0aW9uIChfcmVmMikge1xuICAgICAgICAgICAgICB2YXIgbmFtZSA9IF9yZWYyLm5hbWU7XG4gICAgICAgICAgICAgIHJldHVybiBuYW1lID09PSAnZmxpcCc7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKCFmbGlwTW9kaWZpZXIpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihbJ1BvcHBlcjogXCJhdXRvXCIgcGxhY2VtZW50cyByZXF1aXJlIHRoZSBcImZsaXBcIiBtb2RpZmllciBiZScsICdwcmVzZW50IGFuZCBlbmFibGVkIHRvIHdvcmsuJ10uam9pbignICcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgX2dldENvbXB1dGVkU3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKHBvcHBlciksXG4gICAgICAgICAgICAgIG1hcmdpblRvcCA9IF9nZXRDb21wdXRlZFN0eWxlLm1hcmdpblRvcCxcbiAgICAgICAgICAgICAgbWFyZ2luUmlnaHQgPSBfZ2V0Q29tcHV0ZWRTdHlsZS5tYXJnaW5SaWdodCxcbiAgICAgICAgICAgICAgbWFyZ2luQm90dG9tID0gX2dldENvbXB1dGVkU3R5bGUubWFyZ2luQm90dG9tLFxuICAgICAgICAgICAgICBtYXJnaW5MZWZ0ID0gX2dldENvbXB1dGVkU3R5bGUubWFyZ2luTGVmdDsgLy8gV2Ugbm8gbG9uZ2VyIHRha2UgaW50byBhY2NvdW50IGBtYXJnaW5zYCBvbiB0aGUgcG9wcGVyLCBhbmQgaXQgY2FuXG4gICAgICAgICAgLy8gY2F1c2UgYnVncyB3aXRoIHBvc2l0aW9uaW5nLCBzbyB3ZSdsbCB3YXJuIHRoZSBjb25zdW1lclxuXG5cbiAgICAgICAgICBpZiAoW21hcmdpblRvcCwgbWFyZ2luUmlnaHQsIG1hcmdpbkJvdHRvbSwgbWFyZ2luTGVmdF0uc29tZShmdW5jdGlvbiAobWFyZ2luKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VGbG9hdChtYXJnaW4pO1xuICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oWydQb3BwZXI6IENTUyBcIm1hcmdpblwiIHN0eWxlcyBjYW5ub3QgYmUgdXNlZCB0byBhcHBseSBwYWRkaW5nJywgJ2JldHdlZW4gdGhlIHBvcHBlciBhbmQgaXRzIHJlZmVyZW5jZSBlbGVtZW50IG9yIGJvdW5kYXJ5LicsICdUbyByZXBsaWNhdGUgbWFyZ2luLCB1c2UgdGhlIGBvZmZzZXRgIG1vZGlmaWVyLCBhcyB3ZWxsIGFzJywgJ3RoZSBgcGFkZGluZ2Agb3B0aW9uIGluIHRoZSBgcHJldmVudE92ZXJmbG93YCBhbmQgYGZsaXBgJywgJ21vZGlmaWVycy4nXS5qb2luKCcgJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJ1bk1vZGlmaWVyRWZmZWN0cygpO1xuICAgICAgICByZXR1cm4gaW5zdGFuY2UudXBkYXRlKCk7XG4gICAgICB9LFxuICAgICAgLy8gU3luYyB1cGRhdGUg4oCTIGl0IHdpbGwgYWx3YXlzIGJlIGV4ZWN1dGVkLCBldmVuIGlmIG5vdCBuZWNlc3NhcnkuIFRoaXNcbiAgICAgIC8vIGlzIHVzZWZ1bCBmb3IgbG93IGZyZXF1ZW5jeSB1cGRhdGVzIHdoZXJlIHN5bmMgYmVoYXZpb3Igc2ltcGxpZmllcyB0aGVcbiAgICAgIC8vIGxvZ2ljLlxuICAgICAgLy8gRm9yIGhpZ2ggZnJlcXVlbmN5IHVwZGF0ZXMgKGUuZy4gYHJlc2l6ZWAgYW5kIGBzY3JvbGxgIGV2ZW50cyksIGFsd2F5c1xuICAgICAgLy8gcHJlZmVyIHRoZSBhc3luYyBQb3BwZXIjdXBkYXRlIG1ldGhvZFxuICAgICAgZm9yY2VVcGRhdGU6IGZ1bmN0aW9uIGZvcmNlVXBkYXRlKCkge1xuICAgICAgICBpZiAoaXNEZXN0cm95ZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgX3N0YXRlJGVsZW1lbnRzID0gc3RhdGUuZWxlbWVudHMsXG4gICAgICAgICAgICByZWZlcmVuY2UgPSBfc3RhdGUkZWxlbWVudHMucmVmZXJlbmNlLFxuICAgICAgICAgICAgcG9wcGVyID0gX3N0YXRlJGVsZW1lbnRzLnBvcHBlcjsgLy8gRG9uJ3QgcHJvY2VlZCBpZiBgcmVmZXJlbmNlYCBvciBgcG9wcGVyYCBhcmUgbm90IHZhbGlkIGVsZW1lbnRzXG4gICAgICAgIC8vIGFueW1vcmVcblxuICAgICAgICBpZiAoIWFyZVZhbGlkRWxlbWVudHMocmVmZXJlbmNlLCBwb3BwZXIpKSB7XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihJTlZBTElEX0VMRU1FTlRfRVJST1IpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSAvLyBTdG9yZSB0aGUgcmVmZXJlbmNlIGFuZCBwb3BwZXIgcmVjdHMgdG8gYmUgcmVhZCBieSBtb2RpZmllcnNcblxuXG4gICAgICAgIHN0YXRlLnJlY3RzID0ge1xuICAgICAgICAgIHJlZmVyZW5jZTogZ2V0Q29tcG9zaXRlUmVjdChyZWZlcmVuY2UsIGdldE9mZnNldFBhcmVudChwb3BwZXIpLCBzdGF0ZS5vcHRpb25zLnN0cmF0ZWd5ID09PSAnZml4ZWQnKSxcbiAgICAgICAgICBwb3BwZXI6IGdldExheW91dFJlY3QocG9wcGVyKVxuICAgICAgICB9OyAvLyBNb2RpZmllcnMgaGF2ZSB0aGUgYWJpbGl0eSB0byByZXNldCB0aGUgY3VycmVudCB1cGRhdGUgY3ljbGUuIFRoZVxuICAgICAgICAvLyBtb3N0IGNvbW1vbiB1c2UgY2FzZSBmb3IgdGhpcyBpcyB0aGUgYGZsaXBgIG1vZGlmaWVyIGNoYW5naW5nIHRoZVxuICAgICAgICAvLyBwbGFjZW1lbnQsIHdoaWNoIHRoZW4gbmVlZHMgdG8gcmUtcnVuIGFsbCB0aGUgbW9kaWZpZXJzLCBiZWNhdXNlIHRoZVxuICAgICAgICAvLyBsb2dpYyB3YXMgcHJldmlvdXNseSByYW4gZm9yIHRoZSBwcmV2aW91cyBwbGFjZW1lbnQgYW5kIGlzIHRoZXJlZm9yZVxuICAgICAgICAvLyBzdGFsZS9pbmNvcnJlY3RcblxuICAgICAgICBzdGF0ZS5yZXNldCA9IGZhbHNlO1xuICAgICAgICBzdGF0ZS5wbGFjZW1lbnQgPSBzdGF0ZS5vcHRpb25zLnBsYWNlbWVudDsgLy8gT24gZWFjaCB1cGRhdGUgY3ljbGUsIHRoZSBgbW9kaWZpZXJzRGF0YWAgcHJvcGVydHkgZm9yIGVhY2ggbW9kaWZpZXJcbiAgICAgICAgLy8gaXMgZmlsbGVkIHdpdGggdGhlIGluaXRpYWwgZGF0YSBzcGVjaWZpZWQgYnkgdGhlIG1vZGlmaWVyLiBUaGlzIG1lYW5zXG4gICAgICAgIC8vIGl0IGRvZXNuJ3QgcGVyc2lzdCBhbmQgaXMgZnJlc2ggb24gZWFjaCB1cGRhdGUuXG4gICAgICAgIC8vIFRvIGVuc3VyZSBwZXJzaXN0ZW50IGRhdGEsIHVzZSBgJHtuYW1lfSNwZXJzaXN0ZW50YFxuXG4gICAgICAgIHN0YXRlLm9yZGVyZWRNb2RpZmllcnMuZm9yRWFjaChmdW5jdGlvbiAobW9kaWZpZXIpIHtcbiAgICAgICAgICByZXR1cm4gc3RhdGUubW9kaWZpZXJzRGF0YVttb2RpZmllci5uYW1lXSA9IE9iamVjdC5hc3NpZ24oe30sIG1vZGlmaWVyLmRhdGEpO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIF9fZGVidWdfbG9vcHNfXyA9IDA7XG5cbiAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IHN0YXRlLm9yZGVyZWRNb2RpZmllcnMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgX19kZWJ1Z19sb29wc19fICs9IDE7XG5cbiAgICAgICAgICAgIGlmIChfX2RlYnVnX2xvb3BzX18gPiAxMDApIHtcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihJTkZJTklURV9MT09QX0VSUk9SKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHN0YXRlLnJlc2V0ID09PSB0cnVlKSB7XG4gICAgICAgICAgICBzdGF0ZS5yZXNldCA9IGZhbHNlO1xuICAgICAgICAgICAgaW5kZXggPSAtMTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBfc3RhdGUkb3JkZXJlZE1vZGlmaWUgPSBzdGF0ZS5vcmRlcmVkTW9kaWZpZXJzW2luZGV4XSxcbiAgICAgICAgICAgICAgZm4gPSBfc3RhdGUkb3JkZXJlZE1vZGlmaWUuZm4sXG4gICAgICAgICAgICAgIF9zdGF0ZSRvcmRlcmVkTW9kaWZpZTIgPSBfc3RhdGUkb3JkZXJlZE1vZGlmaWUub3B0aW9ucyxcbiAgICAgICAgICAgICAgX29wdGlvbnMgPSBfc3RhdGUkb3JkZXJlZE1vZGlmaWUyID09PSB2b2lkIDAgPyB7fSA6IF9zdGF0ZSRvcmRlcmVkTW9kaWZpZTIsXG4gICAgICAgICAgICAgIG5hbWUgPSBfc3RhdGUkb3JkZXJlZE1vZGlmaWUubmFtZTtcblxuICAgICAgICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHN0YXRlID0gZm4oe1xuICAgICAgICAgICAgICBzdGF0ZTogc3RhdGUsXG4gICAgICAgICAgICAgIG9wdGlvbnM6IF9vcHRpb25zLFxuICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgICBpbnN0YW5jZTogaW5zdGFuY2VcbiAgICAgICAgICAgIH0pIHx8IHN0YXRlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC8vIEFzeW5jIGFuZCBvcHRpbWlzdGljYWxseSBvcHRpbWl6ZWQgdXBkYXRlIOKAkyBpdCB3aWxsIG5vdCBiZSBleGVjdXRlZCBpZlxuICAgICAgLy8gbm90IG5lY2Vzc2FyeSAoZGVib3VuY2VkIHRvIHJ1biBhdCBtb3N0IG9uY2UtcGVyLXRpY2spXG4gICAgICB1cGRhdGU6IGRlYm91bmNlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgaW5zdGFuY2UuZm9yY2VVcGRhdGUoKTtcbiAgICAgICAgICByZXNvbHZlKHN0YXRlKTtcbiAgICAgICAgfSk7XG4gICAgICB9KSxcbiAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICAgIGNsZWFudXBNb2RpZmllckVmZmVjdHMoKTtcbiAgICAgICAgaXNEZXN0cm95ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAoIWFyZVZhbGlkRWxlbWVudHMocmVmZXJlbmNlLCBwb3BwZXIpKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoSU5WQUxJRF9FTEVNRU5UX0VSUk9SKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgIH1cblxuICAgIGluc3RhbmNlLnNldE9wdGlvbnMob3B0aW9ucykudGhlbihmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgIGlmICghaXNEZXN0cm95ZWQgJiYgb3B0aW9ucy5vbkZpcnN0VXBkYXRlKSB7XG4gICAgICAgIG9wdGlvbnMub25GaXJzdFVwZGF0ZShzdGF0ZSk7XG4gICAgICB9XG4gICAgfSk7IC8vIE1vZGlmaWVycyBoYXZlIHRoZSBhYmlsaXR5IHRvIGV4ZWN1dGUgYXJiaXRyYXJ5IGNvZGUgYmVmb3JlIHRoZSBmaXJzdFxuICAgIC8vIHVwZGF0ZSBjeWNsZSBydW5zLiBUaGV5IHdpbGwgYmUgZXhlY3V0ZWQgaW4gdGhlIHNhbWUgb3JkZXIgYXMgdGhlIHVwZGF0ZVxuICAgIC8vIGN5Y2xlLiBUaGlzIGlzIHVzZWZ1bCB3aGVuIGEgbW9kaWZpZXIgYWRkcyBzb21lIHBlcnNpc3RlbnQgZGF0YSB0aGF0XG4gICAgLy8gb3RoZXIgbW9kaWZpZXJzIG5lZWQgdG8gdXNlLCBidXQgdGhlIG1vZGlmaWVyIGlzIHJ1biBhZnRlciB0aGUgZGVwZW5kZW50XG4gICAgLy8gb25lLlxuXG4gICAgZnVuY3Rpb24gcnVuTW9kaWZpZXJFZmZlY3RzKCkge1xuICAgICAgc3RhdGUub3JkZXJlZE1vZGlmaWVycy5mb3JFYWNoKGZ1bmN0aW9uIChfcmVmMykge1xuICAgICAgICB2YXIgbmFtZSA9IF9yZWYzLm5hbWUsXG4gICAgICAgICAgICBfcmVmMyRvcHRpb25zID0gX3JlZjMub3B0aW9ucyxcbiAgICAgICAgICAgIG9wdGlvbnMgPSBfcmVmMyRvcHRpb25zID09PSB2b2lkIDAgPyB7fSA6IF9yZWYzJG9wdGlvbnMsXG4gICAgICAgICAgICBlZmZlY3QgPSBfcmVmMy5lZmZlY3Q7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBlZmZlY3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB2YXIgY2xlYW51cEZuID0gZWZmZWN0KHtcbiAgICAgICAgICAgIHN0YXRlOiBzdGF0ZSxcbiAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICBpbnN0YW5jZTogaW5zdGFuY2UsXG4gICAgICAgICAgICBvcHRpb25zOiBvcHRpb25zXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB2YXIgbm9vcEZuID0gZnVuY3Rpb24gbm9vcEZuKCkge307XG5cbiAgICAgICAgICBlZmZlY3RDbGVhbnVwRm5zLnB1c2goY2xlYW51cEZuIHx8IG5vb3BGbik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsZWFudXBNb2RpZmllckVmZmVjdHMoKSB7XG4gICAgICBlZmZlY3RDbGVhbnVwRm5zLmZvckVhY2goZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHJldHVybiBmbigpO1xuICAgICAgfSk7XG4gICAgICBlZmZlY3RDbGVhbnVwRm5zID0gW107XG4gICAgfVxuXG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9O1xufVxuZXhwb3J0IHZhciBjcmVhdGVQb3BwZXIgPSAvKiNfX1BVUkVfXyovcG9wcGVyR2VuZXJhdG9yKCk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuZXhwb3J0IHsgZGV0ZWN0T3ZlcmZsb3cgfTsiLCJpbXBvcnQgeyBwb3BwZXJHZW5lcmF0b3IsIGRldGVjdE92ZXJmbG93IH0gZnJvbSBcIi4vY3JlYXRlUG9wcGVyLmpzXCI7XG5pbXBvcnQgZXZlbnRMaXN0ZW5lcnMgZnJvbSBcIi4vbW9kaWZpZXJzL2V2ZW50TGlzdGVuZXJzLmpzXCI7XG5pbXBvcnQgcG9wcGVyT2Zmc2V0cyBmcm9tIFwiLi9tb2RpZmllcnMvcG9wcGVyT2Zmc2V0cy5qc1wiO1xuaW1wb3J0IGNvbXB1dGVTdHlsZXMgZnJvbSBcIi4vbW9kaWZpZXJzL2NvbXB1dGVTdHlsZXMuanNcIjtcbmltcG9ydCBhcHBseVN0eWxlcyBmcm9tIFwiLi9tb2RpZmllcnMvYXBwbHlTdHlsZXMuanNcIjtcbnZhciBkZWZhdWx0TW9kaWZpZXJzID0gW2V2ZW50TGlzdGVuZXJzLCBwb3BwZXJPZmZzZXRzLCBjb21wdXRlU3R5bGVzLCBhcHBseVN0eWxlc107XG52YXIgY3JlYXRlUG9wcGVyID0gLyojX19QVVJFX18qL3BvcHBlckdlbmVyYXRvcih7XG4gIGRlZmF1bHRNb2RpZmllcnM6IGRlZmF1bHRNb2RpZmllcnNcbn0pOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cbmV4cG9ydCB7IGNyZWF0ZVBvcHBlciwgcG9wcGVyR2VuZXJhdG9yLCBkZWZhdWx0TW9kaWZpZXJzLCBkZXRlY3RPdmVyZmxvdyB9OyIsImltcG9ydCB7IHBvcHBlckdlbmVyYXRvciwgZGV0ZWN0T3ZlcmZsb3cgfSBmcm9tIFwiLi9jcmVhdGVQb3BwZXIuanNcIjtcbmltcG9ydCBldmVudExpc3RlbmVycyBmcm9tIFwiLi9tb2RpZmllcnMvZXZlbnRMaXN0ZW5lcnMuanNcIjtcbmltcG9ydCBwb3BwZXJPZmZzZXRzIGZyb20gXCIuL21vZGlmaWVycy9wb3BwZXJPZmZzZXRzLmpzXCI7XG5pbXBvcnQgY29tcHV0ZVN0eWxlcyBmcm9tIFwiLi9tb2RpZmllcnMvY29tcHV0ZVN0eWxlcy5qc1wiO1xuaW1wb3J0IGFwcGx5U3R5bGVzIGZyb20gXCIuL21vZGlmaWVycy9hcHBseVN0eWxlcy5qc1wiO1xuaW1wb3J0IG9mZnNldCBmcm9tIFwiLi9tb2RpZmllcnMvb2Zmc2V0LmpzXCI7XG5pbXBvcnQgZmxpcCBmcm9tIFwiLi9tb2RpZmllcnMvZmxpcC5qc1wiO1xuaW1wb3J0IHByZXZlbnRPdmVyZmxvdyBmcm9tIFwiLi9tb2RpZmllcnMvcHJldmVudE92ZXJmbG93LmpzXCI7XG5pbXBvcnQgYXJyb3cgZnJvbSBcIi4vbW9kaWZpZXJzL2Fycm93LmpzXCI7XG5pbXBvcnQgaGlkZSBmcm9tIFwiLi9tb2RpZmllcnMvaGlkZS5qc1wiO1xudmFyIGRlZmF1bHRNb2RpZmllcnMgPSBbZXZlbnRMaXN0ZW5lcnMsIHBvcHBlck9mZnNldHMsIGNvbXB1dGVTdHlsZXMsIGFwcGx5U3R5bGVzLCBvZmZzZXQsIGZsaXAsIHByZXZlbnRPdmVyZmxvdywgYXJyb3csIGhpZGVdO1xudmFyIGNyZWF0ZVBvcHBlciA9IC8qI19fUFVSRV9fKi9wb3BwZXJHZW5lcmF0b3Ioe1xuICBkZWZhdWx0TW9kaWZpZXJzOiBkZWZhdWx0TW9kaWZpZXJzXG59KTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5leHBvcnQgeyBjcmVhdGVQb3BwZXIsIHBvcHBlckdlbmVyYXRvciwgZGVmYXVsdE1vZGlmaWVycywgZGV0ZWN0T3ZlcmZsb3cgfTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5leHBvcnQgeyBjcmVhdGVQb3BwZXIgYXMgY3JlYXRlUG9wcGVyTGl0ZSB9IGZyb20gXCIuL3BvcHBlci1saXRlLmpzXCI7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuZXhwb3J0ICogZnJvbSBcIi4vbW9kaWZpZXJzL2luZGV4LmpzXCI7IiwiLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQm9vdHN0cmFwICh2NS4wLjIpOiBkcm9wZG93bi5qc1xuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbmltcG9ydCAqIGFzIFBvcHBlciBmcm9tICdAcG9wcGVyanMvY29yZSdcblxuaW1wb3J0IHtcbiAgZGVmaW5lSlF1ZXJ5UGx1Z2luLFxuICBnZXRFbGVtZW50LFxuICBnZXRFbGVtZW50RnJvbVNlbGVjdG9yLFxuICBpc0Rpc2FibGVkLFxuICBpc0VsZW1lbnQsXG4gIGlzVmlzaWJsZSxcbiAgaXNSVEwsXG4gIG5vb3AsXG4gIGdldE5leHRBY3RpdmVFbGVtZW50LFxuICB0eXBlQ2hlY2tDb25maWdcbn0gZnJvbSAnLi91dGlsL2luZGV4J1xuaW1wb3J0IEV2ZW50SGFuZGxlciBmcm9tICcuL2RvbS9ldmVudC1oYW5kbGVyJ1xuaW1wb3J0IE1hbmlwdWxhdG9yIGZyb20gJy4vZG9tL21hbmlwdWxhdG9yJ1xuaW1wb3J0IFNlbGVjdG9yRW5naW5lIGZyb20gJy4vZG9tL3NlbGVjdG9yLWVuZ2luZSdcbmltcG9ydCBCYXNlQ29tcG9uZW50IGZyb20gJy4vYmFzZS1jb21wb25lbnQnXG5cbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb25zdGFudHNcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbmNvbnN0IE5BTUUgPSAnZHJvcGRvd24nXG5jb25zdCBEQVRBX0tFWSA9ICdicy5kcm9wZG93bidcbmNvbnN0IEVWRU5UX0tFWSA9IGAuJHtEQVRBX0tFWX1gXG5jb25zdCBEQVRBX0FQSV9LRVkgPSAnLmRhdGEtYXBpJ1xuXG5jb25zdCBFU0NBUEVfS0VZID0gJ0VzY2FwZSdcbmNvbnN0IFNQQUNFX0tFWSA9ICdTcGFjZSdcbmNvbnN0IFRBQl9LRVkgPSAnVGFiJ1xuY29uc3QgQVJST1dfVVBfS0VZID0gJ0Fycm93VXAnXG5jb25zdCBBUlJPV19ET1dOX0tFWSA9ICdBcnJvd0Rvd24nXG5jb25zdCBSSUdIVF9NT1VTRV9CVVRUT04gPSAyIC8vIE1vdXNlRXZlbnQuYnV0dG9uIHZhbHVlIGZvciB0aGUgc2Vjb25kYXJ5IGJ1dHRvbiwgdXN1YWxseSB0aGUgcmlnaHQgYnV0dG9uXG5cbmNvbnN0IFJFR0VYUF9LRVlET1dOID0gbmV3IFJlZ0V4cChgJHtBUlJPV19VUF9LRVl9fCR7QVJST1dfRE9XTl9LRVl9fCR7RVNDQVBFX0tFWX1gKVxuXG5jb25zdCBFVkVOVF9ISURFID0gYGhpZGUke0VWRU5UX0tFWX1gXG5jb25zdCBFVkVOVF9ISURERU4gPSBgaGlkZGVuJHtFVkVOVF9LRVl9YFxuY29uc3QgRVZFTlRfU0hPVyA9IGBzaG93JHtFVkVOVF9LRVl9YFxuY29uc3QgRVZFTlRfU0hPV04gPSBgc2hvd24ke0VWRU5UX0tFWX1gXG5jb25zdCBFVkVOVF9DTElDSyA9IGBjbGljayR7RVZFTlRfS0VZfWBcbmNvbnN0IEVWRU5UX0NMSUNLX0RBVEFfQVBJID0gYGNsaWNrJHtFVkVOVF9LRVl9JHtEQVRBX0FQSV9LRVl9YFxuY29uc3QgRVZFTlRfS0VZRE9XTl9EQVRBX0FQSSA9IGBrZXlkb3duJHtFVkVOVF9LRVl9JHtEQVRBX0FQSV9LRVl9YFxuY29uc3QgRVZFTlRfS0VZVVBfREFUQV9BUEkgPSBga2V5dXAke0VWRU5UX0tFWX0ke0RBVEFfQVBJX0tFWX1gXG5cbmNvbnN0IENMQVNTX05BTUVfU0hPVyA9ICdzaG93J1xuY29uc3QgQ0xBU1NfTkFNRV9EUk9QVVAgPSAnZHJvcHVwJ1xuY29uc3QgQ0xBU1NfTkFNRV9EUk9QRU5EID0gJ2Ryb3BlbmQnXG5jb25zdCBDTEFTU19OQU1FX0RST1BTVEFSVCA9ICdkcm9wc3RhcnQnXG5jb25zdCBDTEFTU19OQU1FX05BVkJBUiA9ICduYXZiYXInXG5cbmNvbnN0IFNFTEVDVE9SX0RBVEFfVE9HR0xFID0gJ1tkYXRhLWJzLXRvZ2dsZT1cImRyb3Bkb3duXCJdJ1xuY29uc3QgU0VMRUNUT1JfTUVOVSA9ICcuZHJvcGRvd24tbWVudSdcbmNvbnN0IFNFTEVDVE9SX05BVkJBUl9OQVYgPSAnLm5hdmJhci1uYXYnXG5jb25zdCBTRUxFQ1RPUl9WSVNJQkxFX0lURU1TID0gJy5kcm9wZG93bi1tZW51IC5kcm9wZG93bi1pdGVtOm5vdCguZGlzYWJsZWQpOm5vdCg6ZGlzYWJsZWQpJ1xuXG5jb25zdCBQTEFDRU1FTlRfVE9QID0gaXNSVEwoKSA/ICd0b3AtZW5kJyA6ICd0b3Atc3RhcnQnXG5jb25zdCBQTEFDRU1FTlRfVE9QRU5EID0gaXNSVEwoKSA/ICd0b3Atc3RhcnQnIDogJ3RvcC1lbmQnXG5jb25zdCBQTEFDRU1FTlRfQk9UVE9NID0gaXNSVEwoKSA/ICdib3R0b20tZW5kJyA6ICdib3R0b20tc3RhcnQnXG5jb25zdCBQTEFDRU1FTlRfQk9UVE9NRU5EID0gaXNSVEwoKSA/ICdib3R0b20tc3RhcnQnIDogJ2JvdHRvbS1lbmQnXG5jb25zdCBQTEFDRU1FTlRfUklHSFQgPSBpc1JUTCgpID8gJ2xlZnQtc3RhcnQnIDogJ3JpZ2h0LXN0YXJ0J1xuY29uc3QgUExBQ0VNRU5UX0xFRlQgPSBpc1JUTCgpID8gJ3JpZ2h0LXN0YXJ0JyA6ICdsZWZ0LXN0YXJ0J1xuXG5jb25zdCBEZWZhdWx0ID0ge1xuICBvZmZzZXQ6IFswLCAyXSxcbiAgYm91bmRhcnk6ICdjbGlwcGluZ1BhcmVudHMnLFxuICByZWZlcmVuY2U6ICd0b2dnbGUnLFxuICBkaXNwbGF5OiAnZHluYW1pYycsXG4gIHBvcHBlckNvbmZpZzogbnVsbCxcbiAgYXV0b0Nsb3NlOiB0cnVlXG59XG5cbmNvbnN0IERlZmF1bHRUeXBlID0ge1xuICBvZmZzZXQ6ICcoYXJyYXl8c3RyaW5nfGZ1bmN0aW9uKScsXG4gIGJvdW5kYXJ5OiAnKHN0cmluZ3xlbGVtZW50KScsXG4gIHJlZmVyZW5jZTogJyhzdHJpbmd8ZWxlbWVudHxvYmplY3QpJyxcbiAgZGlzcGxheTogJ3N0cmluZycsXG4gIHBvcHBlckNvbmZpZzogJyhudWxsfG9iamVjdHxmdW5jdGlvbiknLFxuICBhdXRvQ2xvc2U6ICcoYm9vbGVhbnxzdHJpbmcpJ1xufVxuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ2xhc3MgRGVmaW5pdGlvblxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuY2xhc3MgRHJvcGRvd24gZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IoZWxlbWVudCwgY29uZmlnKSB7XG4gICAgc3VwZXIoZWxlbWVudClcblxuICAgIHRoaXMuX3BvcHBlciA9IG51bGxcbiAgICB0aGlzLl9jb25maWcgPSB0aGlzLl9nZXRDb25maWcoY29uZmlnKVxuICAgIHRoaXMuX21lbnUgPSB0aGlzLl9nZXRNZW51RWxlbWVudCgpXG4gICAgdGhpcy5faW5OYXZiYXIgPSB0aGlzLl9kZXRlY3ROYXZiYXIoKVxuXG4gICAgdGhpcy5fYWRkRXZlbnRMaXN0ZW5lcnMoKVxuICB9XG5cbiAgLy8gR2V0dGVyc1xuXG4gIHN0YXRpYyBnZXQgRGVmYXVsdCgpIHtcbiAgICByZXR1cm4gRGVmYXVsdFxuICB9XG5cbiAgc3RhdGljIGdldCBEZWZhdWx0VHlwZSgpIHtcbiAgICByZXR1cm4gRGVmYXVsdFR5cGVcbiAgfVxuXG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICByZXR1cm4gTkFNRVxuICB9XG5cbiAgLy8gUHVibGljXG5cbiAgdG9nZ2xlKCkge1xuICAgIGlmIChpc0Rpc2FibGVkKHRoaXMuX2VsZW1lbnQpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCBpc0FjdGl2ZSA9IHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfU0hPVylcblxuICAgIGlmIChpc0FjdGl2ZSkge1xuICAgICAgdGhpcy5oaWRlKClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMuc2hvdygpXG4gIH1cblxuICBzaG93KCkge1xuICAgIGlmIChpc0Rpc2FibGVkKHRoaXMuX2VsZW1lbnQpIHx8IHRoaXMuX21lbnUuY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfU0hPVykpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IHBhcmVudCA9IERyb3Bkb3duLmdldFBhcmVudEZyb21FbGVtZW50KHRoaXMuX2VsZW1lbnQpXG4gICAgY29uc3QgcmVsYXRlZFRhcmdldCA9IHtcbiAgICAgIHJlbGF0ZWRUYXJnZXQ6IHRoaXMuX2VsZW1lbnRcbiAgICB9XG5cbiAgICBjb25zdCBzaG93RXZlbnQgPSBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9TSE9XLCByZWxhdGVkVGFyZ2V0KVxuXG4gICAgaWYgKHNob3dFdmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBUb3RhbGx5IGRpc2FibGUgUG9wcGVyIGZvciBEcm9wZG93bnMgaW4gTmF2YmFyXG4gICAgaWYgKHRoaXMuX2luTmF2YmFyKSB7XG4gICAgICBNYW5pcHVsYXRvci5zZXREYXRhQXR0cmlidXRlKHRoaXMuX21lbnUsICdwb3BwZXInLCAnbm9uZScpXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0eXBlb2YgUG9wcGVyID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdCb290c3RyYXBcXCdzIGRyb3Bkb3ducyByZXF1aXJlIFBvcHBlciAoaHR0cHM6Ly9wb3BwZXIuanMub3JnKScpXG4gICAgICB9XG5cbiAgICAgIGxldCByZWZlcmVuY2VFbGVtZW50ID0gdGhpcy5fZWxlbWVudFxuXG4gICAgICBpZiAodGhpcy5fY29uZmlnLnJlZmVyZW5jZSA9PT0gJ3BhcmVudCcpIHtcbiAgICAgICAgcmVmZXJlbmNlRWxlbWVudCA9IHBhcmVudFxuICAgICAgfSBlbHNlIGlmIChpc0VsZW1lbnQodGhpcy5fY29uZmlnLnJlZmVyZW5jZSkpIHtcbiAgICAgICAgcmVmZXJlbmNlRWxlbWVudCA9IGdldEVsZW1lbnQodGhpcy5fY29uZmlnLnJlZmVyZW5jZSlcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHRoaXMuX2NvbmZpZy5yZWZlcmVuY2UgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJlZmVyZW5jZUVsZW1lbnQgPSB0aGlzLl9jb25maWcucmVmZXJlbmNlXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHBvcHBlckNvbmZpZyA9IHRoaXMuX2dldFBvcHBlckNvbmZpZygpXG4gICAgICBjb25zdCBpc0Rpc3BsYXlTdGF0aWMgPSBwb3BwZXJDb25maWcubW9kaWZpZXJzLmZpbmQobW9kaWZpZXIgPT4gbW9kaWZpZXIubmFtZSA9PT0gJ2FwcGx5U3R5bGVzJyAmJiBtb2RpZmllci5lbmFibGVkID09PSBmYWxzZSlcblxuICAgICAgdGhpcy5fcG9wcGVyID0gUG9wcGVyLmNyZWF0ZVBvcHBlcihyZWZlcmVuY2VFbGVtZW50LCB0aGlzLl9tZW51LCBwb3BwZXJDb25maWcpXG5cbiAgICAgIGlmIChpc0Rpc3BsYXlTdGF0aWMpIHtcbiAgICAgICAgTWFuaXB1bGF0b3Iuc2V0RGF0YUF0dHJpYnV0ZSh0aGlzLl9tZW51LCAncG9wcGVyJywgJ3N0YXRpYycpXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgdGhpcyBpcyBhIHRvdWNoLWVuYWJsZWQgZGV2aWNlIHdlIGFkZCBleHRyYVxuICAgIC8vIGVtcHR5IG1vdXNlb3ZlciBsaXN0ZW5lcnMgdG8gdGhlIGJvZHkncyBpbW1lZGlhdGUgY2hpbGRyZW47XG4gICAgLy8gb25seSBuZWVkZWQgYmVjYXVzZSBvZiBicm9rZW4gZXZlbnQgZGVsZWdhdGlvbiBvbiBpT1NcbiAgICAvLyBodHRwczovL3d3dy5xdWlya3Ntb2RlLm9yZy9ibG9nL2FyY2hpdmVzLzIwMTQvMDIvbW91c2VfZXZlbnRfYnViLmh0bWxcbiAgICBpZiAoJ29udG91Y2hzdGFydCcgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICYmXG4gICAgICAhcGFyZW50LmNsb3Nlc3QoU0VMRUNUT1JfTkFWQkFSX05BVikpIHtcbiAgICAgIFtdLmNvbmNhdCguLi5kb2N1bWVudC5ib2R5LmNoaWxkcmVuKVxuICAgICAgICAuZm9yRWFjaChlbGVtID0+IEV2ZW50SGFuZGxlci5vbihlbGVtLCAnbW91c2VvdmVyJywgbm9vcCkpXG4gICAgfVxuXG4gICAgdGhpcy5fZWxlbWVudC5mb2N1cygpXG4gICAgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtZXhwYW5kZWQnLCB0cnVlKVxuXG4gICAgdGhpcy5fbWVudS5jbGFzc0xpc3QudG9nZ2xlKENMQVNTX05BTUVfU0hPVylcbiAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC50b2dnbGUoQ0xBU1NfTkFNRV9TSE9XKVxuICAgIEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX1NIT1dOLCByZWxhdGVkVGFyZ2V0KVxuICB9XG5cbiAgaGlkZSgpIHtcbiAgICBpZiAoaXNEaXNhYmxlZCh0aGlzLl9lbGVtZW50KSB8fCAhdGhpcy5fbWVudS5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9TSE9XKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3QgcmVsYXRlZFRhcmdldCA9IHtcbiAgICAgIHJlbGF0ZWRUYXJnZXQ6IHRoaXMuX2VsZW1lbnRcbiAgICB9XG5cbiAgICB0aGlzLl9jb21wbGV0ZUhpZGUocmVsYXRlZFRhcmdldClcbiAgfVxuXG4gIGRpc3Bvc2UoKSB7XG4gICAgaWYgKHRoaXMuX3BvcHBlcikge1xuICAgICAgdGhpcy5fcG9wcGVyLmRlc3Ryb3koKVxuICAgIH1cblxuICAgIHN1cGVyLmRpc3Bvc2UoKVxuICB9XG5cbiAgdXBkYXRlKCkge1xuICAgIHRoaXMuX2luTmF2YmFyID0gdGhpcy5fZGV0ZWN0TmF2YmFyKClcbiAgICBpZiAodGhpcy5fcG9wcGVyKSB7XG4gICAgICB0aGlzLl9wb3BwZXIudXBkYXRlKClcbiAgICB9XG4gIH1cblxuICAvLyBQcml2YXRlXG5cbiAgX2FkZEV2ZW50TGlzdGVuZXJzKCkge1xuICAgIEV2ZW50SGFuZGxlci5vbih0aGlzLl9lbGVtZW50LCBFVkVOVF9DTElDSywgZXZlbnQgPT4ge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKVxuICAgICAgdGhpcy50b2dnbGUoKVxuICAgIH0pXG4gIH1cblxuICBfY29tcGxldGVIaWRlKHJlbGF0ZWRUYXJnZXQpIHtcbiAgICBjb25zdCBoaWRlRXZlbnQgPSBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9ISURFLCByZWxhdGVkVGFyZ2V0KVxuICAgIGlmIChoaWRlRXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gSWYgdGhpcyBpcyBhIHRvdWNoLWVuYWJsZWQgZGV2aWNlIHdlIHJlbW92ZSB0aGUgZXh0cmFcbiAgICAvLyBlbXB0eSBtb3VzZW92ZXIgbGlzdGVuZXJzIHdlIGFkZGVkIGZvciBpT1Mgc3VwcG9ydFxuICAgIGlmICgnb250b3VjaHN0YXJ0JyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpIHtcbiAgICAgIFtdLmNvbmNhdCguLi5kb2N1bWVudC5ib2R5LmNoaWxkcmVuKVxuICAgICAgICAuZm9yRWFjaChlbGVtID0+IEV2ZW50SGFuZGxlci5vZmYoZWxlbSwgJ21vdXNlb3ZlcicsIG5vb3ApKVxuICAgIH1cblxuICAgIGlmICh0aGlzLl9wb3BwZXIpIHtcbiAgICAgIHRoaXMuX3BvcHBlci5kZXN0cm95KClcbiAgICB9XG5cbiAgICB0aGlzLl9tZW51LmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9TSE9XKVxuICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19OQU1FX1NIT1cpXG4gICAgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtZXhwYW5kZWQnLCAnZmFsc2UnKVxuICAgIE1hbmlwdWxhdG9yLnJlbW92ZURhdGFBdHRyaWJ1dGUodGhpcy5fbWVudSwgJ3BvcHBlcicpXG4gICAgRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfSElEREVOLCByZWxhdGVkVGFyZ2V0KVxuICB9XG5cbiAgX2dldENvbmZpZyhjb25maWcpIHtcbiAgICBjb25maWcgPSB7XG4gICAgICAuLi50aGlzLmNvbnN0cnVjdG9yLkRlZmF1bHQsXG4gICAgICAuLi5NYW5pcHVsYXRvci5nZXREYXRhQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KSxcbiAgICAgIC4uLmNvbmZpZ1xuICAgIH1cblxuICAgIHR5cGVDaGVja0NvbmZpZyhOQU1FLCBjb25maWcsIHRoaXMuY29uc3RydWN0b3IuRGVmYXVsdFR5cGUpXG5cbiAgICBpZiAodHlwZW9mIGNvbmZpZy5yZWZlcmVuY2UgPT09ICdvYmplY3QnICYmICFpc0VsZW1lbnQoY29uZmlnLnJlZmVyZW5jZSkgJiZcbiAgICAgIHR5cGVvZiBjb25maWcucmVmZXJlbmNlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCAhPT0gJ2Z1bmN0aW9uJ1xuICAgICkge1xuICAgICAgLy8gUG9wcGVyIHZpcnR1YWwgZWxlbWVudHMgcmVxdWlyZSBhIGdldEJvdW5kaW5nQ2xpZW50UmVjdCBtZXRob2RcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYCR7TkFNRS50b1VwcGVyQ2FzZSgpfTogT3B0aW9uIFwicmVmZXJlbmNlXCIgcHJvdmlkZWQgdHlwZSBcIm9iamVjdFwiIHdpdGhvdXQgYSByZXF1aXJlZCBcImdldEJvdW5kaW5nQ2xpZW50UmVjdFwiIG1ldGhvZC5gKVxuICAgIH1cblxuICAgIHJldHVybiBjb25maWdcbiAgfVxuXG4gIF9nZXRNZW51RWxlbWVudCgpIHtcbiAgICByZXR1cm4gU2VsZWN0b3JFbmdpbmUubmV4dCh0aGlzLl9lbGVtZW50LCBTRUxFQ1RPUl9NRU5VKVswXVxuICB9XG5cbiAgX2dldFBsYWNlbWVudCgpIHtcbiAgICBjb25zdCBwYXJlbnREcm9wZG93biA9IHRoaXMuX2VsZW1lbnQucGFyZW50Tm9kZVxuXG4gICAgaWYgKHBhcmVudERyb3Bkb3duLmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX0RST1BFTkQpKSB7XG4gICAgICByZXR1cm4gUExBQ0VNRU5UX1JJR0hUXG4gICAgfVxuXG4gICAgaWYgKHBhcmVudERyb3Bkb3duLmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX0RST1BTVEFSVCkpIHtcbiAgICAgIHJldHVybiBQTEFDRU1FTlRfTEVGVFxuICAgIH1cblxuICAgIC8vIFdlIG5lZWQgdG8gdHJpbSB0aGUgdmFsdWUgYmVjYXVzZSBjdXN0b20gcHJvcGVydGllcyBjYW4gYWxzbyBpbmNsdWRlIHNwYWNlc1xuICAgIGNvbnN0IGlzRW5kID0gZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLl9tZW51KS5nZXRQcm9wZXJ0eVZhbHVlKCctLWJzLXBvc2l0aW9uJykudHJpbSgpID09PSAnZW5kJ1xuXG4gICAgaWYgKHBhcmVudERyb3Bkb3duLmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX0RST1BVUCkpIHtcbiAgICAgIHJldHVybiBpc0VuZCA/IFBMQUNFTUVOVF9UT1BFTkQgOiBQTEFDRU1FTlRfVE9QXG4gICAgfVxuXG4gICAgcmV0dXJuIGlzRW5kID8gUExBQ0VNRU5UX0JPVFRPTUVORCA6IFBMQUNFTUVOVF9CT1RUT01cbiAgfVxuXG4gIF9kZXRlY3ROYXZiYXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2VsZW1lbnQuY2xvc2VzdChgLiR7Q0xBU1NfTkFNRV9OQVZCQVJ9YCkgIT09IG51bGxcbiAgfVxuXG4gIF9nZXRPZmZzZXQoKSB7XG4gICAgY29uc3QgeyBvZmZzZXQgfSA9IHRoaXMuX2NvbmZpZ1xuXG4gICAgaWYgKHR5cGVvZiBvZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gb2Zmc2V0LnNwbGl0KCcsJykubWFwKHZhbCA9PiBOdW1iZXIucGFyc2VJbnQodmFsLCAxMCkpXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBvZmZzZXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBwb3BwZXJEYXRhID0+IG9mZnNldChwb3BwZXJEYXRhLCB0aGlzLl9lbGVtZW50KVxuICAgIH1cblxuICAgIHJldHVybiBvZmZzZXRcbiAgfVxuXG4gIF9nZXRQb3BwZXJDb25maWcoKSB7XG4gICAgY29uc3QgZGVmYXVsdEJzUG9wcGVyQ29uZmlnID0ge1xuICAgICAgcGxhY2VtZW50OiB0aGlzLl9nZXRQbGFjZW1lbnQoKSxcbiAgICAgIG1vZGlmaWVyczogW3tcbiAgICAgICAgbmFtZTogJ3ByZXZlbnRPdmVyZmxvdycsXG4gICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICBib3VuZGFyeTogdGhpcy5fY29uZmlnLmJvdW5kYXJ5XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdvZmZzZXQnLFxuICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgb2Zmc2V0OiB0aGlzLl9nZXRPZmZzZXQoKVxuICAgICAgICB9XG4gICAgICB9XVxuICAgIH1cblxuICAgIC8vIERpc2FibGUgUG9wcGVyIGlmIHdlIGhhdmUgYSBzdGF0aWMgZGlzcGxheVxuICAgIGlmICh0aGlzLl9jb25maWcuZGlzcGxheSA9PT0gJ3N0YXRpYycpIHtcbiAgICAgIGRlZmF1bHRCc1BvcHBlckNvbmZpZy5tb2RpZmllcnMgPSBbe1xuICAgICAgICBuYW1lOiAnYXBwbHlTdHlsZXMnLFxuICAgICAgICBlbmFibGVkOiBmYWxzZVxuICAgICAgfV1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgLi4uZGVmYXVsdEJzUG9wcGVyQ29uZmlnLFxuICAgICAgLi4uKHR5cGVvZiB0aGlzLl9jb25maWcucG9wcGVyQ29uZmlnID09PSAnZnVuY3Rpb24nID8gdGhpcy5fY29uZmlnLnBvcHBlckNvbmZpZyhkZWZhdWx0QnNQb3BwZXJDb25maWcpIDogdGhpcy5fY29uZmlnLnBvcHBlckNvbmZpZylcbiAgICB9XG4gIH1cblxuICBfc2VsZWN0TWVudUl0ZW0oeyBrZXksIHRhcmdldCB9KSB7XG4gICAgY29uc3QgaXRlbXMgPSBTZWxlY3RvckVuZ2luZS5maW5kKFNFTEVDVE9SX1ZJU0lCTEVfSVRFTVMsIHRoaXMuX21lbnUpLmZpbHRlcihpc1Zpc2libGUpXG5cbiAgICBpZiAoIWl0ZW1zLmxlbmd0aCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gaWYgdGFyZ2V0IGlzbid0IGluY2x1ZGVkIGluIGl0ZW1zIChlLmcuIHdoZW4gZXhwYW5kaW5nIHRoZSBkcm9wZG93bilcbiAgICAvLyBhbGxvdyBjeWNsaW5nIHRvIGdldCB0aGUgbGFzdCBpdGVtIGluIGNhc2Uga2V5IGVxdWFscyBBUlJPV19VUF9LRVlcbiAgICBnZXROZXh0QWN0aXZlRWxlbWVudChpdGVtcywgdGFyZ2V0LCBrZXkgPT09IEFSUk9XX0RPV05fS0VZLCAhaXRlbXMuaW5jbHVkZXModGFyZ2V0KSkuZm9jdXMoKVxuICB9XG5cbiAgLy8gU3RhdGljXG5cbiAgc3RhdGljIGRyb3Bkb3duSW50ZXJmYWNlKGVsZW1lbnQsIGNvbmZpZykge1xuICAgIGNvbnN0IGRhdGEgPSBEcm9wZG93bi5nZXRPckNyZWF0ZUluc3RhbmNlKGVsZW1lbnQsIGNvbmZpZylcblxuICAgIGlmICh0eXBlb2YgY29uZmlnID09PSAnc3RyaW5nJykge1xuICAgICAgaWYgKHR5cGVvZiBkYXRhW2NvbmZpZ10gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcIiR7Y29uZmlnfVwiYClcbiAgICAgIH1cblxuICAgICAgZGF0YVtjb25maWddKClcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKGNvbmZpZykge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgRHJvcGRvd24uZHJvcGRvd25JbnRlcmZhY2UodGhpcywgY29uZmlnKVxuICAgIH0pXG4gIH1cblxuICBzdGF0aWMgY2xlYXJNZW51cyhldmVudCkge1xuICAgIGlmIChldmVudCAmJiAoZXZlbnQuYnV0dG9uID09PSBSSUdIVF9NT1VTRV9CVVRUT04gfHwgKGV2ZW50LnR5cGUgPT09ICdrZXl1cCcgJiYgZXZlbnQua2V5ICE9PSBUQUJfS0VZKSkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IHRvZ2dsZXMgPSBTZWxlY3RvckVuZ2luZS5maW5kKFNFTEVDVE9SX0RBVEFfVE9HR0xFKVxuXG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHRvZ2dsZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGNvbnN0IGNvbnRleHQgPSBEcm9wZG93bi5nZXRJbnN0YW5jZSh0b2dnbGVzW2ldKVxuICAgICAgaWYgKCFjb250ZXh0IHx8IGNvbnRleHQuX2NvbmZpZy5hdXRvQ2xvc2UgPT09IGZhbHNlKSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIGlmICghY29udGV4dC5fZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9TSE9XKSkge1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICBjb25zdCByZWxhdGVkVGFyZ2V0ID0ge1xuICAgICAgICByZWxhdGVkVGFyZ2V0OiBjb250ZXh0Ll9lbGVtZW50XG4gICAgICB9XG5cbiAgICAgIGlmIChldmVudCkge1xuICAgICAgICBjb25zdCBjb21wb3NlZFBhdGggPSBldmVudC5jb21wb3NlZFBhdGgoKVxuICAgICAgICBjb25zdCBpc01lbnVUYXJnZXQgPSBjb21wb3NlZFBhdGguaW5jbHVkZXMoY29udGV4dC5fbWVudSlcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGNvbXBvc2VkUGF0aC5pbmNsdWRlcyhjb250ZXh0Ll9lbGVtZW50KSB8fFxuICAgICAgICAgIChjb250ZXh0Ll9jb25maWcuYXV0b0Nsb3NlID09PSAnaW5zaWRlJyAmJiAhaXNNZW51VGFyZ2V0KSB8fFxuICAgICAgICAgIChjb250ZXh0Ll9jb25maWcuYXV0b0Nsb3NlID09PSAnb3V0c2lkZScgJiYgaXNNZW51VGFyZ2V0KVxuICAgICAgICApIHtcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGFiIG5hdmlnYXRpb24gdGhyb3VnaCB0aGUgZHJvcGRvd24gbWVudSBvciBldmVudHMgZnJvbSBjb250YWluZWQgaW5wdXRzIHNob3VsZG4ndCBjbG9zZSB0aGUgbWVudVxuICAgICAgICBpZiAoY29udGV4dC5fbWVudS5jb250YWlucyhldmVudC50YXJnZXQpICYmICgoZXZlbnQudHlwZSA9PT0gJ2tleXVwJyAmJiBldmVudC5rZXkgPT09IFRBQl9LRVkpIHx8IC9pbnB1dHxzZWxlY3R8b3B0aW9ufHRleHRhcmVhfGZvcm0vaS50ZXN0KGV2ZW50LnRhcmdldC50YWdOYW1lKSkpIHtcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV2ZW50LnR5cGUgPT09ICdjbGljaycpIHtcbiAgICAgICAgICByZWxhdGVkVGFyZ2V0LmNsaWNrRXZlbnQgPSBldmVudFxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnRleHQuX2NvbXBsZXRlSGlkZShyZWxhdGVkVGFyZ2V0KVxuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBnZXRQYXJlbnRGcm9tRWxlbWVudChlbGVtZW50KSB7XG4gICAgcmV0dXJuIGdldEVsZW1lbnRGcm9tU2VsZWN0b3IoZWxlbWVudCkgfHwgZWxlbWVudC5wYXJlbnROb2RlXG4gIH1cblxuICBzdGF0aWMgZGF0YUFwaUtleWRvd25IYW5kbGVyKGV2ZW50KSB7XG4gICAgLy8gSWYgbm90IGlucHV0L3RleHRhcmVhOlxuICAgIC8vICAtIEFuZCBub3QgYSBrZXkgaW4gUkVHRVhQX0tFWURPV04gPT4gbm90IGEgZHJvcGRvd24gY29tbWFuZFxuICAgIC8vIElmIGlucHV0L3RleHRhcmVhOlxuICAgIC8vICAtIElmIHNwYWNlIGtleSA9PiBub3QgYSBkcm9wZG93biBjb21tYW5kXG4gICAgLy8gIC0gSWYga2V5IGlzIG90aGVyIHRoYW4gZXNjYXBlXG4gICAgLy8gICAgLSBJZiBrZXkgaXMgbm90IHVwIG9yIGRvd24gPT4gbm90IGEgZHJvcGRvd24gY29tbWFuZFxuICAgIC8vICAgIC0gSWYgdHJpZ2dlciBpbnNpZGUgdGhlIG1lbnUgPT4gbm90IGEgZHJvcGRvd24gY29tbWFuZFxuICAgIGlmICgvaW5wdXR8dGV4dGFyZWEvaS50ZXN0KGV2ZW50LnRhcmdldC50YWdOYW1lKSA/XG4gICAgICBldmVudC5rZXkgPT09IFNQQUNFX0tFWSB8fCAoZXZlbnQua2V5ICE9PSBFU0NBUEVfS0VZICYmXG4gICAgICAoKGV2ZW50LmtleSAhPT0gQVJST1dfRE9XTl9LRVkgJiYgZXZlbnQua2V5ICE9PSBBUlJPV19VUF9LRVkpIHx8XG4gICAgICAgIGV2ZW50LnRhcmdldC5jbG9zZXN0KFNFTEVDVE9SX01FTlUpKSkgOlxuICAgICAgIVJFR0VYUF9LRVlET1dOLnRlc3QoZXZlbnQua2V5KSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3QgaXNBY3RpdmUgPSB0aGlzLmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX1NIT1cpXG5cbiAgICBpZiAoIWlzQWN0aXZlICYmIGV2ZW50LmtleSA9PT0gRVNDQVBFX0tFWSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKVxuICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpXG5cbiAgICBpZiAoaXNEaXNhYmxlZCh0aGlzKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3QgZ2V0VG9nZ2xlQnV0dG9uID0gKCkgPT4gdGhpcy5tYXRjaGVzKFNFTEVDVE9SX0RBVEFfVE9HR0xFKSA/IHRoaXMgOiBTZWxlY3RvckVuZ2luZS5wcmV2KHRoaXMsIFNFTEVDVE9SX0RBVEFfVE9HR0xFKVswXVxuXG4gICAgaWYgKGV2ZW50LmtleSA9PT0gRVNDQVBFX0tFWSkge1xuICAgICAgZ2V0VG9nZ2xlQnV0dG9uKCkuZm9jdXMoKVxuICAgICAgRHJvcGRvd24uY2xlYXJNZW51cygpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoZXZlbnQua2V5ID09PSBBUlJPV19VUF9LRVkgfHwgZXZlbnQua2V5ID09PSBBUlJPV19ET1dOX0tFWSkge1xuICAgICAgaWYgKCFpc0FjdGl2ZSkge1xuICAgICAgICBnZXRUb2dnbGVCdXR0b24oKS5jbGljaygpXG4gICAgICB9XG5cbiAgICAgIERyb3Bkb3duLmdldEluc3RhbmNlKGdldFRvZ2dsZUJ1dHRvbigpKS5fc2VsZWN0TWVudUl0ZW0oZXZlbnQpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoIWlzQWN0aXZlIHx8IGV2ZW50LmtleSA9PT0gU1BBQ0VfS0VZKSB7XG4gICAgICBEcm9wZG93bi5jbGVhck1lbnVzKClcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIERhdGEgQXBpIGltcGxlbWVudGF0aW9uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5FdmVudEhhbmRsZXIub24oZG9jdW1lbnQsIEVWRU5UX0tFWURPV05fREFUQV9BUEksIFNFTEVDVE9SX0RBVEFfVE9HR0xFLCBEcm9wZG93bi5kYXRhQXBpS2V5ZG93bkhhbmRsZXIpXG5FdmVudEhhbmRsZXIub24oZG9jdW1lbnQsIEVWRU5UX0tFWURPV05fREFUQV9BUEksIFNFTEVDVE9SX01FTlUsIERyb3Bkb3duLmRhdGFBcGlLZXlkb3duSGFuZGxlcilcbkV2ZW50SGFuZGxlci5vbihkb2N1bWVudCwgRVZFTlRfQ0xJQ0tfREFUQV9BUEksIERyb3Bkb3duLmNsZWFyTWVudXMpXG5FdmVudEhhbmRsZXIub24oZG9jdW1lbnQsIEVWRU5UX0tFWVVQX0RBVEFfQVBJLCBEcm9wZG93bi5jbGVhck1lbnVzKVxuRXZlbnRIYW5kbGVyLm9uKGRvY3VtZW50LCBFVkVOVF9DTElDS19EQVRBX0FQSSwgU0VMRUNUT1JfREFUQV9UT0dHTEUsIGZ1bmN0aW9uIChldmVudCkge1xuICBldmVudC5wcmV2ZW50RGVmYXVsdCgpXG4gIERyb3Bkb3duLmRyb3Bkb3duSW50ZXJmYWNlKHRoaXMpXG59KVxuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogalF1ZXJ5XG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIGFkZCAuRHJvcGRvd24gdG8galF1ZXJ5IG9ubHkgaWYgalF1ZXJ5IGlzIHByZXNlbnRcbiAqL1xuXG5kZWZpbmVKUXVlcnlQbHVnaW4oRHJvcGRvd24pXG5cbmV4cG9ydCBkZWZhdWx0IERyb3Bkb3duXG4iLCIvKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBCb290c3RyYXAgKHY1LjAuMik6IHV0aWwvc2Nyb2xsQmFyLmpzXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuaW1wb3J0IFNlbGVjdG9yRW5naW5lIGZyb20gJy4uL2RvbS9zZWxlY3Rvci1lbmdpbmUnXG5pbXBvcnQgTWFuaXB1bGF0b3IgZnJvbSAnLi4vZG9tL21hbmlwdWxhdG9yJ1xuaW1wb3J0IHsgaXNFbGVtZW50IH0gZnJvbSAnLi9pbmRleCdcblxuY29uc3QgU0VMRUNUT1JfRklYRURfQ09OVEVOVCA9ICcuZml4ZWQtdG9wLCAuZml4ZWQtYm90dG9tLCAuaXMtZml4ZWQsIC5zdGlja3ktdG9wJ1xuY29uc3QgU0VMRUNUT1JfU1RJQ0tZX0NPTlRFTlQgPSAnLnN0aWNreS10b3AnXG5cbmNsYXNzIFNjcm9sbEJhckhlbHBlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuX2VsZW1lbnQgPSBkb2N1bWVudC5ib2R5XG4gIH1cblxuICBnZXRXaWR0aCgpIHtcbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvV2luZG93L2lubmVyV2lkdGgjdXNhZ2Vfbm90ZXNcbiAgICBjb25zdCBkb2N1bWVudFdpZHRoID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoXG4gICAgcmV0dXJuIE1hdGguYWJzKHdpbmRvdy5pbm5lcldpZHRoIC0gZG9jdW1lbnRXaWR0aClcbiAgfVxuXG4gIGhpZGUoKSB7XG4gICAgY29uc3Qgd2lkdGggPSB0aGlzLmdldFdpZHRoKClcbiAgICB0aGlzLl9kaXNhYmxlT3ZlckZsb3coKVxuICAgIC8vIGdpdmUgcGFkZGluZyB0byBlbGVtZW50IHRvIGJhbGFuY2UgdGhlIGhpZGRlbiBzY3JvbGxiYXIgd2lkdGhcbiAgICB0aGlzLl9zZXRFbGVtZW50QXR0cmlidXRlcyh0aGlzLl9lbGVtZW50LCAncGFkZGluZ1JpZ2h0JywgY2FsY3VsYXRlZFZhbHVlID0+IGNhbGN1bGF0ZWRWYWx1ZSArIHdpZHRoKVxuICAgIC8vIHRyaWNrOiBXZSBhZGp1c3QgcG9zaXRpdmUgcGFkZGluZ1JpZ2h0IGFuZCBuZWdhdGl2ZSBtYXJnaW5SaWdodCB0byBzdGlja3ktdG9wIGVsZW1lbnRzIHRvIGtlZXAgc2hvd2luZyBmdWxsd2lkdGhcbiAgICB0aGlzLl9zZXRFbGVtZW50QXR0cmlidXRlcyhTRUxFQ1RPUl9GSVhFRF9DT05URU5ULCAncGFkZGluZ1JpZ2h0JywgY2FsY3VsYXRlZFZhbHVlID0+IGNhbGN1bGF0ZWRWYWx1ZSArIHdpZHRoKVxuICAgIHRoaXMuX3NldEVsZW1lbnRBdHRyaWJ1dGVzKFNFTEVDVE9SX1NUSUNLWV9DT05URU5ULCAnbWFyZ2luUmlnaHQnLCBjYWxjdWxhdGVkVmFsdWUgPT4gY2FsY3VsYXRlZFZhbHVlIC0gd2lkdGgpXG4gIH1cblxuICBfZGlzYWJsZU92ZXJGbG93KCkge1xuICAgIHRoaXMuX3NhdmVJbml0aWFsQXR0cmlidXRlKHRoaXMuX2VsZW1lbnQsICdvdmVyZmxvdycpXG4gICAgdGhpcy5fZWxlbWVudC5zdHlsZS5vdmVyZmxvdyA9ICdoaWRkZW4nXG4gIH1cblxuICBfc2V0RWxlbWVudEF0dHJpYnV0ZXMoc2VsZWN0b3IsIHN0eWxlUHJvcCwgY2FsbGJhY2spIHtcbiAgICBjb25zdCBzY3JvbGxiYXJXaWR0aCA9IHRoaXMuZ2V0V2lkdGgoKVxuICAgIGNvbnN0IG1hbmlwdWxhdGlvbkNhbGxCYWNrID0gZWxlbWVudCA9PiB7XG4gICAgICBpZiAoZWxlbWVudCAhPT0gdGhpcy5fZWxlbWVudCAmJiB3aW5kb3cuaW5uZXJXaWR0aCA+IGVsZW1lbnQuY2xpZW50V2lkdGggKyBzY3JvbGxiYXJXaWR0aCkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgdGhpcy5fc2F2ZUluaXRpYWxBdHRyaWJ1dGUoZWxlbWVudCwgc3R5bGVQcm9wKVxuICAgICAgY29uc3QgY2FsY3VsYXRlZFZhbHVlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudClbc3R5bGVQcm9wXVxuICAgICAgZWxlbWVudC5zdHlsZVtzdHlsZVByb3BdID0gYCR7Y2FsbGJhY2soTnVtYmVyLnBhcnNlRmxvYXQoY2FsY3VsYXRlZFZhbHVlKSl9cHhgXG4gICAgfVxuXG4gICAgdGhpcy5fYXBwbHlNYW5pcHVsYXRpb25DYWxsYmFjayhzZWxlY3RvciwgbWFuaXB1bGF0aW9uQ2FsbEJhY2spXG4gIH1cblxuICByZXNldCgpIHtcbiAgICB0aGlzLl9yZXNldEVsZW1lbnRBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQsICdvdmVyZmxvdycpXG4gICAgdGhpcy5fcmVzZXRFbGVtZW50QXR0cmlidXRlcyh0aGlzLl9lbGVtZW50LCAncGFkZGluZ1JpZ2h0JylcbiAgICB0aGlzLl9yZXNldEVsZW1lbnRBdHRyaWJ1dGVzKFNFTEVDVE9SX0ZJWEVEX0NPTlRFTlQsICdwYWRkaW5nUmlnaHQnKVxuICAgIHRoaXMuX3Jlc2V0RWxlbWVudEF0dHJpYnV0ZXMoU0VMRUNUT1JfU1RJQ0tZX0NPTlRFTlQsICdtYXJnaW5SaWdodCcpXG4gIH1cblxuICBfc2F2ZUluaXRpYWxBdHRyaWJ1dGUoZWxlbWVudCwgc3R5bGVQcm9wKSB7XG4gICAgY29uc3QgYWN0dWFsVmFsdWUgPSBlbGVtZW50LnN0eWxlW3N0eWxlUHJvcF1cbiAgICBpZiAoYWN0dWFsVmFsdWUpIHtcbiAgICAgIE1hbmlwdWxhdG9yLnNldERhdGFBdHRyaWJ1dGUoZWxlbWVudCwgc3R5bGVQcm9wLCBhY3R1YWxWYWx1ZSlcbiAgICB9XG4gIH1cblxuICBfcmVzZXRFbGVtZW50QXR0cmlidXRlcyhzZWxlY3Rvciwgc3R5bGVQcm9wKSB7XG4gICAgY29uc3QgbWFuaXB1bGF0aW9uQ2FsbEJhY2sgPSBlbGVtZW50ID0+IHtcbiAgICAgIGNvbnN0IHZhbHVlID0gTWFuaXB1bGF0b3IuZ2V0RGF0YUF0dHJpYnV0ZShlbGVtZW50LCBzdHlsZVByb3ApXG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBlbGVtZW50LnN0eWxlLnJlbW92ZVByb3BlcnR5KHN0eWxlUHJvcClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIE1hbmlwdWxhdG9yLnJlbW92ZURhdGFBdHRyaWJ1dGUoZWxlbWVudCwgc3R5bGVQcm9wKVxuICAgICAgICBlbGVtZW50LnN0eWxlW3N0eWxlUHJvcF0gPSB2YWx1ZVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX2FwcGx5TWFuaXB1bGF0aW9uQ2FsbGJhY2soc2VsZWN0b3IsIG1hbmlwdWxhdGlvbkNhbGxCYWNrKVxuICB9XG5cbiAgX2FwcGx5TWFuaXB1bGF0aW9uQ2FsbGJhY2soc2VsZWN0b3IsIGNhbGxCYWNrKSB7XG4gICAgaWYgKGlzRWxlbWVudChzZWxlY3RvcikpIHtcbiAgICAgIGNhbGxCYWNrKHNlbGVjdG9yKVxuICAgIH0gZWxzZSB7XG4gICAgICBTZWxlY3RvckVuZ2luZS5maW5kKHNlbGVjdG9yLCB0aGlzLl9lbGVtZW50KS5mb3JFYWNoKGNhbGxCYWNrKVxuICAgIH1cbiAgfVxuXG4gIGlzT3ZlcmZsb3dpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0V2lkdGgoKSA+IDBcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBTY3JvbGxCYXJIZWxwZXJcbiIsIi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEJvb3RzdHJhcCAodjUuMC4yKTogdXRpbC9iYWNrZHJvcC5qc1xuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYXN0ZXIvTElDRU5TRSlcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuaW1wb3J0IEV2ZW50SGFuZGxlciBmcm9tICcuLi9kb20vZXZlbnQtaGFuZGxlcidcbmltcG9ydCB7IGV4ZWN1dGUsIGV4ZWN1dGVBZnRlclRyYW5zaXRpb24sIGdldEVsZW1lbnQsIHJlZmxvdywgdHlwZUNoZWNrQ29uZmlnIH0gZnJvbSAnLi9pbmRleCdcblxuY29uc3QgRGVmYXVsdCA9IHtcbiAgaXNWaXNpYmxlOiB0cnVlLCAvLyBpZiBmYWxzZSwgd2UgdXNlIHRoZSBiYWNrZHJvcCBoZWxwZXIgd2l0aG91dCBhZGRpbmcgYW55IGVsZW1lbnQgdG8gdGhlIGRvbVxuICBpc0FuaW1hdGVkOiBmYWxzZSxcbiAgcm9vdEVsZW1lbnQ6ICdib2R5JywgLy8gZ2l2ZSB0aGUgY2hvaWNlIHRvIHBsYWNlIGJhY2tkcm9wIHVuZGVyIGRpZmZlcmVudCBlbGVtZW50c1xuICBjbGlja0NhbGxiYWNrOiBudWxsXG59XG5cbmNvbnN0IERlZmF1bHRUeXBlID0ge1xuICBpc1Zpc2libGU6ICdib29sZWFuJyxcbiAgaXNBbmltYXRlZDogJ2Jvb2xlYW4nLFxuICByb290RWxlbWVudDogJyhlbGVtZW50fHN0cmluZyknLFxuICBjbGlja0NhbGxiYWNrOiAnKGZ1bmN0aW9ufG51bGwpJ1xufVxuY29uc3QgTkFNRSA9ICdiYWNrZHJvcCdcbmNvbnN0IENMQVNTX05BTUVfQkFDS0RST1AgPSAnbW9kYWwtYmFja2Ryb3AnXG5jb25zdCBDTEFTU19OQU1FX0ZBREUgPSAnZmFkZSdcbmNvbnN0IENMQVNTX05BTUVfU0hPVyA9ICdzaG93J1xuXG5jb25zdCBFVkVOVF9NT1VTRURPV04gPSBgbW91c2Vkb3duLmJzLiR7TkFNRX1gXG5cbmNsYXNzIEJhY2tkcm9wIHtcbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgdGhpcy5fY29uZmlnID0gdGhpcy5fZ2V0Q29uZmlnKGNvbmZpZylcbiAgICB0aGlzLl9pc0FwcGVuZGVkID0gZmFsc2VcbiAgICB0aGlzLl9lbGVtZW50ID0gbnVsbFxuICB9XG5cbiAgc2hvdyhjYWxsYmFjaykge1xuICAgIGlmICghdGhpcy5fY29uZmlnLmlzVmlzaWJsZSkge1xuICAgICAgZXhlY3V0ZShjYWxsYmFjaylcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMuX2FwcGVuZCgpXG5cbiAgICBpZiAodGhpcy5fY29uZmlnLmlzQW5pbWF0ZWQpIHtcbiAgICAgIHJlZmxvdyh0aGlzLl9nZXRFbGVtZW50KCkpXG4gICAgfVxuXG4gICAgdGhpcy5fZ2V0RWxlbWVudCgpLmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9TSE9XKVxuXG4gICAgdGhpcy5fZW11bGF0ZUFuaW1hdGlvbigoKSA9PiB7XG4gICAgICBleGVjdXRlKGNhbGxiYWNrKVxuICAgIH0pXG4gIH1cblxuICBoaWRlKGNhbGxiYWNrKSB7XG4gICAgaWYgKCF0aGlzLl9jb25maWcuaXNWaXNpYmxlKSB7XG4gICAgICBleGVjdXRlKGNhbGxiYWNrKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdGhpcy5fZ2V0RWxlbWVudCgpLmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9TSE9XKVxuXG4gICAgdGhpcy5fZW11bGF0ZUFuaW1hdGlvbigoKSA9PiB7XG4gICAgICB0aGlzLmRpc3Bvc2UoKVxuICAgICAgZXhlY3V0ZShjYWxsYmFjaylcbiAgICB9KVxuICB9XG5cbiAgLy8gUHJpdmF0ZVxuXG4gIF9nZXRFbGVtZW50KCkge1xuICAgIGlmICghdGhpcy5fZWxlbWVudCkge1xuICAgICAgY29uc3QgYmFja2Ryb3AgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICAgICAgYmFja2Ryb3AuY2xhc3NOYW1lID0gQ0xBU1NfTkFNRV9CQUNLRFJPUFxuICAgICAgaWYgKHRoaXMuX2NvbmZpZy5pc0FuaW1hdGVkKSB7XG4gICAgICAgIGJhY2tkcm9wLmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9GQURFKVxuICAgICAgfVxuXG4gICAgICB0aGlzLl9lbGVtZW50ID0gYmFja2Ryb3BcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fZWxlbWVudFxuICB9XG5cbiAgX2dldENvbmZpZyhjb25maWcpIHtcbiAgICBjb25maWcgPSB7XG4gICAgICAuLi5EZWZhdWx0LFxuICAgICAgLi4uKHR5cGVvZiBjb25maWcgPT09ICdvYmplY3QnID8gY29uZmlnIDoge30pXG4gICAgfVxuXG4gICAgLy8gdXNlIGdldEVsZW1lbnQoKSB3aXRoIHRoZSBkZWZhdWx0IFwiYm9keVwiIHRvIGdldCBhIGZyZXNoIEVsZW1lbnQgb24gZWFjaCBpbnN0YW50aWF0aW9uXG4gICAgY29uZmlnLnJvb3RFbGVtZW50ID0gZ2V0RWxlbWVudChjb25maWcucm9vdEVsZW1lbnQpXG4gICAgdHlwZUNoZWNrQ29uZmlnKE5BTUUsIGNvbmZpZywgRGVmYXVsdFR5cGUpXG4gICAgcmV0dXJuIGNvbmZpZ1xuICB9XG5cbiAgX2FwcGVuZCgpIHtcbiAgICBpZiAodGhpcy5faXNBcHBlbmRlZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdGhpcy5fY29uZmlnLnJvb3RFbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuX2dldEVsZW1lbnQoKSlcblxuICAgIEV2ZW50SGFuZGxlci5vbih0aGlzLl9nZXRFbGVtZW50KCksIEVWRU5UX01PVVNFRE9XTiwgKCkgPT4ge1xuICAgICAgZXhlY3V0ZSh0aGlzLl9jb25maWcuY2xpY2tDYWxsYmFjaylcbiAgICB9KVxuXG4gICAgdGhpcy5faXNBcHBlbmRlZCA9IHRydWVcbiAgfVxuXG4gIGRpc3Bvc2UoKSB7XG4gICAgaWYgKCF0aGlzLl9pc0FwcGVuZGVkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBFdmVudEhhbmRsZXIub2ZmKHRoaXMuX2VsZW1lbnQsIEVWRU5UX01PVVNFRE9XTilcblxuICAgIHRoaXMuX2VsZW1lbnQucmVtb3ZlKClcbiAgICB0aGlzLl9pc0FwcGVuZGVkID0gZmFsc2VcbiAgfVxuXG4gIF9lbXVsYXRlQW5pbWF0aW9uKGNhbGxiYWNrKSB7XG4gICAgZXhlY3V0ZUFmdGVyVHJhbnNpdGlvbihjYWxsYmFjaywgdGhpcy5fZ2V0RWxlbWVudCgpLCB0aGlzLl9jb25maWcuaXNBbmltYXRlZClcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBCYWNrZHJvcFxuIiwiLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQm9vdHN0cmFwICh2NS4wLjIpOiBtb2RhbC5qc1xuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbmltcG9ydCB7XG4gIGRlZmluZUpRdWVyeVBsdWdpbixcbiAgZ2V0RWxlbWVudEZyb21TZWxlY3RvcixcbiAgaXNSVEwsXG4gIGlzVmlzaWJsZSxcbiAgcmVmbG93LFxuICB0eXBlQ2hlY2tDb25maWdcbn0gZnJvbSAnLi91dGlsL2luZGV4J1xuaW1wb3J0IEV2ZW50SGFuZGxlciBmcm9tICcuL2RvbS9ldmVudC1oYW5kbGVyJ1xuaW1wb3J0IE1hbmlwdWxhdG9yIGZyb20gJy4vZG9tL21hbmlwdWxhdG9yJ1xuaW1wb3J0IFNlbGVjdG9yRW5naW5lIGZyb20gJy4vZG9tL3NlbGVjdG9yLWVuZ2luZSdcbmltcG9ydCBTY3JvbGxCYXJIZWxwZXIgZnJvbSAnLi91dGlsL3Njcm9sbGJhcidcbmltcG9ydCBCYXNlQ29tcG9uZW50IGZyb20gJy4vYmFzZS1jb21wb25lbnQnXG5pbXBvcnQgQmFja2Ryb3AgZnJvbSAnLi91dGlsL2JhY2tkcm9wJ1xuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29uc3RhbnRzXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5jb25zdCBOQU1FID0gJ21vZGFsJ1xuY29uc3QgREFUQV9LRVkgPSAnYnMubW9kYWwnXG5jb25zdCBFVkVOVF9LRVkgPSBgLiR7REFUQV9LRVl9YFxuY29uc3QgREFUQV9BUElfS0VZID0gJy5kYXRhLWFwaSdcbmNvbnN0IEVTQ0FQRV9LRVkgPSAnRXNjYXBlJ1xuXG5jb25zdCBEZWZhdWx0ID0ge1xuICBiYWNrZHJvcDogdHJ1ZSxcbiAga2V5Ym9hcmQ6IHRydWUsXG4gIGZvY3VzOiB0cnVlXG59XG5cbmNvbnN0IERlZmF1bHRUeXBlID0ge1xuICBiYWNrZHJvcDogJyhib29sZWFufHN0cmluZyknLFxuICBrZXlib2FyZDogJ2Jvb2xlYW4nLFxuICBmb2N1czogJ2Jvb2xlYW4nXG59XG5cbmNvbnN0IEVWRU5UX0hJREUgPSBgaGlkZSR7RVZFTlRfS0VZfWBcbmNvbnN0IEVWRU5UX0hJREVfUFJFVkVOVEVEID0gYGhpZGVQcmV2ZW50ZWQke0VWRU5UX0tFWX1gXG5jb25zdCBFVkVOVF9ISURERU4gPSBgaGlkZGVuJHtFVkVOVF9LRVl9YFxuY29uc3QgRVZFTlRfU0hPVyA9IGBzaG93JHtFVkVOVF9LRVl9YFxuY29uc3QgRVZFTlRfU0hPV04gPSBgc2hvd24ke0VWRU5UX0tFWX1gXG5jb25zdCBFVkVOVF9GT0NVU0lOID0gYGZvY3VzaW4ke0VWRU5UX0tFWX1gXG5jb25zdCBFVkVOVF9SRVNJWkUgPSBgcmVzaXplJHtFVkVOVF9LRVl9YFxuY29uc3QgRVZFTlRfQ0xJQ0tfRElTTUlTUyA9IGBjbGljay5kaXNtaXNzJHtFVkVOVF9LRVl9YFxuY29uc3QgRVZFTlRfS0VZRE9XTl9ESVNNSVNTID0gYGtleWRvd24uZGlzbWlzcyR7RVZFTlRfS0VZfWBcbmNvbnN0IEVWRU5UX01PVVNFVVBfRElTTUlTUyA9IGBtb3VzZXVwLmRpc21pc3Mke0VWRU5UX0tFWX1gXG5jb25zdCBFVkVOVF9NT1VTRURPV05fRElTTUlTUyA9IGBtb3VzZWRvd24uZGlzbWlzcyR7RVZFTlRfS0VZfWBcbmNvbnN0IEVWRU5UX0NMSUNLX0RBVEFfQVBJID0gYGNsaWNrJHtFVkVOVF9LRVl9JHtEQVRBX0FQSV9LRVl9YFxuXG5jb25zdCBDTEFTU19OQU1FX09QRU4gPSAnbW9kYWwtb3BlbidcbmNvbnN0IENMQVNTX05BTUVfRkFERSA9ICdmYWRlJ1xuY29uc3QgQ0xBU1NfTkFNRV9TSE9XID0gJ3Nob3cnXG5jb25zdCBDTEFTU19OQU1FX1NUQVRJQyA9ICdtb2RhbC1zdGF0aWMnXG5cbmNvbnN0IFNFTEVDVE9SX0RJQUxPRyA9ICcubW9kYWwtZGlhbG9nJ1xuY29uc3QgU0VMRUNUT1JfTU9EQUxfQk9EWSA9ICcubW9kYWwtYm9keSdcbmNvbnN0IFNFTEVDVE9SX0RBVEFfVE9HR0xFID0gJ1tkYXRhLWJzLXRvZ2dsZT1cIm1vZGFsXCJdJ1xuY29uc3QgU0VMRUNUT1JfREFUQV9ESVNNSVNTID0gJ1tkYXRhLWJzLWRpc21pc3M9XCJtb2RhbFwiXSdcblxuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENsYXNzIERlZmluaXRpb25cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbmNsYXNzIE1vZGFsIGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKGVsZW1lbnQsIGNvbmZpZykge1xuICAgIHN1cGVyKGVsZW1lbnQpXG5cbiAgICB0aGlzLl9jb25maWcgPSB0aGlzLl9nZXRDb25maWcoY29uZmlnKVxuICAgIHRoaXMuX2RpYWxvZyA9IFNlbGVjdG9yRW5naW5lLmZpbmRPbmUoU0VMRUNUT1JfRElBTE9HLCB0aGlzLl9lbGVtZW50KVxuICAgIHRoaXMuX2JhY2tkcm9wID0gdGhpcy5faW5pdGlhbGl6ZUJhY2tEcm9wKClcbiAgICB0aGlzLl9pc1Nob3duID0gZmFsc2VcbiAgICB0aGlzLl9pZ25vcmVCYWNrZHJvcENsaWNrID0gZmFsc2VcbiAgICB0aGlzLl9pc1RyYW5zaXRpb25pbmcgPSBmYWxzZVxuICAgIHRoaXMuX3Njcm9sbEJhciA9IG5ldyBTY3JvbGxCYXJIZWxwZXIoKVxuICB9XG5cbiAgLy8gR2V0dGVyc1xuXG4gIHN0YXRpYyBnZXQgRGVmYXVsdCgpIHtcbiAgICByZXR1cm4gRGVmYXVsdFxuICB9XG5cbiAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgIHJldHVybiBOQU1FXG4gIH1cblxuICAvLyBQdWJsaWNcblxuICB0b2dnbGUocmVsYXRlZFRhcmdldCkge1xuICAgIHJldHVybiB0aGlzLl9pc1Nob3duID8gdGhpcy5oaWRlKCkgOiB0aGlzLnNob3cocmVsYXRlZFRhcmdldClcbiAgfVxuXG4gIHNob3cocmVsYXRlZFRhcmdldCkge1xuICAgIGlmICh0aGlzLl9pc1Nob3duIHx8IHRoaXMuX2lzVHJhbnNpdGlvbmluZykge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3Qgc2hvd0V2ZW50ID0gRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfU0hPVywge1xuICAgICAgcmVsYXRlZFRhcmdldFxuICAgIH0pXG5cbiAgICBpZiAoc2hvd0V2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMuX2lzU2hvd24gPSB0cnVlXG5cbiAgICBpZiAodGhpcy5faXNBbmltYXRlZCgpKSB7XG4gICAgICB0aGlzLl9pc1RyYW5zaXRpb25pbmcgPSB0cnVlXG4gICAgfVxuXG4gICAgdGhpcy5fc2Nyb2xsQmFyLmhpZGUoKVxuXG4gICAgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfT1BFTilcblxuICAgIHRoaXMuX2FkanVzdERpYWxvZygpXG5cbiAgICB0aGlzLl9zZXRFc2NhcGVFdmVudCgpXG4gICAgdGhpcy5fc2V0UmVzaXplRXZlbnQoKVxuXG4gICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0NMSUNLX0RJU01JU1MsIFNFTEVDVE9SX0RBVEFfRElTTUlTUywgZXZlbnQgPT4gdGhpcy5oaWRlKGV2ZW50KSlcblxuICAgIEV2ZW50SGFuZGxlci5vbih0aGlzLl9kaWFsb2csIEVWRU5UX01PVVNFRE9XTl9ESVNNSVNTLCAoKSA9PiB7XG4gICAgICBFdmVudEhhbmRsZXIub25lKHRoaXMuX2VsZW1lbnQsIEVWRU5UX01PVVNFVVBfRElTTUlTUywgZXZlbnQgPT4ge1xuICAgICAgICBpZiAoZXZlbnQudGFyZ2V0ID09PSB0aGlzLl9lbGVtZW50KSB7XG4gICAgICAgICAgdGhpcy5faWdub3JlQmFja2Ryb3BDbGljayA9IHRydWVcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9KVxuXG4gICAgdGhpcy5fc2hvd0JhY2tkcm9wKCgpID0+IHRoaXMuX3Nob3dFbGVtZW50KHJlbGF0ZWRUYXJnZXQpKVxuICB9XG5cbiAgaGlkZShldmVudCkge1xuICAgIGlmIChldmVudCAmJiBbJ0EnLCAnQVJFQSddLmluY2x1ZGVzKGV2ZW50LnRhcmdldC50YWdOYW1lKSkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKVxuICAgIH1cblxuICAgIGlmICghdGhpcy5faXNTaG93biB8fCB0aGlzLl9pc1RyYW5zaXRpb25pbmcpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IGhpZGVFdmVudCA9IEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0hJREUpXG5cbiAgICBpZiAoaGlkZUV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMuX2lzU2hvd24gPSBmYWxzZVxuICAgIGNvbnN0IGlzQW5pbWF0ZWQgPSB0aGlzLl9pc0FuaW1hdGVkKClcblxuICAgIGlmIChpc0FuaW1hdGVkKSB7XG4gICAgICB0aGlzLl9pc1RyYW5zaXRpb25pbmcgPSB0cnVlXG4gICAgfVxuXG4gICAgdGhpcy5fc2V0RXNjYXBlRXZlbnQoKVxuICAgIHRoaXMuX3NldFJlc2l6ZUV2ZW50KClcblxuICAgIEV2ZW50SGFuZGxlci5vZmYoZG9jdW1lbnQsIEVWRU5UX0ZPQ1VTSU4pXG5cbiAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9TSE9XKVxuXG4gICAgRXZlbnRIYW5kbGVyLm9mZih0aGlzLl9lbGVtZW50LCBFVkVOVF9DTElDS19ESVNNSVNTKVxuICAgIEV2ZW50SGFuZGxlci5vZmYodGhpcy5fZGlhbG9nLCBFVkVOVF9NT1VTRURPV05fRElTTUlTUylcblxuICAgIHRoaXMuX3F1ZXVlQ2FsbGJhY2soKCkgPT4gdGhpcy5faGlkZU1vZGFsKCksIHRoaXMuX2VsZW1lbnQsIGlzQW5pbWF0ZWQpXG4gIH1cblxuICBkaXNwb3NlKCkge1xuICAgIFt3aW5kb3csIHRoaXMuX2RpYWxvZ11cbiAgICAgIC5mb3JFYWNoKGh0bWxFbGVtZW50ID0+IEV2ZW50SGFuZGxlci5vZmYoaHRtbEVsZW1lbnQsIEVWRU5UX0tFWSkpXG5cbiAgICB0aGlzLl9iYWNrZHJvcC5kaXNwb3NlKClcbiAgICBzdXBlci5kaXNwb3NlKClcblxuICAgIC8qKlxuICAgICAqIGBkb2N1bWVudGAgaGFzIDIgZXZlbnRzIGBFVkVOVF9GT0NVU0lOYCBhbmQgYEVWRU5UX0NMSUNLX0RBVEFfQVBJYFxuICAgICAqIERvIG5vdCBtb3ZlIGBkb2N1bWVudGAgaW4gYGh0bWxFbGVtZW50c2AgYXJyYXlcbiAgICAgKiBJdCB3aWxsIHJlbW92ZSBgRVZFTlRfQ0xJQ0tfREFUQV9BUElgIGV2ZW50IHRoYXQgc2hvdWxkIHJlbWFpblxuICAgICAqL1xuICAgIEV2ZW50SGFuZGxlci5vZmYoZG9jdW1lbnQsIEVWRU5UX0ZPQ1VTSU4pXG4gIH1cblxuICBoYW5kbGVVcGRhdGUoKSB7XG4gICAgdGhpcy5fYWRqdXN0RGlhbG9nKClcbiAgfVxuXG4gIC8vIFByaXZhdGVcblxuICBfaW5pdGlhbGl6ZUJhY2tEcm9wKCkge1xuICAgIHJldHVybiBuZXcgQmFja2Ryb3Aoe1xuICAgICAgaXNWaXNpYmxlOiBCb29sZWFuKHRoaXMuX2NvbmZpZy5iYWNrZHJvcCksIC8vICdzdGF0aWMnIG9wdGlvbiB3aWxsIGJlIHRyYW5zbGF0ZWQgdG8gdHJ1ZSwgYW5kIGJvb2xlYW5zIHdpbGwga2VlcCB0aGVpciB2YWx1ZVxuICAgICAgaXNBbmltYXRlZDogdGhpcy5faXNBbmltYXRlZCgpXG4gICAgfSlcbiAgfVxuXG4gIF9nZXRDb25maWcoY29uZmlnKSB7XG4gICAgY29uZmlnID0ge1xuICAgICAgLi4uRGVmYXVsdCxcbiAgICAgIC4uLk1hbmlwdWxhdG9yLmdldERhdGFBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpLFxuICAgICAgLi4uKHR5cGVvZiBjb25maWcgPT09ICdvYmplY3QnID8gY29uZmlnIDoge30pXG4gICAgfVxuICAgIHR5cGVDaGVja0NvbmZpZyhOQU1FLCBjb25maWcsIERlZmF1bHRUeXBlKVxuICAgIHJldHVybiBjb25maWdcbiAgfVxuXG4gIF9zaG93RWxlbWVudChyZWxhdGVkVGFyZ2V0KSB7XG4gICAgY29uc3QgaXNBbmltYXRlZCA9IHRoaXMuX2lzQW5pbWF0ZWQoKVxuICAgIGNvbnN0IG1vZGFsQm9keSA9IFNlbGVjdG9yRW5naW5lLmZpbmRPbmUoU0VMRUNUT1JfTU9EQUxfQk9EWSwgdGhpcy5fZGlhbG9nKVxuXG4gICAgaWYgKCF0aGlzLl9lbGVtZW50LnBhcmVudE5vZGUgfHwgdGhpcy5fZWxlbWVudC5wYXJlbnROb2RlLm5vZGVUeXBlICE9PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgLy8gRG9uJ3QgbW92ZSBtb2RhbCdzIERPTSBwb3NpdGlvblxuICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLl9lbGVtZW50KVxuICAgIH1cblxuICAgIHRoaXMuX2VsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdibG9jaydcbiAgICB0aGlzLl9lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nKVxuICAgIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLW1vZGFsJywgdHJ1ZSlcbiAgICB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZSgncm9sZScsICdkaWFsb2cnKVxuICAgIHRoaXMuX2VsZW1lbnQuc2Nyb2xsVG9wID0gMFxuXG4gICAgaWYgKG1vZGFsQm9keSkge1xuICAgICAgbW9kYWxCb2R5LnNjcm9sbFRvcCA9IDBcbiAgICB9XG5cbiAgICBpZiAoaXNBbmltYXRlZCkge1xuICAgICAgcmVmbG93KHRoaXMuX2VsZW1lbnQpXG4gICAgfVxuXG4gICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfU0hPVylcblxuICAgIGlmICh0aGlzLl9jb25maWcuZm9jdXMpIHtcbiAgICAgIHRoaXMuX2VuZm9yY2VGb2N1cygpXG4gICAgfVxuXG4gICAgY29uc3QgdHJhbnNpdGlvbkNvbXBsZXRlID0gKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuX2NvbmZpZy5mb2N1cykge1xuICAgICAgICB0aGlzLl9lbGVtZW50LmZvY3VzKClcbiAgICAgIH1cblxuICAgICAgdGhpcy5faXNUcmFuc2l0aW9uaW5nID0gZmFsc2VcbiAgICAgIEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX1NIT1dOLCB7XG4gICAgICAgIHJlbGF0ZWRUYXJnZXRcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgdGhpcy5fcXVldWVDYWxsYmFjayh0cmFuc2l0aW9uQ29tcGxldGUsIHRoaXMuX2RpYWxvZywgaXNBbmltYXRlZClcbiAgfVxuXG4gIF9lbmZvcmNlRm9jdXMoKSB7XG4gICAgRXZlbnRIYW5kbGVyLm9mZihkb2N1bWVudCwgRVZFTlRfRk9DVVNJTikgLy8gZ3VhcmQgYWdhaW5zdCBpbmZpbml0ZSBmb2N1cyBsb29wXG4gICAgRXZlbnRIYW5kbGVyLm9uKGRvY3VtZW50LCBFVkVOVF9GT0NVU0lOLCBldmVudCA9PiB7XG4gICAgICBpZiAoZG9jdW1lbnQgIT09IGV2ZW50LnRhcmdldCAmJlxuICAgICAgICAgIHRoaXMuX2VsZW1lbnQgIT09IGV2ZW50LnRhcmdldCAmJlxuICAgICAgICAgICF0aGlzLl9lbGVtZW50LmNvbnRhaW5zKGV2ZW50LnRhcmdldCkpIHtcbiAgICAgICAgdGhpcy5fZWxlbWVudC5mb2N1cygpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIF9zZXRFc2NhcGVFdmVudCgpIHtcbiAgICBpZiAodGhpcy5faXNTaG93bikge1xuICAgICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0tFWURPV05fRElTTUlTUywgZXZlbnQgPT4ge1xuICAgICAgICBpZiAodGhpcy5fY29uZmlnLmtleWJvYXJkICYmIGV2ZW50LmtleSA9PT0gRVNDQVBFX0tFWSkge1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KClcbiAgICAgICAgICB0aGlzLmhpZGUoKVxuICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLl9jb25maWcua2V5Ym9hcmQgJiYgZXZlbnQua2V5ID09PSBFU0NBUEVfS0VZKSB7XG4gICAgICAgICAgdGhpcy5fdHJpZ2dlckJhY2tkcm9wVHJhbnNpdGlvbigpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIEV2ZW50SGFuZGxlci5vZmYodGhpcy5fZWxlbWVudCwgRVZFTlRfS0VZRE9XTl9ESVNNSVNTKVxuICAgIH1cbiAgfVxuXG4gIF9zZXRSZXNpemVFdmVudCgpIHtcbiAgICBpZiAodGhpcy5faXNTaG93bikge1xuICAgICAgRXZlbnRIYW5kbGVyLm9uKHdpbmRvdywgRVZFTlRfUkVTSVpFLCAoKSA9PiB0aGlzLl9hZGp1c3REaWFsb2coKSlcbiAgICB9IGVsc2Uge1xuICAgICAgRXZlbnRIYW5kbGVyLm9mZih3aW5kb3csIEVWRU5UX1JFU0laRSlcbiAgICB9XG4gIH1cblxuICBfaGlkZU1vZGFsKCkge1xuICAgIHRoaXMuX2VsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdub25lJ1xuICAgIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLWhpZGRlbicsIHRydWUpXG4gICAgdGhpcy5fZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtbW9kYWwnKVxuICAgIHRoaXMuX2VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdyb2xlJylcbiAgICB0aGlzLl9pc1RyYW5zaXRpb25pbmcgPSBmYWxzZVxuICAgIHRoaXMuX2JhY2tkcm9wLmhpZGUoKCkgPT4ge1xuICAgICAgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfT1BFTilcbiAgICAgIHRoaXMuX3Jlc2V0QWRqdXN0bWVudHMoKVxuICAgICAgdGhpcy5fc2Nyb2xsQmFyLnJlc2V0KClcbiAgICAgIEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0hJRERFTilcbiAgICB9KVxuICB9XG5cbiAgX3Nob3dCYWNrZHJvcChjYWxsYmFjaykge1xuICAgIEV2ZW50SGFuZGxlci5vbih0aGlzLl9lbGVtZW50LCBFVkVOVF9DTElDS19ESVNNSVNTLCBldmVudCA9PiB7XG4gICAgICBpZiAodGhpcy5faWdub3JlQmFja2Ryb3BDbGljaykge1xuICAgICAgICB0aGlzLl9pZ25vcmVCYWNrZHJvcENsaWNrID0gZmFsc2VcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGlmIChldmVudC50YXJnZXQgIT09IGV2ZW50LmN1cnJlbnRUYXJnZXQpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9jb25maWcuYmFja2Ryb3AgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5oaWRlKClcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fY29uZmlnLmJhY2tkcm9wID09PSAnc3RhdGljJykge1xuICAgICAgICB0aGlzLl90cmlnZ2VyQmFja2Ryb3BUcmFuc2l0aW9uKClcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgdGhpcy5fYmFja2Ryb3Auc2hvdyhjYWxsYmFjaylcbiAgfVxuXG4gIF9pc0FuaW1hdGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX0ZBREUpXG4gIH1cblxuICBfdHJpZ2dlckJhY2tkcm9wVHJhbnNpdGlvbigpIHtcbiAgICBjb25zdCBoaWRlRXZlbnQgPSBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9ISURFX1BSRVZFTlRFRClcbiAgICBpZiAoaGlkZUV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IHsgY2xhc3NMaXN0LCBzY3JvbGxIZWlnaHQsIHN0eWxlIH0gPSB0aGlzLl9lbGVtZW50XG4gICAgY29uc3QgaXNNb2RhbE92ZXJmbG93aW5nID0gc2Nyb2xsSGVpZ2h0ID4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodFxuXG4gICAgLy8gcmV0dXJuIGlmIHRoZSBmb2xsb3dpbmcgYmFja2dyb3VuZCB0cmFuc2l0aW9uIGhhc24ndCB5ZXQgY29tcGxldGVkXG4gICAgaWYgKCghaXNNb2RhbE92ZXJmbG93aW5nICYmIHN0eWxlLm92ZXJmbG93WSA9PT0gJ2hpZGRlbicpIHx8IGNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX1NUQVRJQykpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmICghaXNNb2RhbE92ZXJmbG93aW5nKSB7XG4gICAgICBzdHlsZS5vdmVyZmxvd1kgPSAnaGlkZGVuJ1xuICAgIH1cblxuICAgIGNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9TVEFUSUMpXG4gICAgdGhpcy5fcXVldWVDYWxsYmFjaygoKSA9PiB7XG4gICAgICBjbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfU1RBVElDKVxuICAgICAgaWYgKCFpc01vZGFsT3ZlcmZsb3dpbmcpIHtcbiAgICAgICAgdGhpcy5fcXVldWVDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgICAgc3R5bGUub3ZlcmZsb3dZID0gJydcbiAgICAgICAgfSwgdGhpcy5fZGlhbG9nKVxuICAgICAgfVxuICAgIH0sIHRoaXMuX2RpYWxvZylcblxuICAgIHRoaXMuX2VsZW1lbnQuZm9jdXMoKVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyB0aGUgZm9sbG93aW5nIG1ldGhvZHMgYXJlIHVzZWQgdG8gaGFuZGxlIG92ZXJmbG93aW5nIG1vZGFsc1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgX2FkanVzdERpYWxvZygpIHtcbiAgICBjb25zdCBpc01vZGFsT3ZlcmZsb3dpbmcgPSB0aGlzLl9lbGVtZW50LnNjcm9sbEhlaWdodCA+IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHRcbiAgICBjb25zdCBzY3JvbGxiYXJXaWR0aCA9IHRoaXMuX3Njcm9sbEJhci5nZXRXaWR0aCgpXG4gICAgY29uc3QgaXNCb2R5T3ZlcmZsb3dpbmcgPSBzY3JvbGxiYXJXaWR0aCA+IDBcblxuICAgIGlmICgoIWlzQm9keU92ZXJmbG93aW5nICYmIGlzTW9kYWxPdmVyZmxvd2luZyAmJiAhaXNSVEwoKSkgfHwgKGlzQm9keU92ZXJmbG93aW5nICYmICFpc01vZGFsT3ZlcmZsb3dpbmcgJiYgaXNSVEwoKSkpIHtcbiAgICAgIHRoaXMuX2VsZW1lbnQuc3R5bGUucGFkZGluZ0xlZnQgPSBgJHtzY3JvbGxiYXJXaWR0aH1weGBcbiAgICB9XG5cbiAgICBpZiAoKGlzQm9keU92ZXJmbG93aW5nICYmICFpc01vZGFsT3ZlcmZsb3dpbmcgJiYgIWlzUlRMKCkpIHx8ICghaXNCb2R5T3ZlcmZsb3dpbmcgJiYgaXNNb2RhbE92ZXJmbG93aW5nICYmIGlzUlRMKCkpKSB7XG4gICAgICB0aGlzLl9lbGVtZW50LnN0eWxlLnBhZGRpbmdSaWdodCA9IGAke3Njcm9sbGJhcldpZHRofXB4YFxuICAgIH1cbiAgfVxuXG4gIF9yZXNldEFkanVzdG1lbnRzKCkge1xuICAgIHRoaXMuX2VsZW1lbnQuc3R5bGUucGFkZGluZ0xlZnQgPSAnJ1xuICAgIHRoaXMuX2VsZW1lbnQuc3R5bGUucGFkZGluZ1JpZ2h0ID0gJydcbiAgfVxuXG4gIC8vIFN0YXRpY1xuXG4gIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UoY29uZmlnLCByZWxhdGVkVGFyZ2V0KSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICBjb25zdCBkYXRhID0gTW9kYWwuZ2V0T3JDcmVhdGVJbnN0YW5jZSh0aGlzLCBjb25maWcpXG5cbiAgICAgIGlmICh0eXBlb2YgY29uZmlnICE9PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBkYXRhW2NvbmZpZ10gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcIiR7Y29uZmlnfVwiYClcbiAgICAgIH1cblxuICAgICAgZGF0YVtjb25maWddKHJlbGF0ZWRUYXJnZXQpXG4gICAgfSlcbiAgfVxufVxuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogRGF0YSBBcGkgaW1wbGVtZW50YXRpb25cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbkV2ZW50SGFuZGxlci5vbihkb2N1bWVudCwgRVZFTlRfQ0xJQ0tfREFUQV9BUEksIFNFTEVDVE9SX0RBVEFfVE9HR0xFLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgY29uc3QgdGFyZ2V0ID0gZ2V0RWxlbWVudEZyb21TZWxlY3Rvcih0aGlzKVxuXG4gIGlmIChbJ0EnLCAnQVJFQSddLmluY2x1ZGVzKHRoaXMudGFnTmFtZSkpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpXG4gIH1cblxuICBFdmVudEhhbmRsZXIub25lKHRhcmdldCwgRVZFTlRfU0hPVywgc2hvd0V2ZW50ID0+IHtcbiAgICBpZiAoc2hvd0V2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgIC8vIG9ubHkgcmVnaXN0ZXIgZm9jdXMgcmVzdG9yZXIgaWYgbW9kYWwgd2lsbCBhY3R1YWxseSBnZXQgc2hvd25cbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIEV2ZW50SGFuZGxlci5vbmUodGFyZ2V0LCBFVkVOVF9ISURERU4sICgpID0+IHtcbiAgICAgIGlmIChpc1Zpc2libGUodGhpcykpIHtcbiAgICAgICAgdGhpcy5mb2N1cygpXG4gICAgICB9XG4gICAgfSlcbiAgfSlcblxuICBjb25zdCBkYXRhID0gTW9kYWwuZ2V0T3JDcmVhdGVJbnN0YW5jZSh0YXJnZXQpXG5cbiAgZGF0YS50b2dnbGUodGhpcylcbn0pXG5cbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBqUXVlcnlcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogYWRkIC5Nb2RhbCB0byBqUXVlcnkgb25seSBpZiBqUXVlcnkgaXMgcHJlc2VudFxuICovXG5cbmRlZmluZUpRdWVyeVBsdWdpbihNb2RhbClcblxuZXhwb3J0IGRlZmF1bHQgTW9kYWxcbiIsIi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEJvb3RzdHJhcCAodjUuMC4yKTogb2ZmY2FudmFzLmpzXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21hc3Rlci9MSUNFTlNFKVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5pbXBvcnQge1xuICBkZWZpbmVKUXVlcnlQbHVnaW4sXG4gIGdldEVsZW1lbnRGcm9tU2VsZWN0b3IsXG4gIGlzRGlzYWJsZWQsXG4gIGlzVmlzaWJsZSxcbiAgdHlwZUNoZWNrQ29uZmlnXG59IGZyb20gJy4vdXRpbC9pbmRleCdcbmltcG9ydCBTY3JvbGxCYXJIZWxwZXIgZnJvbSAnLi91dGlsL3Njcm9sbGJhcidcbmltcG9ydCBFdmVudEhhbmRsZXIgZnJvbSAnLi9kb20vZXZlbnQtaGFuZGxlcidcbmltcG9ydCBCYXNlQ29tcG9uZW50IGZyb20gJy4vYmFzZS1jb21wb25lbnQnXG5pbXBvcnQgU2VsZWN0b3JFbmdpbmUgZnJvbSAnLi9kb20vc2VsZWN0b3ItZW5naW5lJ1xuaW1wb3J0IE1hbmlwdWxhdG9yIGZyb20gJy4vZG9tL21hbmlwdWxhdG9yJ1xuaW1wb3J0IEJhY2tkcm9wIGZyb20gJy4vdXRpbC9iYWNrZHJvcCdcblxuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvbnN0YW50c1xuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuY29uc3QgTkFNRSA9ICdvZmZjYW52YXMnXG5jb25zdCBEQVRBX0tFWSA9ICdicy5vZmZjYW52YXMnXG5jb25zdCBFVkVOVF9LRVkgPSBgLiR7REFUQV9LRVl9YFxuY29uc3QgREFUQV9BUElfS0VZID0gJy5kYXRhLWFwaSdcbmNvbnN0IEVWRU5UX0xPQURfREFUQV9BUEkgPSBgbG9hZCR7RVZFTlRfS0VZfSR7REFUQV9BUElfS0VZfWBcbmNvbnN0IEVTQ0FQRV9LRVkgPSAnRXNjYXBlJ1xuXG5jb25zdCBEZWZhdWx0ID0ge1xuICBiYWNrZHJvcDogdHJ1ZSxcbiAga2V5Ym9hcmQ6IHRydWUsXG4gIHNjcm9sbDogZmFsc2Vcbn1cblxuY29uc3QgRGVmYXVsdFR5cGUgPSB7XG4gIGJhY2tkcm9wOiAnYm9vbGVhbicsXG4gIGtleWJvYXJkOiAnYm9vbGVhbicsXG4gIHNjcm9sbDogJ2Jvb2xlYW4nXG59XG5cbmNvbnN0IENMQVNTX05BTUVfU0hPVyA9ICdzaG93J1xuY29uc3QgT1BFTl9TRUxFQ1RPUiA9ICcub2ZmY2FudmFzLnNob3cnXG5cbmNvbnN0IEVWRU5UX1NIT1cgPSBgc2hvdyR7RVZFTlRfS0VZfWBcbmNvbnN0IEVWRU5UX1NIT1dOID0gYHNob3duJHtFVkVOVF9LRVl9YFxuY29uc3QgRVZFTlRfSElERSA9IGBoaWRlJHtFVkVOVF9LRVl9YFxuY29uc3QgRVZFTlRfSElEREVOID0gYGhpZGRlbiR7RVZFTlRfS0VZfWBcbmNvbnN0IEVWRU5UX0ZPQ1VTSU4gPSBgZm9jdXNpbiR7RVZFTlRfS0VZfWBcbmNvbnN0IEVWRU5UX0NMSUNLX0RBVEFfQVBJID0gYGNsaWNrJHtFVkVOVF9LRVl9JHtEQVRBX0FQSV9LRVl9YFxuY29uc3QgRVZFTlRfQ0xJQ0tfRElTTUlTUyA9IGBjbGljay5kaXNtaXNzJHtFVkVOVF9LRVl9YFxuY29uc3QgRVZFTlRfS0VZRE9XTl9ESVNNSVNTID0gYGtleWRvd24uZGlzbWlzcyR7RVZFTlRfS0VZfWBcblxuY29uc3QgU0VMRUNUT1JfREFUQV9ESVNNSVNTID0gJ1tkYXRhLWJzLWRpc21pc3M9XCJvZmZjYW52YXNcIl0nXG5jb25zdCBTRUxFQ1RPUl9EQVRBX1RPR0dMRSA9ICdbZGF0YS1icy10b2dnbGU9XCJvZmZjYW52YXNcIl0nXG5cbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDbGFzcyBEZWZpbml0aW9uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5jbGFzcyBPZmZjYW52YXMgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IoZWxlbWVudCwgY29uZmlnKSB7XG4gICAgc3VwZXIoZWxlbWVudClcblxuICAgIHRoaXMuX2NvbmZpZyA9IHRoaXMuX2dldENvbmZpZyhjb25maWcpXG4gICAgdGhpcy5faXNTaG93biA9IGZhbHNlXG4gICAgdGhpcy5fYmFja2Ryb3AgPSB0aGlzLl9pbml0aWFsaXplQmFja0Ryb3AoKVxuICAgIHRoaXMuX2FkZEV2ZW50TGlzdGVuZXJzKClcbiAgfVxuXG4gIC8vIEdldHRlcnNcblxuICBzdGF0aWMgZ2V0IE5BTUUoKSB7XG4gICAgcmV0dXJuIE5BTUVcbiAgfVxuXG4gIHN0YXRpYyBnZXQgRGVmYXVsdCgpIHtcbiAgICByZXR1cm4gRGVmYXVsdFxuICB9XG5cbiAgLy8gUHVibGljXG5cbiAgdG9nZ2xlKHJlbGF0ZWRUYXJnZXQpIHtcbiAgICByZXR1cm4gdGhpcy5faXNTaG93biA/IHRoaXMuaGlkZSgpIDogdGhpcy5zaG93KHJlbGF0ZWRUYXJnZXQpXG4gIH1cblxuICBzaG93KHJlbGF0ZWRUYXJnZXQpIHtcbiAgICBpZiAodGhpcy5faXNTaG93bikge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3Qgc2hvd0V2ZW50ID0gRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfU0hPVywgeyByZWxhdGVkVGFyZ2V0IH0pXG5cbiAgICBpZiAoc2hvd0V2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMuX2lzU2hvd24gPSB0cnVlXG4gICAgdGhpcy5fZWxlbWVudC5zdHlsZS52aXNpYmlsaXR5ID0gJ3Zpc2libGUnXG5cbiAgICB0aGlzLl9iYWNrZHJvcC5zaG93KClcblxuICAgIGlmICghdGhpcy5fY29uZmlnLnNjcm9sbCkge1xuICAgICAgbmV3IFNjcm9sbEJhckhlbHBlcigpLmhpZGUoKVxuICAgICAgdGhpcy5fZW5mb3JjZUZvY3VzT25FbGVtZW50KHRoaXMuX2VsZW1lbnQpXG4gICAgfVxuXG4gICAgdGhpcy5fZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJylcbiAgICB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1tb2RhbCcsIHRydWUpXG4gICAgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAnZGlhbG9nJylcbiAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9TSE9XKVxuXG4gICAgY29uc3QgY29tcGxldGVDYWxsQmFjayA9ICgpID0+IHtcbiAgICAgIEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX1NIT1dOLCB7IHJlbGF0ZWRUYXJnZXQgfSlcbiAgICB9XG5cbiAgICB0aGlzLl9xdWV1ZUNhbGxiYWNrKGNvbXBsZXRlQ2FsbEJhY2ssIHRoaXMuX2VsZW1lbnQsIHRydWUpXG4gIH1cblxuICBoaWRlKCkge1xuICAgIGlmICghdGhpcy5faXNTaG93bikge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3QgaGlkZUV2ZW50ID0gRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfSElERSlcblxuICAgIGlmIChoaWRlRXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgRXZlbnRIYW5kbGVyLm9mZihkb2N1bWVudCwgRVZFTlRfRk9DVVNJTilcbiAgICB0aGlzLl9lbGVtZW50LmJsdXIoKVxuICAgIHRoaXMuX2lzU2hvd24gPSBmYWxzZVxuICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19OQU1FX1NIT1cpXG4gICAgdGhpcy5fYmFja2Ryb3AuaGlkZSgpXG5cbiAgICBjb25zdCBjb21wbGV0ZUNhbGxiYWNrID0gKCkgPT4ge1xuICAgICAgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJywgdHJ1ZSlcbiAgICAgIHRoaXMuX2VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdhcmlhLW1vZGFsJylcbiAgICAgIHRoaXMuX2VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdyb2xlJylcbiAgICAgIHRoaXMuX2VsZW1lbnQuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nXG5cbiAgICAgIGlmICghdGhpcy5fY29uZmlnLnNjcm9sbCkge1xuICAgICAgICBuZXcgU2Nyb2xsQmFySGVscGVyKCkucmVzZXQoKVxuICAgICAgfVxuXG4gICAgICBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9ISURERU4pXG4gICAgfVxuXG4gICAgdGhpcy5fcXVldWVDYWxsYmFjayhjb21wbGV0ZUNhbGxiYWNrLCB0aGlzLl9lbGVtZW50LCB0cnVlKVxuICB9XG5cbiAgZGlzcG9zZSgpIHtcbiAgICB0aGlzLl9iYWNrZHJvcC5kaXNwb3NlKClcbiAgICBzdXBlci5kaXNwb3NlKClcbiAgICBFdmVudEhhbmRsZXIub2ZmKGRvY3VtZW50LCBFVkVOVF9GT0NVU0lOKVxuICB9XG5cbiAgLy8gUHJpdmF0ZVxuXG4gIF9nZXRDb25maWcoY29uZmlnKSB7XG4gICAgY29uZmlnID0ge1xuICAgICAgLi4uRGVmYXVsdCxcbiAgICAgIC4uLk1hbmlwdWxhdG9yLmdldERhdGFBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpLFxuICAgICAgLi4uKHR5cGVvZiBjb25maWcgPT09ICdvYmplY3QnID8gY29uZmlnIDoge30pXG4gICAgfVxuICAgIHR5cGVDaGVja0NvbmZpZyhOQU1FLCBjb25maWcsIERlZmF1bHRUeXBlKVxuICAgIHJldHVybiBjb25maWdcbiAgfVxuXG4gIF9pbml0aWFsaXplQmFja0Ryb3AoKSB7XG4gICAgcmV0dXJuIG5ldyBCYWNrZHJvcCh7XG4gICAgICBpc1Zpc2libGU6IHRoaXMuX2NvbmZpZy5iYWNrZHJvcCxcbiAgICAgIGlzQW5pbWF0ZWQ6IHRydWUsXG4gICAgICByb290RWxlbWVudDogdGhpcy5fZWxlbWVudC5wYXJlbnROb2RlLFxuICAgICAgY2xpY2tDYWxsYmFjazogKCkgPT4gdGhpcy5oaWRlKClcbiAgICB9KVxuICB9XG5cbiAgX2VuZm9yY2VGb2N1c09uRWxlbWVudChlbGVtZW50KSB7XG4gICAgRXZlbnRIYW5kbGVyLm9mZihkb2N1bWVudCwgRVZFTlRfRk9DVVNJTikgLy8gZ3VhcmQgYWdhaW5zdCBpbmZpbml0ZSBmb2N1cyBsb29wXG4gICAgRXZlbnRIYW5kbGVyLm9uKGRvY3VtZW50LCBFVkVOVF9GT0NVU0lOLCBldmVudCA9PiB7XG4gICAgICBpZiAoZG9jdW1lbnQgIT09IGV2ZW50LnRhcmdldCAmJlxuICAgICAgICBlbGVtZW50ICE9PSBldmVudC50YXJnZXQgJiZcbiAgICAgICAgIWVsZW1lbnQuY29udGFpbnMoZXZlbnQudGFyZ2V0KSkge1xuICAgICAgICBlbGVtZW50LmZvY3VzKClcbiAgICAgIH1cbiAgICB9KVxuICAgIGVsZW1lbnQuZm9jdXMoKVxuICB9XG5cbiAgX2FkZEV2ZW50TGlzdGVuZXJzKCkge1xuICAgIEV2ZW50SGFuZGxlci5vbih0aGlzLl9lbGVtZW50LCBFVkVOVF9DTElDS19ESVNNSVNTLCBTRUxFQ1RPUl9EQVRBX0RJU01JU1MsICgpID0+IHRoaXMuaGlkZSgpKVxuXG4gICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0tFWURPV05fRElTTUlTUywgZXZlbnQgPT4ge1xuICAgICAgaWYgKHRoaXMuX2NvbmZpZy5rZXlib2FyZCAmJiBldmVudC5rZXkgPT09IEVTQ0FQRV9LRVkpIHtcbiAgICAgICAgdGhpcy5oaWRlKClcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgLy8gU3RhdGljXG5cbiAgc3RhdGljIGpRdWVyeUludGVyZmFjZShjb25maWcpIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIGNvbnN0IGRhdGEgPSBPZmZjYW52YXMuZ2V0T3JDcmVhdGVJbnN0YW5jZSh0aGlzLCBjb25maWcpXG5cbiAgICAgIGlmICh0eXBlb2YgY29uZmlnICE9PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgaWYgKGRhdGFbY29uZmlnXSA9PT0gdW5kZWZpbmVkIHx8IGNvbmZpZy5zdGFydHNXaXRoKCdfJykgfHwgY29uZmlnID09PSAnY29uc3RydWN0b3InKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcIiR7Y29uZmlnfVwiYClcbiAgICAgIH1cblxuICAgICAgZGF0YVtjb25maWddKHRoaXMpXG4gICAgfSlcbiAgfVxufVxuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogRGF0YSBBcGkgaW1wbGVtZW50YXRpb25cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbkV2ZW50SGFuZGxlci5vbihkb2N1bWVudCwgRVZFTlRfQ0xJQ0tfREFUQV9BUEksIFNFTEVDVE9SX0RBVEFfVE9HR0xFLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgY29uc3QgdGFyZ2V0ID0gZ2V0RWxlbWVudEZyb21TZWxlY3Rvcih0aGlzKVxuXG4gIGlmIChbJ0EnLCAnQVJFQSddLmluY2x1ZGVzKHRoaXMudGFnTmFtZSkpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpXG4gIH1cblxuICBpZiAoaXNEaXNhYmxlZCh0aGlzKSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgRXZlbnRIYW5kbGVyLm9uZSh0YXJnZXQsIEVWRU5UX0hJRERFTiwgKCkgPT4ge1xuICAgIC8vIGZvY3VzIG9uIHRyaWdnZXIgd2hlbiBpdCBpcyBjbG9zZWRcbiAgICBpZiAoaXNWaXNpYmxlKHRoaXMpKSB7XG4gICAgICB0aGlzLmZvY3VzKClcbiAgICB9XG4gIH0pXG5cbiAgLy8gYXZvaWQgY29uZmxpY3Qgd2hlbiBjbGlja2luZyBhIHRvZ2dsZXIgb2YgYW4gb2ZmY2FudmFzLCB3aGlsZSBhbm90aGVyIGlzIG9wZW5cbiAgY29uc3QgYWxsUmVhZHlPcGVuID0gU2VsZWN0b3JFbmdpbmUuZmluZE9uZShPUEVOX1NFTEVDVE9SKVxuICBpZiAoYWxsUmVhZHlPcGVuICYmIGFsbFJlYWR5T3BlbiAhPT0gdGFyZ2V0KSB7XG4gICAgT2ZmY2FudmFzLmdldEluc3RhbmNlKGFsbFJlYWR5T3BlbikuaGlkZSgpXG4gIH1cblxuICBjb25zdCBkYXRhID0gT2ZmY2FudmFzLmdldE9yQ3JlYXRlSW5zdGFuY2UodGFyZ2V0KVxuICBkYXRhLnRvZ2dsZSh0aGlzKVxufSlcblxuRXZlbnRIYW5kbGVyLm9uKHdpbmRvdywgRVZFTlRfTE9BRF9EQVRBX0FQSSwgKCkgPT5cbiAgU2VsZWN0b3JFbmdpbmUuZmluZChPUEVOX1NFTEVDVE9SKS5mb3JFYWNoKGVsID0+IE9mZmNhbnZhcy5nZXRPckNyZWF0ZUluc3RhbmNlKGVsKS5zaG93KCkpXG4pXG5cbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBqUXVlcnlcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbmRlZmluZUpRdWVyeVBsdWdpbihPZmZjYW52YXMpXG5cbmV4cG9ydCBkZWZhdWx0IE9mZmNhbnZhc1xuIiwiLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQm9vdHN0cmFwICh2NS4wLjIpOiB1dGlsL3Nhbml0aXplci5qc1xuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbmNvbnN0IHVyaUF0dHJzID0gbmV3IFNldChbXG4gICdiYWNrZ3JvdW5kJyxcbiAgJ2NpdGUnLFxuICAnaHJlZicsXG4gICdpdGVtdHlwZScsXG4gICdsb25nZGVzYycsXG4gICdwb3N0ZXInLFxuICAnc3JjJyxcbiAgJ3hsaW5rOmhyZWYnXG5dKVxuXG5jb25zdCBBUklBX0FUVFJJQlVURV9QQVRURVJOID0gL15hcmlhLVtcXHctXSokL2lcblxuLyoqXG4gKiBBIHBhdHRlcm4gdGhhdCByZWNvZ25pemVzIGEgY29tbW9ubHkgdXNlZnVsIHN1YnNldCBvZiBVUkxzIHRoYXQgYXJlIHNhZmUuXG4gKlxuICogU2hvdXRvdXQgdG8gQW5ndWxhciA3IGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL2FuZ3VsYXIvYmxvYi83LjIuNC9wYWNrYWdlcy9jb3JlL3NyYy9zYW5pdGl6YXRpb24vdXJsX3Nhbml0aXplci50c1xuICovXG5jb25zdCBTQUZFX1VSTF9QQVRURVJOID0gL14oPzooPzpodHRwcz98bWFpbHRvfGZ0cHx0ZWx8ZmlsZSk6fFteIyYvOj9dKig/OlsjLz9dfCQpKS9pXG5cbi8qKlxuICogQSBwYXR0ZXJuIHRoYXQgbWF0Y2hlcyBzYWZlIGRhdGEgVVJMcy4gT25seSBtYXRjaGVzIGltYWdlLCB2aWRlbyBhbmQgYXVkaW8gdHlwZXMuXG4gKlxuICogU2hvdXRvdXQgdG8gQW5ndWxhciA3IGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL2FuZ3VsYXIvYmxvYi83LjIuNC9wYWNrYWdlcy9jb3JlL3NyYy9zYW5pdGl6YXRpb24vdXJsX3Nhbml0aXplci50c1xuICovXG5jb25zdCBEQVRBX1VSTF9QQVRURVJOID0gL15kYXRhOig/OmltYWdlXFwvKD86Ym1wfGdpZnxqcGVnfGpwZ3xwbmd8dGlmZnx3ZWJwKXx2aWRlb1xcLyg/Om1wZWd8bXA0fG9nZ3x3ZWJtKXxhdWRpb1xcLyg/Om1wM3xvZ2F8b2dnfG9wdXMpKTtiYXNlNjQsW1xcZCsvYS16XSs9KiQvaVxuXG5jb25zdCBhbGxvd2VkQXR0cmlidXRlID0gKGF0dHIsIGFsbG93ZWRBdHRyaWJ1dGVMaXN0KSA9PiB7XG4gIGNvbnN0IGF0dHJOYW1lID0gYXR0ci5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpXG5cbiAgaWYgKGFsbG93ZWRBdHRyaWJ1dGVMaXN0LmluY2x1ZGVzKGF0dHJOYW1lKSkge1xuICAgIGlmICh1cmlBdHRycy5oYXMoYXR0ck5hbWUpKSB7XG4gICAgICByZXR1cm4gQm9vbGVhbihTQUZFX1VSTF9QQVRURVJOLnRlc3QoYXR0ci5ub2RlVmFsdWUpIHx8IERBVEFfVVJMX1BBVFRFUk4udGVzdChhdHRyLm5vZGVWYWx1ZSkpXG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGNvbnN0IHJlZ0V4cCA9IGFsbG93ZWRBdHRyaWJ1dGVMaXN0LmZpbHRlcihhdHRyUmVnZXggPT4gYXR0clJlZ2V4IGluc3RhbmNlb2YgUmVnRXhwKVxuXG4gIC8vIENoZWNrIGlmIGEgcmVndWxhciBleHByZXNzaW9uIHZhbGlkYXRlcyB0aGUgYXR0cmlidXRlLlxuICBmb3IgKGxldCBpID0gMCwgbGVuID0gcmVnRXhwLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKHJlZ0V4cFtpXS50ZXN0KGF0dHJOYW1lKSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2Vcbn1cblxuZXhwb3J0IGNvbnN0IERlZmF1bHRBbGxvd2xpc3QgPSB7XG4gIC8vIEdsb2JhbCBhdHRyaWJ1dGVzIGFsbG93ZWQgb24gYW55IHN1cHBsaWVkIGVsZW1lbnQgYmVsb3cuXG4gICcqJzogWydjbGFzcycsICdkaXInLCAnaWQnLCAnbGFuZycsICdyb2xlJywgQVJJQV9BVFRSSUJVVEVfUEFUVEVSTl0sXG4gIGE6IFsndGFyZ2V0JywgJ2hyZWYnLCAndGl0bGUnLCAncmVsJ10sXG4gIGFyZWE6IFtdLFxuICBiOiBbXSxcbiAgYnI6IFtdLFxuICBjb2w6IFtdLFxuICBjb2RlOiBbXSxcbiAgZGl2OiBbXSxcbiAgZW06IFtdLFxuICBocjogW10sXG4gIGgxOiBbXSxcbiAgaDI6IFtdLFxuICBoMzogW10sXG4gIGg0OiBbXSxcbiAgaDU6IFtdLFxuICBoNjogW10sXG4gIGk6IFtdLFxuICBpbWc6IFsnc3JjJywgJ3NyY3NldCcsICdhbHQnLCAndGl0bGUnLCAnd2lkdGgnLCAnaGVpZ2h0J10sXG4gIGxpOiBbXSxcbiAgb2w6IFtdLFxuICBwOiBbXSxcbiAgcHJlOiBbXSxcbiAgczogW10sXG4gIHNtYWxsOiBbXSxcbiAgc3BhbjogW10sXG4gIHN1YjogW10sXG4gIHN1cDogW10sXG4gIHN0cm9uZzogW10sXG4gIHU6IFtdLFxuICB1bDogW11cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNhbml0aXplSHRtbCh1bnNhZmVIdG1sLCBhbGxvd0xpc3QsIHNhbml0aXplRm4pIHtcbiAgaWYgKCF1bnNhZmVIdG1sLmxlbmd0aCkge1xuICAgIHJldHVybiB1bnNhZmVIdG1sXG4gIH1cblxuICBpZiAoc2FuaXRpemVGbiAmJiB0eXBlb2Ygc2FuaXRpemVGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBzYW5pdGl6ZUZuKHVuc2FmZUh0bWwpXG4gIH1cblxuICBjb25zdCBkb21QYXJzZXIgPSBuZXcgd2luZG93LkRPTVBhcnNlcigpXG4gIGNvbnN0IGNyZWF0ZWREb2N1bWVudCA9IGRvbVBhcnNlci5wYXJzZUZyb21TdHJpbmcodW5zYWZlSHRtbCwgJ3RleHQvaHRtbCcpXG4gIGNvbnN0IGFsbG93bGlzdEtleXMgPSBPYmplY3Qua2V5cyhhbGxvd0xpc3QpXG4gIGNvbnN0IGVsZW1lbnRzID0gW10uY29uY2F0KC4uLmNyZWF0ZWREb2N1bWVudC5ib2R5LnF1ZXJ5U2VsZWN0b3JBbGwoJyonKSlcblxuICBmb3IgKGxldCBpID0gMCwgbGVuID0gZWxlbWVudHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBjb25zdCBlbCA9IGVsZW1lbnRzW2ldXG4gICAgY29uc3QgZWxOYW1lID0gZWwubm9kZU5hbWUudG9Mb3dlckNhc2UoKVxuXG4gICAgaWYgKCFhbGxvd2xpc3RLZXlzLmluY2x1ZGVzKGVsTmFtZSkpIHtcbiAgICAgIGVsLnJlbW92ZSgpXG5cbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuXG4gICAgY29uc3QgYXR0cmlidXRlTGlzdCA9IFtdLmNvbmNhdCguLi5lbC5hdHRyaWJ1dGVzKVxuICAgIGNvbnN0IGFsbG93ZWRBdHRyaWJ1dGVzID0gW10uY29uY2F0KGFsbG93TGlzdFsnKiddIHx8IFtdLCBhbGxvd0xpc3RbZWxOYW1lXSB8fCBbXSlcblxuICAgIGF0dHJpYnV0ZUxpc3QuZm9yRWFjaChhdHRyID0+IHtcbiAgICAgIGlmICghYWxsb3dlZEF0dHJpYnV0ZShhdHRyLCBhbGxvd2VkQXR0cmlidXRlcykpIHtcbiAgICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKGF0dHIubm9kZU5hbWUpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIHJldHVybiBjcmVhdGVkRG9jdW1lbnQuYm9keS5pbm5lckhUTUxcbn1cbiIsIi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEJvb3RzdHJhcCAodjUuMC4yKTogdG9vbHRpcC5qc1xuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbmltcG9ydCAqIGFzIFBvcHBlciBmcm9tICdAcG9wcGVyanMvY29yZSdcblxuaW1wb3J0IHtcbiAgZGVmaW5lSlF1ZXJ5UGx1Z2luLFxuICBmaW5kU2hhZG93Um9vdCxcbiAgZ2V0RWxlbWVudCxcbiAgZ2V0VUlELFxuICBpc0VsZW1lbnQsXG4gIGlzUlRMLFxuICBub29wLFxuICB0eXBlQ2hlY2tDb25maWdcbn0gZnJvbSAnLi91dGlsL2luZGV4J1xuaW1wb3J0IHtcbiAgRGVmYXVsdEFsbG93bGlzdCxcbiAgc2FuaXRpemVIdG1sXG59IGZyb20gJy4vdXRpbC9zYW5pdGl6ZXInXG5pbXBvcnQgRGF0YSBmcm9tICcuL2RvbS9kYXRhJ1xuaW1wb3J0IEV2ZW50SGFuZGxlciBmcm9tICcuL2RvbS9ldmVudC1oYW5kbGVyJ1xuaW1wb3J0IE1hbmlwdWxhdG9yIGZyb20gJy4vZG9tL21hbmlwdWxhdG9yJ1xuaW1wb3J0IFNlbGVjdG9yRW5naW5lIGZyb20gJy4vZG9tL3NlbGVjdG9yLWVuZ2luZSdcbmltcG9ydCBCYXNlQ29tcG9uZW50IGZyb20gJy4vYmFzZS1jb21wb25lbnQnXG5cbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb25zdGFudHNcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbmNvbnN0IE5BTUUgPSAndG9vbHRpcCdcbmNvbnN0IERBVEFfS0VZID0gJ2JzLnRvb2x0aXAnXG5jb25zdCBFVkVOVF9LRVkgPSBgLiR7REFUQV9LRVl9YFxuY29uc3QgQ0xBU1NfUFJFRklYID0gJ2JzLXRvb2x0aXAnXG5jb25zdCBCU0NMU19QUkVGSVhfUkVHRVggPSBuZXcgUmVnRXhwKGAoXnxcXFxccykke0NMQVNTX1BSRUZJWH1cXFxcUytgLCAnZycpXG5jb25zdCBESVNBTExPV0VEX0FUVFJJQlVURVMgPSBuZXcgU2V0KFsnc2FuaXRpemUnLCAnYWxsb3dMaXN0JywgJ3Nhbml0aXplRm4nXSlcblxuY29uc3QgRGVmYXVsdFR5cGUgPSB7XG4gIGFuaW1hdGlvbjogJ2Jvb2xlYW4nLFxuICB0ZW1wbGF0ZTogJ3N0cmluZycsXG4gIHRpdGxlOiAnKHN0cmluZ3xlbGVtZW50fGZ1bmN0aW9uKScsXG4gIHRyaWdnZXI6ICdzdHJpbmcnLFxuICBkZWxheTogJyhudW1iZXJ8b2JqZWN0KScsXG4gIGh0bWw6ICdib29sZWFuJyxcbiAgc2VsZWN0b3I6ICcoc3RyaW5nfGJvb2xlYW4pJyxcbiAgcGxhY2VtZW50OiAnKHN0cmluZ3xmdW5jdGlvbiknLFxuICBvZmZzZXQ6ICcoYXJyYXl8c3RyaW5nfGZ1bmN0aW9uKScsXG4gIGNvbnRhaW5lcjogJyhzdHJpbmd8ZWxlbWVudHxib29sZWFuKScsXG4gIGZhbGxiYWNrUGxhY2VtZW50czogJ2FycmF5JyxcbiAgYm91bmRhcnk6ICcoc3RyaW5nfGVsZW1lbnQpJyxcbiAgY3VzdG9tQ2xhc3M6ICcoc3RyaW5nfGZ1bmN0aW9uKScsXG4gIHNhbml0aXplOiAnYm9vbGVhbicsXG4gIHNhbml0aXplRm46ICcobnVsbHxmdW5jdGlvbiknLFxuICBhbGxvd0xpc3Q6ICdvYmplY3QnLFxuICBwb3BwZXJDb25maWc6ICcobnVsbHxvYmplY3R8ZnVuY3Rpb24pJ1xufVxuXG5jb25zdCBBdHRhY2htZW50TWFwID0ge1xuICBBVVRPOiAnYXV0bycsXG4gIFRPUDogJ3RvcCcsXG4gIFJJR0hUOiBpc1JUTCgpID8gJ2xlZnQnIDogJ3JpZ2h0JyxcbiAgQk9UVE9NOiAnYm90dG9tJyxcbiAgTEVGVDogaXNSVEwoKSA/ICdyaWdodCcgOiAnbGVmdCdcbn1cblxuY29uc3QgRGVmYXVsdCA9IHtcbiAgYW5pbWF0aW9uOiB0cnVlLFxuICB0ZW1wbGF0ZTogJzxkaXYgY2xhc3M9XCJ0b29sdGlwXCIgcm9sZT1cInRvb2x0aXBcIj4nICtcbiAgICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJ0b29sdGlwLWFycm93XCI+PC9kaXY+JyArXG4gICAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwidG9vbHRpcC1pbm5lclwiPjwvZGl2PicgK1xuICAgICAgICAgICAgJzwvZGl2PicsXG4gIHRyaWdnZXI6ICdob3ZlciBmb2N1cycsXG4gIHRpdGxlOiAnJyxcbiAgZGVsYXk6IDAsXG4gIGh0bWw6IGZhbHNlLFxuICBzZWxlY3RvcjogZmFsc2UsXG4gIHBsYWNlbWVudDogJ3RvcCcsXG4gIG9mZnNldDogWzAsIDBdLFxuICBjb250YWluZXI6IGZhbHNlLFxuICBmYWxsYmFja1BsYWNlbWVudHM6IFsndG9wJywgJ3JpZ2h0JywgJ2JvdHRvbScsICdsZWZ0J10sXG4gIGJvdW5kYXJ5OiAnY2xpcHBpbmdQYXJlbnRzJyxcbiAgY3VzdG9tQ2xhc3M6ICcnLFxuICBzYW5pdGl6ZTogdHJ1ZSxcbiAgc2FuaXRpemVGbjogbnVsbCxcbiAgYWxsb3dMaXN0OiBEZWZhdWx0QWxsb3dsaXN0LFxuICBwb3BwZXJDb25maWc6IG51bGxcbn1cblxuY29uc3QgRXZlbnQgPSB7XG4gIEhJREU6IGBoaWRlJHtFVkVOVF9LRVl9YCxcbiAgSElEREVOOiBgaGlkZGVuJHtFVkVOVF9LRVl9YCxcbiAgU0hPVzogYHNob3cke0VWRU5UX0tFWX1gLFxuICBTSE9XTjogYHNob3duJHtFVkVOVF9LRVl9YCxcbiAgSU5TRVJURUQ6IGBpbnNlcnRlZCR7RVZFTlRfS0VZfWAsXG4gIENMSUNLOiBgY2xpY2ske0VWRU5UX0tFWX1gLFxuICBGT0NVU0lOOiBgZm9jdXNpbiR7RVZFTlRfS0VZfWAsXG4gIEZPQ1VTT1VUOiBgZm9jdXNvdXQke0VWRU5UX0tFWX1gLFxuICBNT1VTRUVOVEVSOiBgbW91c2VlbnRlciR7RVZFTlRfS0VZfWAsXG4gIE1PVVNFTEVBVkU6IGBtb3VzZWxlYXZlJHtFVkVOVF9LRVl9YFxufVxuXG5jb25zdCBDTEFTU19OQU1FX0ZBREUgPSAnZmFkZSdcbmNvbnN0IENMQVNTX05BTUVfTU9EQUwgPSAnbW9kYWwnXG5jb25zdCBDTEFTU19OQU1FX1NIT1cgPSAnc2hvdydcblxuY29uc3QgSE9WRVJfU1RBVEVfU0hPVyA9ICdzaG93J1xuY29uc3QgSE9WRVJfU1RBVEVfT1VUID0gJ291dCdcblxuY29uc3QgU0VMRUNUT1JfVE9PTFRJUF9JTk5FUiA9ICcudG9vbHRpcC1pbm5lcidcblxuY29uc3QgVFJJR0dFUl9IT1ZFUiA9ICdob3ZlcidcbmNvbnN0IFRSSUdHRVJfRk9DVVMgPSAnZm9jdXMnXG5jb25zdCBUUklHR0VSX0NMSUNLID0gJ2NsaWNrJ1xuY29uc3QgVFJJR0dFUl9NQU5VQUwgPSAnbWFudWFsJ1xuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ2xhc3MgRGVmaW5pdGlvblxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuY2xhc3MgVG9vbHRpcCBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvcihlbGVtZW50LCBjb25maWcpIHtcbiAgICBpZiAodHlwZW9mIFBvcHBlciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Jvb3RzdHJhcFxcJ3MgdG9vbHRpcHMgcmVxdWlyZSBQb3BwZXIgKGh0dHBzOi8vcG9wcGVyLmpzLm9yZyknKVxuICAgIH1cblxuICAgIHN1cGVyKGVsZW1lbnQpXG5cbiAgICAvLyBwcml2YXRlXG4gICAgdGhpcy5faXNFbmFibGVkID0gdHJ1ZVxuICAgIHRoaXMuX3RpbWVvdXQgPSAwXG4gICAgdGhpcy5faG92ZXJTdGF0ZSA9ICcnXG4gICAgdGhpcy5fYWN0aXZlVHJpZ2dlciA9IHt9XG4gICAgdGhpcy5fcG9wcGVyID0gbnVsbFxuXG4gICAgLy8gUHJvdGVjdGVkXG4gICAgdGhpcy5fY29uZmlnID0gdGhpcy5fZ2V0Q29uZmlnKGNvbmZpZylcbiAgICB0aGlzLnRpcCA9IG51bGxcblxuICAgIHRoaXMuX3NldExpc3RlbmVycygpXG4gIH1cblxuICAvLyBHZXR0ZXJzXG5cbiAgc3RhdGljIGdldCBEZWZhdWx0KCkge1xuICAgIHJldHVybiBEZWZhdWx0XG4gIH1cblxuICBzdGF0aWMgZ2V0IE5BTUUoKSB7XG4gICAgcmV0dXJuIE5BTUVcbiAgfVxuXG4gIHN0YXRpYyBnZXQgRXZlbnQoKSB7XG4gICAgcmV0dXJuIEV2ZW50XG4gIH1cblxuICBzdGF0aWMgZ2V0IERlZmF1bHRUeXBlKCkge1xuICAgIHJldHVybiBEZWZhdWx0VHlwZVxuICB9XG5cbiAgLy8gUHVibGljXG5cbiAgZW5hYmxlKCkge1xuICAgIHRoaXMuX2lzRW5hYmxlZCA9IHRydWVcbiAgfVxuXG4gIGRpc2FibGUoKSB7XG4gICAgdGhpcy5faXNFbmFibGVkID0gZmFsc2VcbiAgfVxuXG4gIHRvZ2dsZUVuYWJsZWQoKSB7XG4gICAgdGhpcy5faXNFbmFibGVkID0gIXRoaXMuX2lzRW5hYmxlZFxuICB9XG5cbiAgdG9nZ2xlKGV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLl9pc0VuYWJsZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmIChldmVudCkge1xuICAgICAgY29uc3QgY29udGV4dCA9IHRoaXMuX2luaXRpYWxpemVPbkRlbGVnYXRlZFRhcmdldChldmVudClcblxuICAgICAgY29udGV4dC5fYWN0aXZlVHJpZ2dlci5jbGljayA9ICFjb250ZXh0Ll9hY3RpdmVUcmlnZ2VyLmNsaWNrXG5cbiAgICAgIGlmIChjb250ZXh0Ll9pc1dpdGhBY3RpdmVUcmlnZ2VyKCkpIHtcbiAgICAgICAgY29udGV4dC5fZW50ZXIobnVsbCwgY29udGV4dClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRleHQuX2xlYXZlKG51bGwsIGNvbnRleHQpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0aGlzLmdldFRpcEVsZW1lbnQoKS5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9TSE9XKSkge1xuICAgICAgICB0aGlzLl9sZWF2ZShudWxsLCB0aGlzKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgdGhpcy5fZW50ZXIobnVsbCwgdGhpcylcbiAgICB9XG4gIH1cblxuICBkaXNwb3NlKCkge1xuICAgIGNsZWFyVGltZW91dCh0aGlzLl90aW1lb3V0KVxuXG4gICAgRXZlbnRIYW5kbGVyLm9mZih0aGlzLl9lbGVtZW50LmNsb3Nlc3QoYC4ke0NMQVNTX05BTUVfTU9EQUx9YCksICdoaWRlLmJzLm1vZGFsJywgdGhpcy5faGlkZU1vZGFsSGFuZGxlcilcblxuICAgIGlmICh0aGlzLnRpcCkge1xuICAgICAgdGhpcy50aXAucmVtb3ZlKClcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fcG9wcGVyKSB7XG4gICAgICB0aGlzLl9wb3BwZXIuZGVzdHJveSgpXG4gICAgfVxuXG4gICAgc3VwZXIuZGlzcG9zZSgpXG4gIH1cblxuICBzaG93KCkge1xuICAgIGlmICh0aGlzLl9lbGVtZW50LnN0eWxlLmRpc3BsYXkgPT09ICdub25lJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQbGVhc2UgdXNlIHNob3cgb24gdmlzaWJsZSBlbGVtZW50cycpXG4gICAgfVxuXG4gICAgaWYgKCEodGhpcy5pc1dpdGhDb250ZW50KCkgJiYgdGhpcy5faXNFbmFibGVkKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3Qgc2hvd0V2ZW50ID0gRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgdGhpcy5jb25zdHJ1Y3Rvci5FdmVudC5TSE9XKVxuICAgIGNvbnN0IHNoYWRvd1Jvb3QgPSBmaW5kU2hhZG93Um9vdCh0aGlzLl9lbGVtZW50KVxuICAgIGNvbnN0IGlzSW5UaGVEb20gPSBzaGFkb3dSb290ID09PSBudWxsID9cbiAgICAgIHRoaXMuX2VsZW1lbnQub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY29udGFpbnModGhpcy5fZWxlbWVudCkgOlxuICAgICAgc2hhZG93Um9vdC5jb250YWlucyh0aGlzLl9lbGVtZW50KVxuXG4gICAgaWYgKHNob3dFdmVudC5kZWZhdWx0UHJldmVudGVkIHx8ICFpc0luVGhlRG9tKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCB0aXAgPSB0aGlzLmdldFRpcEVsZW1lbnQoKVxuICAgIGNvbnN0IHRpcElkID0gZ2V0VUlEKHRoaXMuY29uc3RydWN0b3IuTkFNRSlcblxuICAgIHRpcC5zZXRBdHRyaWJ1dGUoJ2lkJywgdGlwSWQpXG4gICAgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtZGVzY3JpYmVkYnknLCB0aXBJZClcblxuICAgIHRoaXMuc2V0Q29udGVudCgpXG5cbiAgICBpZiAodGhpcy5fY29uZmlnLmFuaW1hdGlvbikge1xuICAgICAgdGlwLmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9GQURFKVxuICAgIH1cblxuICAgIGNvbnN0IHBsYWNlbWVudCA9IHR5cGVvZiB0aGlzLl9jb25maWcucGxhY2VtZW50ID09PSAnZnVuY3Rpb24nID9cbiAgICAgIHRoaXMuX2NvbmZpZy5wbGFjZW1lbnQuY2FsbCh0aGlzLCB0aXAsIHRoaXMuX2VsZW1lbnQpIDpcbiAgICAgIHRoaXMuX2NvbmZpZy5wbGFjZW1lbnRcblxuICAgIGNvbnN0IGF0dGFjaG1lbnQgPSB0aGlzLl9nZXRBdHRhY2htZW50KHBsYWNlbWVudClcbiAgICB0aGlzLl9hZGRBdHRhY2htZW50Q2xhc3MoYXR0YWNobWVudClcblxuICAgIGNvbnN0IHsgY29udGFpbmVyIH0gPSB0aGlzLl9jb25maWdcbiAgICBEYXRhLnNldCh0aXAsIHRoaXMuY29uc3RydWN0b3IuREFUQV9LRVksIHRoaXMpXG5cbiAgICBpZiAoIXRoaXMuX2VsZW1lbnQub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY29udGFpbnModGhpcy50aXApKSB7XG4gICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQodGlwKVxuICAgICAgRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgdGhpcy5jb25zdHJ1Y3Rvci5FdmVudC5JTlNFUlRFRClcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fcG9wcGVyKSB7XG4gICAgICB0aGlzLl9wb3BwZXIudXBkYXRlKClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fcG9wcGVyID0gUG9wcGVyLmNyZWF0ZVBvcHBlcih0aGlzLl9lbGVtZW50LCB0aXAsIHRoaXMuX2dldFBvcHBlckNvbmZpZyhhdHRhY2htZW50KSlcbiAgICB9XG5cbiAgICB0aXAuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX1NIT1cpXG5cbiAgICBjb25zdCBjdXN0b21DbGFzcyA9IHR5cGVvZiB0aGlzLl9jb25maWcuY3VzdG9tQ2xhc3MgPT09ICdmdW5jdGlvbicgPyB0aGlzLl9jb25maWcuY3VzdG9tQ2xhc3MoKSA6IHRoaXMuX2NvbmZpZy5jdXN0b21DbGFzc1xuICAgIGlmIChjdXN0b21DbGFzcykge1xuICAgICAgdGlwLmNsYXNzTGlzdC5hZGQoLi4uY3VzdG9tQ2xhc3Muc3BsaXQoJyAnKSlcbiAgICB9XG5cbiAgICAvLyBJZiB0aGlzIGlzIGEgdG91Y2gtZW5hYmxlZCBkZXZpY2Ugd2UgYWRkIGV4dHJhXG4gICAgLy8gZW1wdHkgbW91c2VvdmVyIGxpc3RlbmVycyB0byB0aGUgYm9keSdzIGltbWVkaWF0ZSBjaGlsZHJlbjtcbiAgICAvLyBvbmx5IG5lZWRlZCBiZWNhdXNlIG9mIGJyb2tlbiBldmVudCBkZWxlZ2F0aW9uIG9uIGlPU1xuICAgIC8vIGh0dHBzOi8vd3d3LnF1aXJrc21vZGUub3JnL2Jsb2cvYXJjaGl2ZXMvMjAxNC8wMi9tb3VzZV9ldmVudF9idWIuaHRtbFxuICAgIGlmICgnb250b3VjaHN0YXJ0JyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpIHtcbiAgICAgIFtdLmNvbmNhdCguLi5kb2N1bWVudC5ib2R5LmNoaWxkcmVuKS5mb3JFYWNoKGVsZW1lbnQgPT4ge1xuICAgICAgICBFdmVudEhhbmRsZXIub24oZWxlbWVudCwgJ21vdXNlb3ZlcicsIG5vb3ApXG4gICAgICB9KVxuICAgIH1cblxuICAgIGNvbnN0IGNvbXBsZXRlID0gKCkgPT4ge1xuICAgICAgY29uc3QgcHJldkhvdmVyU3RhdGUgPSB0aGlzLl9ob3ZlclN0YXRlXG5cbiAgICAgIHRoaXMuX2hvdmVyU3RhdGUgPSBudWxsXG4gICAgICBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCB0aGlzLmNvbnN0cnVjdG9yLkV2ZW50LlNIT1dOKVxuXG4gICAgICBpZiAocHJldkhvdmVyU3RhdGUgPT09IEhPVkVSX1NUQVRFX09VVCkge1xuICAgICAgICB0aGlzLl9sZWF2ZShudWxsLCB0aGlzKVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGlzQW5pbWF0ZWQgPSB0aGlzLnRpcC5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9GQURFKVxuICAgIHRoaXMuX3F1ZXVlQ2FsbGJhY2soY29tcGxldGUsIHRoaXMudGlwLCBpc0FuaW1hdGVkKVxuICB9XG5cbiAgaGlkZSgpIHtcbiAgICBpZiAoIXRoaXMuX3BvcHBlcikge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3QgdGlwID0gdGhpcy5nZXRUaXBFbGVtZW50KClcbiAgICBjb25zdCBjb21wbGV0ZSA9ICgpID0+IHtcbiAgICAgIGlmICh0aGlzLl9pc1dpdGhBY3RpdmVUcmlnZ2VyKCkpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9ob3ZlclN0YXRlICE9PSBIT1ZFUl9TVEFURV9TSE9XKSB7XG4gICAgICAgIHRpcC5yZW1vdmUoKVxuICAgICAgfVxuXG4gICAgICB0aGlzLl9jbGVhblRpcENsYXNzKClcbiAgICAgIHRoaXMuX2VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdhcmlhLWRlc2NyaWJlZGJ5JylcbiAgICAgIEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIHRoaXMuY29uc3RydWN0b3IuRXZlbnQuSElEREVOKVxuXG4gICAgICBpZiAodGhpcy5fcG9wcGVyKSB7XG4gICAgICAgIHRoaXMuX3BvcHBlci5kZXN0cm95KClcbiAgICAgICAgdGhpcy5fcG9wcGVyID0gbnVsbFxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGhpZGVFdmVudCA9IEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIHRoaXMuY29uc3RydWN0b3IuRXZlbnQuSElERSlcbiAgICBpZiAoaGlkZUV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRpcC5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfU0hPVylcblxuICAgIC8vIElmIHRoaXMgaXMgYSB0b3VjaC1lbmFibGVkIGRldmljZSB3ZSByZW1vdmUgdGhlIGV4dHJhXG4gICAgLy8gZW1wdHkgbW91c2VvdmVyIGxpc3RlbmVycyB3ZSBhZGRlZCBmb3IgaU9TIHN1cHBvcnRcbiAgICBpZiAoJ29udG91Y2hzdGFydCcgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgICBbXS5jb25jYXQoLi4uZG9jdW1lbnQuYm9keS5jaGlsZHJlbilcbiAgICAgICAgLmZvckVhY2goZWxlbWVudCA9PiBFdmVudEhhbmRsZXIub2ZmKGVsZW1lbnQsICdtb3VzZW92ZXInLCBub29wKSlcbiAgICB9XG5cbiAgICB0aGlzLl9hY3RpdmVUcmlnZ2VyW1RSSUdHRVJfQ0xJQ0tdID0gZmFsc2VcbiAgICB0aGlzLl9hY3RpdmVUcmlnZ2VyW1RSSUdHRVJfRk9DVVNdID0gZmFsc2VcbiAgICB0aGlzLl9hY3RpdmVUcmlnZ2VyW1RSSUdHRVJfSE9WRVJdID0gZmFsc2VcblxuICAgIGNvbnN0IGlzQW5pbWF0ZWQgPSB0aGlzLnRpcC5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9GQURFKVxuICAgIHRoaXMuX3F1ZXVlQ2FsbGJhY2soY29tcGxldGUsIHRoaXMudGlwLCBpc0FuaW1hdGVkKVxuICAgIHRoaXMuX2hvdmVyU3RhdGUgPSAnJ1xuICB9XG5cbiAgdXBkYXRlKCkge1xuICAgIGlmICh0aGlzLl9wb3BwZXIgIT09IG51bGwpIHtcbiAgICAgIHRoaXMuX3BvcHBlci51cGRhdGUoKVxuICAgIH1cbiAgfVxuXG4gIC8vIFByb3RlY3RlZFxuXG4gIGlzV2l0aENvbnRlbnQoKSB7XG4gICAgcmV0dXJuIEJvb2xlYW4odGhpcy5nZXRUaXRsZSgpKVxuICB9XG5cbiAgZ2V0VGlwRWxlbWVudCgpIHtcbiAgICBpZiAodGhpcy50aXApIHtcbiAgICAgIHJldHVybiB0aGlzLnRpcFxuICAgIH1cblxuICAgIGNvbnN0IGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICAgIGVsZW1lbnQuaW5uZXJIVE1MID0gdGhpcy5fY29uZmlnLnRlbXBsYXRlXG5cbiAgICB0aGlzLnRpcCA9IGVsZW1lbnQuY2hpbGRyZW5bMF1cbiAgICByZXR1cm4gdGhpcy50aXBcbiAgfVxuXG4gIHNldENvbnRlbnQoKSB7XG4gICAgY29uc3QgdGlwID0gdGhpcy5nZXRUaXBFbGVtZW50KClcbiAgICB0aGlzLnNldEVsZW1lbnRDb250ZW50KFNlbGVjdG9yRW5naW5lLmZpbmRPbmUoU0VMRUNUT1JfVE9PTFRJUF9JTk5FUiwgdGlwKSwgdGhpcy5nZXRUaXRsZSgpKVxuICAgIHRpcC5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfRkFERSwgQ0xBU1NfTkFNRV9TSE9XKVxuICB9XG5cbiAgc2V0RWxlbWVudENvbnRlbnQoZWxlbWVudCwgY29udGVudCkge1xuICAgIGlmIChlbGVtZW50ID09PSBudWxsKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoaXNFbGVtZW50KGNvbnRlbnQpKSB7XG4gICAgICBjb250ZW50ID0gZ2V0RWxlbWVudChjb250ZW50KVxuXG4gICAgICAvLyBjb250ZW50IGlzIGEgRE9NIG5vZGUgb3IgYSBqUXVlcnlcbiAgICAgIGlmICh0aGlzLl9jb25maWcuaHRtbCkge1xuICAgICAgICBpZiAoY29udGVudC5wYXJlbnROb2RlICE9PSBlbGVtZW50KSB7XG4gICAgICAgICAgZWxlbWVudC5pbm5lckhUTUwgPSAnJ1xuICAgICAgICAgIGVsZW1lbnQuYXBwZW5kQ2hpbGQoY29udGVudClcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWxlbWVudC50ZXh0Q29udGVudCA9IGNvbnRlbnQudGV4dENvbnRlbnRcbiAgICAgIH1cblxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2NvbmZpZy5odG1sKSB7XG4gICAgICBpZiAodGhpcy5fY29uZmlnLnNhbml0aXplKSB7XG4gICAgICAgIGNvbnRlbnQgPSBzYW5pdGl6ZUh0bWwoY29udGVudCwgdGhpcy5fY29uZmlnLmFsbG93TGlzdCwgdGhpcy5fY29uZmlnLnNhbml0aXplRm4pXG4gICAgICB9XG5cbiAgICAgIGVsZW1lbnQuaW5uZXJIVE1MID0gY29udGVudFxuICAgIH0gZWxzZSB7XG4gICAgICBlbGVtZW50LnRleHRDb250ZW50ID0gY29udGVudFxuICAgIH1cbiAgfVxuXG4gIGdldFRpdGxlKCkge1xuICAgIGxldCB0aXRsZSA9IHRoaXMuX2VsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLWJzLW9yaWdpbmFsLXRpdGxlJylcblxuICAgIGlmICghdGl0bGUpIHtcbiAgICAgIHRpdGxlID0gdHlwZW9mIHRoaXMuX2NvbmZpZy50aXRsZSA9PT0gJ2Z1bmN0aW9uJyA/XG4gICAgICAgIHRoaXMuX2NvbmZpZy50aXRsZS5jYWxsKHRoaXMuX2VsZW1lbnQpIDpcbiAgICAgICAgdGhpcy5fY29uZmlnLnRpdGxlXG4gICAgfVxuXG4gICAgcmV0dXJuIHRpdGxlXG4gIH1cblxuICB1cGRhdGVBdHRhY2htZW50KGF0dGFjaG1lbnQpIHtcbiAgICBpZiAoYXR0YWNobWVudCA9PT0gJ3JpZ2h0Jykge1xuICAgICAgcmV0dXJuICdlbmQnXG4gICAgfVxuXG4gICAgaWYgKGF0dGFjaG1lbnQgPT09ICdsZWZ0Jykge1xuICAgICAgcmV0dXJuICdzdGFydCdcbiAgICB9XG5cbiAgICByZXR1cm4gYXR0YWNobWVudFxuICB9XG5cbiAgLy8gUHJpdmF0ZVxuXG4gIF9pbml0aWFsaXplT25EZWxlZ2F0ZWRUYXJnZXQoZXZlbnQsIGNvbnRleHQpIHtcbiAgICBjb25zdCBkYXRhS2V5ID0gdGhpcy5jb25zdHJ1Y3Rvci5EQVRBX0tFWVxuICAgIGNvbnRleHQgPSBjb250ZXh0IHx8IERhdGEuZ2V0KGV2ZW50LmRlbGVnYXRlVGFyZ2V0LCBkYXRhS2V5KVxuXG4gICAgaWYgKCFjb250ZXh0KSB7XG4gICAgICBjb250ZXh0ID0gbmV3IHRoaXMuY29uc3RydWN0b3IoZXZlbnQuZGVsZWdhdGVUYXJnZXQsIHRoaXMuX2dldERlbGVnYXRlQ29uZmlnKCkpXG4gICAgICBEYXRhLnNldChldmVudC5kZWxlZ2F0ZVRhcmdldCwgZGF0YUtleSwgY29udGV4dClcbiAgICB9XG5cbiAgICByZXR1cm4gY29udGV4dFxuICB9XG5cbiAgX2dldE9mZnNldCgpIHtcbiAgICBjb25zdCB7IG9mZnNldCB9ID0gdGhpcy5fY29uZmlnXG5cbiAgICBpZiAodHlwZW9mIG9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBvZmZzZXQuc3BsaXQoJywnKS5tYXAodmFsID0+IE51bWJlci5wYXJzZUludCh2YWwsIDEwKSlcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG9mZnNldCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIHBvcHBlckRhdGEgPT4gb2Zmc2V0KHBvcHBlckRhdGEsIHRoaXMuX2VsZW1lbnQpXG4gICAgfVxuXG4gICAgcmV0dXJuIG9mZnNldFxuICB9XG5cbiAgX2dldFBvcHBlckNvbmZpZyhhdHRhY2htZW50KSB7XG4gICAgY29uc3QgZGVmYXVsdEJzUG9wcGVyQ29uZmlnID0ge1xuICAgICAgcGxhY2VtZW50OiBhdHRhY2htZW50LFxuICAgICAgbW9kaWZpZXJzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiAnZmxpcCcsXG4gICAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgZmFsbGJhY2tQbGFjZW1lbnRzOiB0aGlzLl9jb25maWcuZmFsbGJhY2tQbGFjZW1lbnRzXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogJ29mZnNldCcsXG4gICAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgb2Zmc2V0OiB0aGlzLl9nZXRPZmZzZXQoKVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6ICdwcmV2ZW50T3ZlcmZsb3cnLFxuICAgICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgIGJvdW5kYXJ5OiB0aGlzLl9jb25maWcuYm91bmRhcnlcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiAnYXJyb3cnLFxuICAgICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgIGVsZW1lbnQ6IGAuJHt0aGlzLmNvbnN0cnVjdG9yLk5BTUV9LWFycm93YFxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6ICdvbkNoYW5nZScsXG4gICAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgICBwaGFzZTogJ2FmdGVyV3JpdGUnLFxuICAgICAgICAgIGZuOiBkYXRhID0+IHRoaXMuX2hhbmRsZVBvcHBlclBsYWNlbWVudENoYW5nZShkYXRhKVxuICAgICAgICB9XG4gICAgICBdLFxuICAgICAgb25GaXJzdFVwZGF0ZTogZGF0YSA9PiB7XG4gICAgICAgIGlmIChkYXRhLm9wdGlvbnMucGxhY2VtZW50ICE9PSBkYXRhLnBsYWNlbWVudCkge1xuICAgICAgICAgIHRoaXMuX2hhbmRsZVBvcHBlclBsYWNlbWVudENoYW5nZShkYXRhKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmRlZmF1bHRCc1BvcHBlckNvbmZpZyxcbiAgICAgIC4uLih0eXBlb2YgdGhpcy5fY29uZmlnLnBvcHBlckNvbmZpZyA9PT0gJ2Z1bmN0aW9uJyA/IHRoaXMuX2NvbmZpZy5wb3BwZXJDb25maWcoZGVmYXVsdEJzUG9wcGVyQ29uZmlnKSA6IHRoaXMuX2NvbmZpZy5wb3BwZXJDb25maWcpXG4gICAgfVxuICB9XG5cbiAgX2FkZEF0dGFjaG1lbnRDbGFzcyhhdHRhY2htZW50KSB7XG4gICAgdGhpcy5nZXRUaXBFbGVtZW50KCkuY2xhc3NMaXN0LmFkZChgJHtDTEFTU19QUkVGSVh9LSR7dGhpcy51cGRhdGVBdHRhY2htZW50KGF0dGFjaG1lbnQpfWApXG4gIH1cblxuICBfZ2V0QXR0YWNobWVudChwbGFjZW1lbnQpIHtcbiAgICByZXR1cm4gQXR0YWNobWVudE1hcFtwbGFjZW1lbnQudG9VcHBlckNhc2UoKV1cbiAgfVxuXG4gIF9zZXRMaXN0ZW5lcnMoKSB7XG4gICAgY29uc3QgdHJpZ2dlcnMgPSB0aGlzLl9jb25maWcudHJpZ2dlci5zcGxpdCgnICcpXG5cbiAgICB0cmlnZ2Vycy5mb3JFYWNoKHRyaWdnZXIgPT4ge1xuICAgICAgaWYgKHRyaWdnZXIgPT09ICdjbGljaycpIHtcbiAgICAgICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2VsZW1lbnQsIHRoaXMuY29uc3RydWN0b3IuRXZlbnQuQ0xJQ0ssIHRoaXMuX2NvbmZpZy5zZWxlY3RvciwgZXZlbnQgPT4gdGhpcy50b2dnbGUoZXZlbnQpKVxuICAgICAgfSBlbHNlIGlmICh0cmlnZ2VyICE9PSBUUklHR0VSX01BTlVBTCkge1xuICAgICAgICBjb25zdCBldmVudEluID0gdHJpZ2dlciA9PT0gVFJJR0dFUl9IT1ZFUiA/XG4gICAgICAgICAgdGhpcy5jb25zdHJ1Y3Rvci5FdmVudC5NT1VTRUVOVEVSIDpcbiAgICAgICAgICB0aGlzLmNvbnN0cnVjdG9yLkV2ZW50LkZPQ1VTSU5cbiAgICAgICAgY29uc3QgZXZlbnRPdXQgPSB0cmlnZ2VyID09PSBUUklHR0VSX0hPVkVSID9cbiAgICAgICAgICB0aGlzLmNvbnN0cnVjdG9yLkV2ZW50Lk1PVVNFTEVBVkUgOlxuICAgICAgICAgIHRoaXMuY29uc3RydWN0b3IuRXZlbnQuRk9DVVNPVVRcblxuICAgICAgICBFdmVudEhhbmRsZXIub24odGhpcy5fZWxlbWVudCwgZXZlbnRJbiwgdGhpcy5fY29uZmlnLnNlbGVjdG9yLCBldmVudCA9PiB0aGlzLl9lbnRlcihldmVudCkpXG4gICAgICAgIEV2ZW50SGFuZGxlci5vbih0aGlzLl9lbGVtZW50LCBldmVudE91dCwgdGhpcy5fY29uZmlnLnNlbGVjdG9yLCBldmVudCA9PiB0aGlzLl9sZWF2ZShldmVudCkpXG4gICAgICB9XG4gICAgfSlcblxuICAgIHRoaXMuX2hpZGVNb2RhbEhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICBpZiAodGhpcy5fZWxlbWVudCkge1xuICAgICAgICB0aGlzLmhpZGUoKVxuICAgICAgfVxuICAgIH1cblxuICAgIEV2ZW50SGFuZGxlci5vbih0aGlzLl9lbGVtZW50LmNsb3Nlc3QoYC4ke0NMQVNTX05BTUVfTU9EQUx9YCksICdoaWRlLmJzLm1vZGFsJywgdGhpcy5faGlkZU1vZGFsSGFuZGxlcilcblxuICAgIGlmICh0aGlzLl9jb25maWcuc2VsZWN0b3IpIHtcbiAgICAgIHRoaXMuX2NvbmZpZyA9IHtcbiAgICAgICAgLi4udGhpcy5fY29uZmlnLFxuICAgICAgICB0cmlnZ2VyOiAnbWFudWFsJyxcbiAgICAgICAgc2VsZWN0b3I6ICcnXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2ZpeFRpdGxlKClcbiAgICB9XG4gIH1cblxuICBfZml4VGl0bGUoKSB7XG4gICAgY29uc3QgdGl0bGUgPSB0aGlzLl9lbGVtZW50LmdldEF0dHJpYnV0ZSgndGl0bGUnKVxuICAgIGNvbnN0IG9yaWdpbmFsVGl0bGVUeXBlID0gdHlwZW9mIHRoaXMuX2VsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLWJzLW9yaWdpbmFsLXRpdGxlJylcblxuICAgIGlmICh0aXRsZSB8fCBvcmlnaW5hbFRpdGxlVHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKCdkYXRhLWJzLW9yaWdpbmFsLXRpdGxlJywgdGl0bGUgfHwgJycpXG4gICAgICBpZiAodGl0bGUgJiYgIXRoaXMuX2VsZW1lbnQuZ2V0QXR0cmlidXRlKCdhcmlhLWxhYmVsJykgJiYgIXRoaXMuX2VsZW1lbnQudGV4dENvbnRlbnQpIHtcbiAgICAgICAgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtbGFiZWwnLCB0aXRsZSlcbiAgICAgIH1cblxuICAgICAgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3RpdGxlJywgJycpXG4gICAgfVxuICB9XG5cbiAgX2VudGVyKGV2ZW50LCBjb250ZXh0KSB7XG4gICAgY29udGV4dCA9IHRoaXMuX2luaXRpYWxpemVPbkRlbGVnYXRlZFRhcmdldChldmVudCwgY29udGV4dClcblxuICAgIGlmIChldmVudCkge1xuICAgICAgY29udGV4dC5fYWN0aXZlVHJpZ2dlcltcbiAgICAgICAgZXZlbnQudHlwZSA9PT0gJ2ZvY3VzaW4nID8gVFJJR0dFUl9GT0NVUyA6IFRSSUdHRVJfSE9WRVJcbiAgICAgIF0gPSB0cnVlXG4gICAgfVxuXG4gICAgaWYgKGNvbnRleHQuZ2V0VGlwRWxlbWVudCgpLmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX1NIT1cpIHx8IGNvbnRleHQuX2hvdmVyU3RhdGUgPT09IEhPVkVSX1NUQVRFX1NIT1cpIHtcbiAgICAgIGNvbnRleHQuX2hvdmVyU3RhdGUgPSBIT1ZFUl9TVEFURV9TSE9XXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjbGVhclRpbWVvdXQoY29udGV4dC5fdGltZW91dClcblxuICAgIGNvbnRleHQuX2hvdmVyU3RhdGUgPSBIT1ZFUl9TVEFURV9TSE9XXG5cbiAgICBpZiAoIWNvbnRleHQuX2NvbmZpZy5kZWxheSB8fCAhY29udGV4dC5fY29uZmlnLmRlbGF5LnNob3cpIHtcbiAgICAgIGNvbnRleHQuc2hvdygpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb250ZXh0Ll90aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBpZiAoY29udGV4dC5faG92ZXJTdGF0ZSA9PT0gSE9WRVJfU1RBVEVfU0hPVykge1xuICAgICAgICBjb250ZXh0LnNob3coKVxuICAgICAgfVxuICAgIH0sIGNvbnRleHQuX2NvbmZpZy5kZWxheS5zaG93KVxuICB9XG5cbiAgX2xlYXZlKGV2ZW50LCBjb250ZXh0KSB7XG4gICAgY29udGV4dCA9IHRoaXMuX2luaXRpYWxpemVPbkRlbGVnYXRlZFRhcmdldChldmVudCwgY29udGV4dClcblxuICAgIGlmIChldmVudCkge1xuICAgICAgY29udGV4dC5fYWN0aXZlVHJpZ2dlcltcbiAgICAgICAgZXZlbnQudHlwZSA9PT0gJ2ZvY3Vzb3V0JyA/IFRSSUdHRVJfRk9DVVMgOiBUUklHR0VSX0hPVkVSXG4gICAgICBdID0gY29udGV4dC5fZWxlbWVudC5jb250YWlucyhldmVudC5yZWxhdGVkVGFyZ2V0KVxuICAgIH1cblxuICAgIGlmIChjb250ZXh0Ll9pc1dpdGhBY3RpdmVUcmlnZ2VyKCkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNsZWFyVGltZW91dChjb250ZXh0Ll90aW1lb3V0KVxuXG4gICAgY29udGV4dC5faG92ZXJTdGF0ZSA9IEhPVkVSX1NUQVRFX09VVFxuXG4gICAgaWYgKCFjb250ZXh0Ll9jb25maWcuZGVsYXkgfHwgIWNvbnRleHQuX2NvbmZpZy5kZWxheS5oaWRlKSB7XG4gICAgICBjb250ZXh0LmhpZGUoKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29udGV4dC5fdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgaWYgKGNvbnRleHQuX2hvdmVyU3RhdGUgPT09IEhPVkVSX1NUQVRFX09VVCkge1xuICAgICAgICBjb250ZXh0LmhpZGUoKVxuICAgICAgfVxuICAgIH0sIGNvbnRleHQuX2NvbmZpZy5kZWxheS5oaWRlKVxuICB9XG5cbiAgX2lzV2l0aEFjdGl2ZVRyaWdnZXIoKSB7XG4gICAgZm9yIChjb25zdCB0cmlnZ2VyIGluIHRoaXMuX2FjdGl2ZVRyaWdnZXIpIHtcbiAgICAgIGlmICh0aGlzLl9hY3RpdmVUcmlnZ2VyW3RyaWdnZXJdKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBfZ2V0Q29uZmlnKGNvbmZpZykge1xuICAgIGNvbnN0IGRhdGFBdHRyaWJ1dGVzID0gTWFuaXB1bGF0b3IuZ2V0RGF0YUF0dHJpYnV0ZXModGhpcy5fZWxlbWVudClcblxuICAgIE9iamVjdC5rZXlzKGRhdGFBdHRyaWJ1dGVzKS5mb3JFYWNoKGRhdGFBdHRyID0+IHtcbiAgICAgIGlmIChESVNBTExPV0VEX0FUVFJJQlVURVMuaGFzKGRhdGFBdHRyKSkge1xuICAgICAgICBkZWxldGUgZGF0YUF0dHJpYnV0ZXNbZGF0YUF0dHJdXG4gICAgICB9XG4gICAgfSlcblxuICAgIGNvbmZpZyA9IHtcbiAgICAgIC4uLnRoaXMuY29uc3RydWN0b3IuRGVmYXVsdCxcbiAgICAgIC4uLmRhdGFBdHRyaWJ1dGVzLFxuICAgICAgLi4uKHR5cGVvZiBjb25maWcgPT09ICdvYmplY3QnICYmIGNvbmZpZyA/IGNvbmZpZyA6IHt9KVxuICAgIH1cblxuICAgIGNvbmZpZy5jb250YWluZXIgPSBjb25maWcuY29udGFpbmVyID09PSBmYWxzZSA/IGRvY3VtZW50LmJvZHkgOiBnZXRFbGVtZW50KGNvbmZpZy5jb250YWluZXIpXG5cbiAgICBpZiAodHlwZW9mIGNvbmZpZy5kZWxheSA9PT0gJ251bWJlcicpIHtcbiAgICAgIGNvbmZpZy5kZWxheSA9IHtcbiAgICAgICAgc2hvdzogY29uZmlnLmRlbGF5LFxuICAgICAgICBoaWRlOiBjb25maWcuZGVsYXlcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGNvbmZpZy50aXRsZSA9PT0gJ251bWJlcicpIHtcbiAgICAgIGNvbmZpZy50aXRsZSA9IGNvbmZpZy50aXRsZS50b1N0cmluZygpXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBjb25maWcuY29udGVudCA9PT0gJ251bWJlcicpIHtcbiAgICAgIGNvbmZpZy5jb250ZW50ID0gY29uZmlnLmNvbnRlbnQudG9TdHJpbmcoKVxuICAgIH1cblxuICAgIHR5cGVDaGVja0NvbmZpZyhOQU1FLCBjb25maWcsIHRoaXMuY29uc3RydWN0b3IuRGVmYXVsdFR5cGUpXG5cbiAgICBpZiAoY29uZmlnLnNhbml0aXplKSB7XG4gICAgICBjb25maWcudGVtcGxhdGUgPSBzYW5pdGl6ZUh0bWwoY29uZmlnLnRlbXBsYXRlLCBjb25maWcuYWxsb3dMaXN0LCBjb25maWcuc2FuaXRpemVGbilcbiAgICB9XG5cbiAgICByZXR1cm4gY29uZmlnXG4gIH1cblxuICBfZ2V0RGVsZWdhdGVDb25maWcoKSB7XG4gICAgY29uc3QgY29uZmlnID0ge31cblxuICAgIGlmICh0aGlzLl9jb25maWcpIHtcbiAgICAgIGZvciAoY29uc3Qga2V5IGluIHRoaXMuX2NvbmZpZykge1xuICAgICAgICBpZiAodGhpcy5jb25zdHJ1Y3Rvci5EZWZhdWx0W2tleV0gIT09IHRoaXMuX2NvbmZpZ1trZXldKSB7XG4gICAgICAgICAgY29uZmlnW2tleV0gPSB0aGlzLl9jb25maWdba2V5XVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbmZpZ1xuICB9XG5cbiAgX2NsZWFuVGlwQ2xhc3MoKSB7XG4gICAgY29uc3QgdGlwID0gdGhpcy5nZXRUaXBFbGVtZW50KClcbiAgICBjb25zdCB0YWJDbGFzcyA9IHRpcC5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykubWF0Y2goQlNDTFNfUFJFRklYX1JFR0VYKVxuICAgIGlmICh0YWJDbGFzcyAhPT0gbnVsbCAmJiB0YWJDbGFzcy5sZW5ndGggPiAwKSB7XG4gICAgICB0YWJDbGFzcy5tYXAodG9rZW4gPT4gdG9rZW4udHJpbSgpKVxuICAgICAgICAuZm9yRWFjaCh0Q2xhc3MgPT4gdGlwLmNsYXNzTGlzdC5yZW1vdmUodENsYXNzKSlcbiAgICB9XG4gIH1cblxuICBfaGFuZGxlUG9wcGVyUGxhY2VtZW50Q2hhbmdlKHBvcHBlckRhdGEpIHtcbiAgICBjb25zdCB7IHN0YXRlIH0gPSBwb3BwZXJEYXRhXG5cbiAgICBpZiAoIXN0YXRlKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLnRpcCA9IHN0YXRlLmVsZW1lbnRzLnBvcHBlclxuICAgIHRoaXMuX2NsZWFuVGlwQ2xhc3MoKVxuICAgIHRoaXMuX2FkZEF0dGFjaG1lbnRDbGFzcyh0aGlzLl9nZXRBdHRhY2htZW50KHN0YXRlLnBsYWNlbWVudCkpXG4gIH1cblxuICAvLyBTdGF0aWNcblxuICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKGNvbmZpZykge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgY29uc3QgZGF0YSA9IFRvb2x0aXAuZ2V0T3JDcmVhdGVJbnN0YW5jZSh0aGlzLCBjb25maWcpXG5cbiAgICAgIGlmICh0eXBlb2YgY29uZmlnID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAodHlwZW9mIGRhdGFbY29uZmlnXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXCIke2NvbmZpZ31cImApXG4gICAgICAgIH1cblxuICAgICAgICBkYXRhW2NvbmZpZ10oKVxuICAgICAgfVxuICAgIH0pXG4gIH1cbn1cblxuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIGpRdWVyeVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBhZGQgLlRvb2x0aXAgdG8galF1ZXJ5IG9ubHkgaWYgalF1ZXJ5IGlzIHByZXNlbnRcbiAqL1xuXG5kZWZpbmVKUXVlcnlQbHVnaW4oVG9vbHRpcClcblxuZXhwb3J0IGRlZmF1bHQgVG9vbHRpcFxuIiwiLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQm9vdHN0cmFwICh2NS4wLjIpOiBwb3BvdmVyLmpzXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuaW1wb3J0IHsgZGVmaW5lSlF1ZXJ5UGx1Z2luIH0gZnJvbSAnLi91dGlsL2luZGV4J1xuaW1wb3J0IFNlbGVjdG9yRW5naW5lIGZyb20gJy4vZG9tL3NlbGVjdG9yLWVuZ2luZSdcbmltcG9ydCBUb29sdGlwIGZyb20gJy4vdG9vbHRpcCdcblxuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvbnN0YW50c1xuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuY29uc3QgTkFNRSA9ICdwb3BvdmVyJ1xuY29uc3QgREFUQV9LRVkgPSAnYnMucG9wb3ZlcidcbmNvbnN0IEVWRU5UX0tFWSA9IGAuJHtEQVRBX0tFWX1gXG5jb25zdCBDTEFTU19QUkVGSVggPSAnYnMtcG9wb3ZlcidcbmNvbnN0IEJTQ0xTX1BSRUZJWF9SRUdFWCA9IG5ldyBSZWdFeHAoYChefFxcXFxzKSR7Q0xBU1NfUFJFRklYfVxcXFxTK2AsICdnJylcblxuY29uc3QgRGVmYXVsdCA9IHtcbiAgLi4uVG9vbHRpcC5EZWZhdWx0LFxuICBwbGFjZW1lbnQ6ICdyaWdodCcsXG4gIG9mZnNldDogWzAsIDhdLFxuICB0cmlnZ2VyOiAnY2xpY2snLFxuICBjb250ZW50OiAnJyxcbiAgdGVtcGxhdGU6ICc8ZGl2IGNsYXNzPVwicG9wb3ZlclwiIHJvbGU9XCJ0b29sdGlwXCI+JyArXG4gICAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwicG9wb3Zlci1hcnJvd1wiPjwvZGl2PicgK1xuICAgICAgICAgICAgICAnPGgzIGNsYXNzPVwicG9wb3Zlci1oZWFkZXJcIj48L2gzPicgK1xuICAgICAgICAgICAgICAnPGRpdiBjbGFzcz1cInBvcG92ZXItYm9keVwiPjwvZGl2PicgK1xuICAgICAgICAgICAgJzwvZGl2Pidcbn1cblxuY29uc3QgRGVmYXVsdFR5cGUgPSB7XG4gIC4uLlRvb2x0aXAuRGVmYXVsdFR5cGUsXG4gIGNvbnRlbnQ6ICcoc3RyaW5nfGVsZW1lbnR8ZnVuY3Rpb24pJ1xufVxuXG5jb25zdCBFdmVudCA9IHtcbiAgSElERTogYGhpZGUke0VWRU5UX0tFWX1gLFxuICBISURERU46IGBoaWRkZW4ke0VWRU5UX0tFWX1gLFxuICBTSE9XOiBgc2hvdyR7RVZFTlRfS0VZfWAsXG4gIFNIT1dOOiBgc2hvd24ke0VWRU5UX0tFWX1gLFxuICBJTlNFUlRFRDogYGluc2VydGVkJHtFVkVOVF9LRVl9YCxcbiAgQ0xJQ0s6IGBjbGljayR7RVZFTlRfS0VZfWAsXG4gIEZPQ1VTSU46IGBmb2N1c2luJHtFVkVOVF9LRVl9YCxcbiAgRk9DVVNPVVQ6IGBmb2N1c291dCR7RVZFTlRfS0VZfWAsXG4gIE1PVVNFRU5URVI6IGBtb3VzZWVudGVyJHtFVkVOVF9LRVl9YCxcbiAgTU9VU0VMRUFWRTogYG1vdXNlbGVhdmUke0VWRU5UX0tFWX1gXG59XG5cbmNvbnN0IENMQVNTX05BTUVfRkFERSA9ICdmYWRlJ1xuY29uc3QgQ0xBU1NfTkFNRV9TSE9XID0gJ3Nob3cnXG5cbmNvbnN0IFNFTEVDVE9SX1RJVExFID0gJy5wb3BvdmVyLWhlYWRlcidcbmNvbnN0IFNFTEVDVE9SX0NPTlRFTlQgPSAnLnBvcG92ZXItYm9keSdcblxuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENsYXNzIERlZmluaXRpb25cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbmNsYXNzIFBvcG92ZXIgZXh0ZW5kcyBUb29sdGlwIHtcbiAgLy8gR2V0dGVyc1xuXG4gIHN0YXRpYyBnZXQgRGVmYXVsdCgpIHtcbiAgICByZXR1cm4gRGVmYXVsdFxuICB9XG5cbiAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgIHJldHVybiBOQU1FXG4gIH1cblxuICBzdGF0aWMgZ2V0IEV2ZW50KCkge1xuICAgIHJldHVybiBFdmVudFxuICB9XG5cbiAgc3RhdGljIGdldCBEZWZhdWx0VHlwZSgpIHtcbiAgICByZXR1cm4gRGVmYXVsdFR5cGVcbiAgfVxuXG4gIC8vIE92ZXJyaWRlc1xuXG4gIGlzV2l0aENvbnRlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0VGl0bGUoKSB8fCB0aGlzLl9nZXRDb250ZW50KClcbiAgfVxuXG4gIGdldFRpcEVsZW1lbnQoKSB7XG4gICAgaWYgKHRoaXMudGlwKSB7XG4gICAgICByZXR1cm4gdGhpcy50aXBcbiAgICB9XG5cbiAgICB0aGlzLnRpcCA9IHN1cGVyLmdldFRpcEVsZW1lbnQoKVxuXG4gICAgaWYgKCF0aGlzLmdldFRpdGxlKCkpIHtcbiAgICAgIFNlbGVjdG9yRW5naW5lLmZpbmRPbmUoU0VMRUNUT1JfVElUTEUsIHRoaXMudGlwKS5yZW1vdmUoKVxuICAgIH1cblxuICAgIGlmICghdGhpcy5fZ2V0Q29udGVudCgpKSB7XG4gICAgICBTZWxlY3RvckVuZ2luZS5maW5kT25lKFNFTEVDVE9SX0NPTlRFTlQsIHRoaXMudGlwKS5yZW1vdmUoKVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnRpcFxuICB9XG5cbiAgc2V0Q29udGVudCgpIHtcbiAgICBjb25zdCB0aXAgPSB0aGlzLmdldFRpcEVsZW1lbnQoKVxuXG4gICAgLy8gd2UgdXNlIGFwcGVuZCBmb3IgaHRtbCBvYmplY3RzIHRvIG1haW50YWluIGpzIGV2ZW50c1xuICAgIHRoaXMuc2V0RWxlbWVudENvbnRlbnQoU2VsZWN0b3JFbmdpbmUuZmluZE9uZShTRUxFQ1RPUl9USVRMRSwgdGlwKSwgdGhpcy5nZXRUaXRsZSgpKVxuICAgIGxldCBjb250ZW50ID0gdGhpcy5fZ2V0Q29udGVudCgpXG4gICAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb250ZW50ID0gY29udGVudC5jYWxsKHRoaXMuX2VsZW1lbnQpXG4gICAgfVxuXG4gICAgdGhpcy5zZXRFbGVtZW50Q29udGVudChTZWxlY3RvckVuZ2luZS5maW5kT25lKFNFTEVDVE9SX0NPTlRFTlQsIHRpcCksIGNvbnRlbnQpXG5cbiAgICB0aXAuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19OQU1FX0ZBREUsIENMQVNTX05BTUVfU0hPVylcbiAgfVxuXG4gIC8vIFByaXZhdGVcblxuICBfYWRkQXR0YWNobWVudENsYXNzKGF0dGFjaG1lbnQpIHtcbiAgICB0aGlzLmdldFRpcEVsZW1lbnQoKS5jbGFzc0xpc3QuYWRkKGAke0NMQVNTX1BSRUZJWH0tJHt0aGlzLnVwZGF0ZUF0dGFjaG1lbnQoYXR0YWNobWVudCl9YClcbiAgfVxuXG4gIF9nZXRDb250ZW50KCkge1xuICAgIHJldHVybiB0aGlzLl9lbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1icy1jb250ZW50JykgfHwgdGhpcy5fY29uZmlnLmNvbnRlbnRcbiAgfVxuXG4gIF9jbGVhblRpcENsYXNzKCkge1xuICAgIGNvbnN0IHRpcCA9IHRoaXMuZ2V0VGlwRWxlbWVudCgpXG4gICAgY29uc3QgdGFiQ2xhc3MgPSB0aXAuZ2V0QXR0cmlidXRlKCdjbGFzcycpLm1hdGNoKEJTQ0xTX1BSRUZJWF9SRUdFWClcbiAgICBpZiAodGFiQ2xhc3MgIT09IG51bGwgJiYgdGFiQ2xhc3MubGVuZ3RoID4gMCkge1xuICAgICAgdGFiQ2xhc3MubWFwKHRva2VuID0+IHRva2VuLnRyaW0oKSlcbiAgICAgICAgLmZvckVhY2godENsYXNzID0+IHRpcC5jbGFzc0xpc3QucmVtb3ZlKHRDbGFzcykpXG4gICAgfVxuICB9XG5cbiAgLy8gU3RhdGljXG5cbiAgc3RhdGljIGpRdWVyeUludGVyZmFjZShjb25maWcpIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIGNvbnN0IGRhdGEgPSBQb3BvdmVyLmdldE9yQ3JlYXRlSW5zdGFuY2UodGhpcywgY29uZmlnKVxuXG4gICAgICBpZiAodHlwZW9mIGNvbmZpZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhW2NvbmZpZ10gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHtjb25maWd9XCJgKVxuICAgICAgICB9XG5cbiAgICAgICAgZGF0YVtjb25maWddKClcbiAgICAgIH1cbiAgICB9KVxuICB9XG59XG5cbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBqUXVlcnlcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogYWRkIC5Qb3BvdmVyIHRvIGpRdWVyeSBvbmx5IGlmIGpRdWVyeSBpcyBwcmVzZW50XG4gKi9cblxuZGVmaW5lSlF1ZXJ5UGx1Z2luKFBvcG92ZXIpXG5cbmV4cG9ydCBkZWZhdWx0IFBvcG92ZXJcbiIsIi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEJvb3RzdHJhcCAodjUuMC4yKTogc2Nyb2xsc3B5LmpzXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuaW1wb3J0IHtcbiAgZGVmaW5lSlF1ZXJ5UGx1Z2luLFxuICBnZXRTZWxlY3RvckZyb21FbGVtZW50LFxuICBnZXRVSUQsXG4gIGlzRWxlbWVudCxcbiAgdHlwZUNoZWNrQ29uZmlnXG59IGZyb20gJy4vdXRpbC9pbmRleCdcbmltcG9ydCBFdmVudEhhbmRsZXIgZnJvbSAnLi9kb20vZXZlbnQtaGFuZGxlcidcbmltcG9ydCBNYW5pcHVsYXRvciBmcm9tICcuL2RvbS9tYW5pcHVsYXRvcidcbmltcG9ydCBTZWxlY3RvckVuZ2luZSBmcm9tICcuL2RvbS9zZWxlY3Rvci1lbmdpbmUnXG5pbXBvcnQgQmFzZUNvbXBvbmVudCBmcm9tICcuL2Jhc2UtY29tcG9uZW50J1xuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29uc3RhbnRzXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5jb25zdCBOQU1FID0gJ3Njcm9sbHNweSdcbmNvbnN0IERBVEFfS0VZID0gJ2JzLnNjcm9sbHNweSdcbmNvbnN0IEVWRU5UX0tFWSA9IGAuJHtEQVRBX0tFWX1gXG5jb25zdCBEQVRBX0FQSV9LRVkgPSAnLmRhdGEtYXBpJ1xuXG5jb25zdCBEZWZhdWx0ID0ge1xuICBvZmZzZXQ6IDEwLFxuICBtZXRob2Q6ICdhdXRvJyxcbiAgdGFyZ2V0OiAnJ1xufVxuXG5jb25zdCBEZWZhdWx0VHlwZSA9IHtcbiAgb2Zmc2V0OiAnbnVtYmVyJyxcbiAgbWV0aG9kOiAnc3RyaW5nJyxcbiAgdGFyZ2V0OiAnKHN0cmluZ3xlbGVtZW50KSdcbn1cblxuY29uc3QgRVZFTlRfQUNUSVZBVEUgPSBgYWN0aXZhdGUke0VWRU5UX0tFWX1gXG5jb25zdCBFVkVOVF9TQ1JPTEwgPSBgc2Nyb2xsJHtFVkVOVF9LRVl9YFxuY29uc3QgRVZFTlRfTE9BRF9EQVRBX0FQSSA9IGBsb2FkJHtFVkVOVF9LRVl9JHtEQVRBX0FQSV9LRVl9YFxuXG5jb25zdCBDTEFTU19OQU1FX0RST1BET1dOX0lURU0gPSAnZHJvcGRvd24taXRlbSdcbmNvbnN0IENMQVNTX05BTUVfQUNUSVZFID0gJ2FjdGl2ZSdcblxuY29uc3QgU0VMRUNUT1JfREFUQV9TUFkgPSAnW2RhdGEtYnMtc3B5PVwic2Nyb2xsXCJdJ1xuY29uc3QgU0VMRUNUT1JfTkFWX0xJU1RfR1JPVVAgPSAnLm5hdiwgLmxpc3QtZ3JvdXAnXG5jb25zdCBTRUxFQ1RPUl9OQVZfTElOS1MgPSAnLm5hdi1saW5rJ1xuY29uc3QgU0VMRUNUT1JfTkFWX0lURU1TID0gJy5uYXYtaXRlbSdcbmNvbnN0IFNFTEVDVE9SX0xJU1RfSVRFTVMgPSAnLmxpc3QtZ3JvdXAtaXRlbSdcbmNvbnN0IFNFTEVDVE9SX0RST1BET1dOID0gJy5kcm9wZG93bidcbmNvbnN0IFNFTEVDVE9SX0RST1BET1dOX1RPR0dMRSA9ICcuZHJvcGRvd24tdG9nZ2xlJ1xuXG5jb25zdCBNRVRIT0RfT0ZGU0VUID0gJ29mZnNldCdcbmNvbnN0IE1FVEhPRF9QT1NJVElPTiA9ICdwb3NpdGlvbidcblxuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENsYXNzIERlZmluaXRpb25cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbmNsYXNzIFNjcm9sbFNweSBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvcihlbGVtZW50LCBjb25maWcpIHtcbiAgICBzdXBlcihlbGVtZW50KVxuICAgIHRoaXMuX3Njcm9sbEVsZW1lbnQgPSB0aGlzLl9lbGVtZW50LnRhZ05hbWUgPT09ICdCT0RZJyA/IHdpbmRvdyA6IHRoaXMuX2VsZW1lbnRcbiAgICB0aGlzLl9jb25maWcgPSB0aGlzLl9nZXRDb25maWcoY29uZmlnKVxuICAgIHRoaXMuX3NlbGVjdG9yID0gYCR7dGhpcy5fY29uZmlnLnRhcmdldH0gJHtTRUxFQ1RPUl9OQVZfTElOS1N9LCAke3RoaXMuX2NvbmZpZy50YXJnZXR9ICR7U0VMRUNUT1JfTElTVF9JVEVNU30sICR7dGhpcy5fY29uZmlnLnRhcmdldH0gLiR7Q0xBU1NfTkFNRV9EUk9QRE9XTl9JVEVNfWBcbiAgICB0aGlzLl9vZmZzZXRzID0gW11cbiAgICB0aGlzLl90YXJnZXRzID0gW11cbiAgICB0aGlzLl9hY3RpdmVUYXJnZXQgPSBudWxsXG4gICAgdGhpcy5fc2Nyb2xsSGVpZ2h0ID0gMFxuXG4gICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX3Njcm9sbEVsZW1lbnQsIEVWRU5UX1NDUk9MTCwgKCkgPT4gdGhpcy5fcHJvY2VzcygpKVxuXG4gICAgdGhpcy5yZWZyZXNoKClcbiAgICB0aGlzLl9wcm9jZXNzKClcbiAgfVxuXG4gIC8vIEdldHRlcnNcblxuICBzdGF0aWMgZ2V0IERlZmF1bHQoKSB7XG4gICAgcmV0dXJuIERlZmF1bHRcbiAgfVxuXG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICByZXR1cm4gTkFNRVxuICB9XG5cbiAgLy8gUHVibGljXG5cbiAgcmVmcmVzaCgpIHtcbiAgICBjb25zdCBhdXRvTWV0aG9kID0gdGhpcy5fc2Nyb2xsRWxlbWVudCA9PT0gdGhpcy5fc2Nyb2xsRWxlbWVudC53aW5kb3cgP1xuICAgICAgTUVUSE9EX09GRlNFVCA6XG4gICAgICBNRVRIT0RfUE9TSVRJT05cblxuICAgIGNvbnN0IG9mZnNldE1ldGhvZCA9IHRoaXMuX2NvbmZpZy5tZXRob2QgPT09ICdhdXRvJyA/XG4gICAgICBhdXRvTWV0aG9kIDpcbiAgICAgIHRoaXMuX2NvbmZpZy5tZXRob2RcblxuICAgIGNvbnN0IG9mZnNldEJhc2UgPSBvZmZzZXRNZXRob2QgPT09IE1FVEhPRF9QT1NJVElPTiA/XG4gICAgICB0aGlzLl9nZXRTY3JvbGxUb3AoKSA6XG4gICAgICAwXG5cbiAgICB0aGlzLl9vZmZzZXRzID0gW11cbiAgICB0aGlzLl90YXJnZXRzID0gW11cbiAgICB0aGlzLl9zY3JvbGxIZWlnaHQgPSB0aGlzLl9nZXRTY3JvbGxIZWlnaHQoKVxuXG4gICAgY29uc3QgdGFyZ2V0cyA9IFNlbGVjdG9yRW5naW5lLmZpbmQodGhpcy5fc2VsZWN0b3IpXG5cbiAgICB0YXJnZXRzLm1hcChlbGVtZW50ID0+IHtcbiAgICAgIGNvbnN0IHRhcmdldFNlbGVjdG9yID0gZ2V0U2VsZWN0b3JGcm9tRWxlbWVudChlbGVtZW50KVxuICAgICAgY29uc3QgdGFyZ2V0ID0gdGFyZ2V0U2VsZWN0b3IgPyBTZWxlY3RvckVuZ2luZS5maW5kT25lKHRhcmdldFNlbGVjdG9yKSA6IG51bGxcblxuICAgICAgaWYgKHRhcmdldCkge1xuICAgICAgICBjb25zdCB0YXJnZXRCQ1IgPSB0YXJnZXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcbiAgICAgICAgaWYgKHRhcmdldEJDUi53aWR0aCB8fCB0YXJnZXRCQ1IuaGVpZ2h0KSB7XG4gICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIE1hbmlwdWxhdG9yW29mZnNldE1ldGhvZF0odGFyZ2V0KS50b3AgKyBvZmZzZXRCYXNlLFxuICAgICAgICAgICAgdGFyZ2V0U2VsZWN0b3JcbiAgICAgICAgICBdXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG51bGxcbiAgICB9KVxuICAgICAgLmZpbHRlcihpdGVtID0+IGl0ZW0pXG4gICAgICAuc29ydCgoYSwgYikgPT4gYVswXSAtIGJbMF0pXG4gICAgICAuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgdGhpcy5fb2Zmc2V0cy5wdXNoKGl0ZW1bMF0pXG4gICAgICAgIHRoaXMuX3RhcmdldHMucHVzaChpdGVtWzFdKVxuICAgICAgfSlcbiAgfVxuXG4gIGRpc3Bvc2UoKSB7XG4gICAgRXZlbnRIYW5kbGVyLm9mZih0aGlzLl9zY3JvbGxFbGVtZW50LCBFVkVOVF9LRVkpXG4gICAgc3VwZXIuZGlzcG9zZSgpXG4gIH1cblxuICAvLyBQcml2YXRlXG5cbiAgX2dldENvbmZpZyhjb25maWcpIHtcbiAgICBjb25maWcgPSB7XG4gICAgICAuLi5EZWZhdWx0LFxuICAgICAgLi4uTWFuaXB1bGF0b3IuZ2V0RGF0YUF0dHJpYnV0ZXModGhpcy5fZWxlbWVudCksXG4gICAgICAuLi4odHlwZW9mIGNvbmZpZyA9PT0gJ29iamVjdCcgJiYgY29uZmlnID8gY29uZmlnIDoge30pXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBjb25maWcudGFyZ2V0ICE9PSAnc3RyaW5nJyAmJiBpc0VsZW1lbnQoY29uZmlnLnRhcmdldCkpIHtcbiAgICAgIGxldCB7IGlkIH0gPSBjb25maWcudGFyZ2V0XG4gICAgICBpZiAoIWlkKSB7XG4gICAgICAgIGlkID0gZ2V0VUlEKE5BTUUpXG4gICAgICAgIGNvbmZpZy50YXJnZXQuaWQgPSBpZFxuICAgICAgfVxuXG4gICAgICBjb25maWcudGFyZ2V0ID0gYCMke2lkfWBcbiAgICB9XG5cbiAgICB0eXBlQ2hlY2tDb25maWcoTkFNRSwgY29uZmlnLCBEZWZhdWx0VHlwZSlcblxuICAgIHJldHVybiBjb25maWdcbiAgfVxuXG4gIF9nZXRTY3JvbGxUb3AoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Njcm9sbEVsZW1lbnQgPT09IHdpbmRvdyA/XG4gICAgICB0aGlzLl9zY3JvbGxFbGVtZW50LnBhZ2VZT2Zmc2V0IDpcbiAgICAgIHRoaXMuX3Njcm9sbEVsZW1lbnQuc2Nyb2xsVG9wXG4gIH1cblxuICBfZ2V0U2Nyb2xsSGVpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLl9zY3JvbGxFbGVtZW50LnNjcm9sbEhlaWdodCB8fCBNYXRoLm1heChcbiAgICAgIGRvY3VtZW50LmJvZHkuc2Nyb2xsSGVpZ2h0LFxuICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbEhlaWdodFxuICAgIClcbiAgfVxuXG4gIF9nZXRPZmZzZXRIZWlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Njcm9sbEVsZW1lbnQgPT09IHdpbmRvdyA/XG4gICAgICB3aW5kb3cuaW5uZXJIZWlnaHQgOlxuICAgICAgdGhpcy5fc2Nyb2xsRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHRcbiAgfVxuXG4gIF9wcm9jZXNzKCkge1xuICAgIGNvbnN0IHNjcm9sbFRvcCA9IHRoaXMuX2dldFNjcm9sbFRvcCgpICsgdGhpcy5fY29uZmlnLm9mZnNldFxuICAgIGNvbnN0IHNjcm9sbEhlaWdodCA9IHRoaXMuX2dldFNjcm9sbEhlaWdodCgpXG4gICAgY29uc3QgbWF4U2Nyb2xsID0gdGhpcy5fY29uZmlnLm9mZnNldCArIHNjcm9sbEhlaWdodCAtIHRoaXMuX2dldE9mZnNldEhlaWdodCgpXG5cbiAgICBpZiAodGhpcy5fc2Nyb2xsSGVpZ2h0ICE9PSBzY3JvbGxIZWlnaHQpIHtcbiAgICAgIHRoaXMucmVmcmVzaCgpXG4gICAgfVxuXG4gICAgaWYgKHNjcm9sbFRvcCA+PSBtYXhTY3JvbGwpIHtcbiAgICAgIGNvbnN0IHRhcmdldCA9IHRoaXMuX3RhcmdldHNbdGhpcy5fdGFyZ2V0cy5sZW5ndGggLSAxXVxuXG4gICAgICBpZiAodGhpcy5fYWN0aXZlVGFyZ2V0ICE9PSB0YXJnZXQpIHtcbiAgICAgICAgdGhpcy5fYWN0aXZhdGUodGFyZ2V0KVxuICAgICAgfVxuXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAodGhpcy5fYWN0aXZlVGFyZ2V0ICYmIHNjcm9sbFRvcCA8IHRoaXMuX29mZnNldHNbMF0gJiYgdGhpcy5fb2Zmc2V0c1swXSA+IDApIHtcbiAgICAgIHRoaXMuX2FjdGl2ZVRhcmdldCA9IG51bGxcbiAgICAgIHRoaXMuX2NsZWFyKClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSB0aGlzLl9vZmZzZXRzLmxlbmd0aDsgaS0tOykge1xuICAgICAgY29uc3QgaXNBY3RpdmVUYXJnZXQgPSB0aGlzLl9hY3RpdmVUYXJnZXQgIT09IHRoaXMuX3RhcmdldHNbaV0gJiZcbiAgICAgICAgICBzY3JvbGxUb3AgPj0gdGhpcy5fb2Zmc2V0c1tpXSAmJlxuICAgICAgICAgICh0eXBlb2YgdGhpcy5fb2Zmc2V0c1tpICsgMV0gPT09ICd1bmRlZmluZWQnIHx8IHNjcm9sbFRvcCA8IHRoaXMuX29mZnNldHNbaSArIDFdKVxuXG4gICAgICBpZiAoaXNBY3RpdmVUYXJnZXQpIHtcbiAgICAgICAgdGhpcy5fYWN0aXZhdGUodGhpcy5fdGFyZ2V0c1tpXSlcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBfYWN0aXZhdGUodGFyZ2V0KSB7XG4gICAgdGhpcy5fYWN0aXZlVGFyZ2V0ID0gdGFyZ2V0XG5cbiAgICB0aGlzLl9jbGVhcigpXG5cbiAgICBjb25zdCBxdWVyaWVzID0gdGhpcy5fc2VsZWN0b3Iuc3BsaXQoJywnKVxuICAgICAgLm1hcChzZWxlY3RvciA9PiBgJHtzZWxlY3Rvcn1bZGF0YS1icy10YXJnZXQ9XCIke3RhcmdldH1cIl0sJHtzZWxlY3Rvcn1baHJlZj1cIiR7dGFyZ2V0fVwiXWApXG5cbiAgICBjb25zdCBsaW5rID0gU2VsZWN0b3JFbmdpbmUuZmluZE9uZShxdWVyaWVzLmpvaW4oJywnKSlcblxuICAgIGlmIChsaW5rLmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX0RST1BET1dOX0lURU0pKSB7XG4gICAgICBTZWxlY3RvckVuZ2luZS5maW5kT25lKFNFTEVDVE9SX0RST1BET1dOX1RPR0dMRSwgbGluay5jbG9zZXN0KFNFTEVDVE9SX0RST1BET1dOKSlcbiAgICAgICAgLmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9BQ1RJVkUpXG5cbiAgICAgIGxpbmsuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX0FDVElWRSlcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gU2V0IHRyaWdnZXJlZCBsaW5rIGFzIGFjdGl2ZVxuICAgICAgbGluay5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfQUNUSVZFKVxuXG4gICAgICBTZWxlY3RvckVuZ2luZS5wYXJlbnRzKGxpbmssIFNFTEVDVE9SX05BVl9MSVNUX0dST1VQKVxuICAgICAgICAuZm9yRWFjaChsaXN0R3JvdXAgPT4ge1xuICAgICAgICAgIC8vIFNldCB0cmlnZ2VyZWQgbGlua3MgcGFyZW50cyBhcyBhY3RpdmVcbiAgICAgICAgICAvLyBXaXRoIGJvdGggPHVsPiBhbmQgPG5hdj4gbWFya3VwIGEgcGFyZW50IGlzIHRoZSBwcmV2aW91cyBzaWJsaW5nIG9mIGFueSBuYXYgYW5jZXN0b3JcbiAgICAgICAgICBTZWxlY3RvckVuZ2luZS5wcmV2KGxpc3RHcm91cCwgYCR7U0VMRUNUT1JfTkFWX0xJTktTfSwgJHtTRUxFQ1RPUl9MSVNUX0lURU1TfWApXG4gICAgICAgICAgICAuZm9yRWFjaChpdGVtID0+IGl0ZW0uY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX0FDVElWRSkpXG5cbiAgICAgICAgICAvLyBIYW5kbGUgc3BlY2lhbCBjYXNlIHdoZW4gLm5hdi1saW5rIGlzIGluc2lkZSAubmF2LWl0ZW1cbiAgICAgICAgICBTZWxlY3RvckVuZ2luZS5wcmV2KGxpc3RHcm91cCwgU0VMRUNUT1JfTkFWX0lURU1TKVxuICAgICAgICAgICAgLmZvckVhY2gobmF2SXRlbSA9PiB7XG4gICAgICAgICAgICAgIFNlbGVjdG9yRW5naW5lLmNoaWxkcmVuKG5hdkl0ZW0sIFNFTEVDVE9SX05BVl9MSU5LUylcbiAgICAgICAgICAgICAgICAuZm9yRWFjaChpdGVtID0+IGl0ZW0uY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX0FDVElWRSkpXG4gICAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX3Njcm9sbEVsZW1lbnQsIEVWRU5UX0FDVElWQVRFLCB7XG4gICAgICByZWxhdGVkVGFyZ2V0OiB0YXJnZXRcbiAgICB9KVxuICB9XG5cbiAgX2NsZWFyKCkge1xuICAgIFNlbGVjdG9yRW5naW5lLmZpbmQodGhpcy5fc2VsZWN0b3IpXG4gICAgICAuZmlsdGVyKG5vZGUgPT4gbm9kZS5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9BQ1RJVkUpKVxuICAgICAgLmZvckVhY2gobm9kZSA9PiBub2RlLmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9BQ1RJVkUpKVxuICB9XG5cbiAgLy8gU3RhdGljXG5cbiAgc3RhdGljIGpRdWVyeUludGVyZmFjZShjb25maWcpIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIGNvbnN0IGRhdGEgPSBTY3JvbGxTcHkuZ2V0T3JDcmVhdGVJbnN0YW5jZSh0aGlzLCBjb25maWcpXG5cbiAgICAgIGlmICh0eXBlb2YgY29uZmlnICE9PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBkYXRhW2NvbmZpZ10gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcIiR7Y29uZmlnfVwiYClcbiAgICAgIH1cblxuICAgICAgZGF0YVtjb25maWddKClcbiAgICB9KVxuICB9XG59XG5cbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBEYXRhIEFwaSBpbXBsZW1lbnRhdGlvblxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuRXZlbnRIYW5kbGVyLm9uKHdpbmRvdywgRVZFTlRfTE9BRF9EQVRBX0FQSSwgKCkgPT4ge1xuICBTZWxlY3RvckVuZ2luZS5maW5kKFNFTEVDVE9SX0RBVEFfU1BZKVxuICAgIC5mb3JFYWNoKHNweSA9PiBuZXcgU2Nyb2xsU3B5KHNweSkpXG59KVxuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogalF1ZXJ5XG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIGFkZCAuU2Nyb2xsU3B5IHRvIGpRdWVyeSBvbmx5IGlmIGpRdWVyeSBpcyBwcmVzZW50XG4gKi9cblxuZGVmaW5lSlF1ZXJ5UGx1Z2luKFNjcm9sbFNweSlcblxuZXhwb3J0IGRlZmF1bHQgU2Nyb2xsU3B5XG4iLCIvKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBCb290c3RyYXAgKHY1LjAuMik6IHRhYi5qc1xuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbmltcG9ydCB7XG4gIGRlZmluZUpRdWVyeVBsdWdpbixcbiAgZ2V0RWxlbWVudEZyb21TZWxlY3RvcixcbiAgaXNEaXNhYmxlZCxcbiAgcmVmbG93XG59IGZyb20gJy4vdXRpbC9pbmRleCdcbmltcG9ydCBFdmVudEhhbmRsZXIgZnJvbSAnLi9kb20vZXZlbnQtaGFuZGxlcidcbmltcG9ydCBTZWxlY3RvckVuZ2luZSBmcm9tICcuL2RvbS9zZWxlY3Rvci1lbmdpbmUnXG5pbXBvcnQgQmFzZUNvbXBvbmVudCBmcm9tICcuL2Jhc2UtY29tcG9uZW50J1xuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29uc3RhbnRzXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5jb25zdCBOQU1FID0gJ3RhYidcbmNvbnN0IERBVEFfS0VZID0gJ2JzLnRhYidcbmNvbnN0IEVWRU5UX0tFWSA9IGAuJHtEQVRBX0tFWX1gXG5jb25zdCBEQVRBX0FQSV9LRVkgPSAnLmRhdGEtYXBpJ1xuXG5jb25zdCBFVkVOVF9ISURFID0gYGhpZGUke0VWRU5UX0tFWX1gXG5jb25zdCBFVkVOVF9ISURERU4gPSBgaGlkZGVuJHtFVkVOVF9LRVl9YFxuY29uc3QgRVZFTlRfU0hPVyA9IGBzaG93JHtFVkVOVF9LRVl9YFxuY29uc3QgRVZFTlRfU0hPV04gPSBgc2hvd24ke0VWRU5UX0tFWX1gXG5jb25zdCBFVkVOVF9DTElDS19EQVRBX0FQSSA9IGBjbGljayR7RVZFTlRfS0VZfSR7REFUQV9BUElfS0VZfWBcblxuY29uc3QgQ0xBU1NfTkFNRV9EUk9QRE9XTl9NRU5VID0gJ2Ryb3Bkb3duLW1lbnUnXG5jb25zdCBDTEFTU19OQU1FX0FDVElWRSA9ICdhY3RpdmUnXG5jb25zdCBDTEFTU19OQU1FX0ZBREUgPSAnZmFkZSdcbmNvbnN0IENMQVNTX05BTUVfU0hPVyA9ICdzaG93J1xuXG5jb25zdCBTRUxFQ1RPUl9EUk9QRE9XTiA9ICcuZHJvcGRvd24nXG5jb25zdCBTRUxFQ1RPUl9OQVZfTElTVF9HUk9VUCA9ICcubmF2LCAubGlzdC1ncm91cCdcbmNvbnN0IFNFTEVDVE9SX0FDVElWRSA9ICcuYWN0aXZlJ1xuY29uc3QgU0VMRUNUT1JfQUNUSVZFX1VMID0gJzpzY29wZSA+IGxpID4gLmFjdGl2ZSdcbmNvbnN0IFNFTEVDVE9SX0RBVEFfVE9HR0xFID0gJ1tkYXRhLWJzLXRvZ2dsZT1cInRhYlwiXSwgW2RhdGEtYnMtdG9nZ2xlPVwicGlsbFwiXSwgW2RhdGEtYnMtdG9nZ2xlPVwibGlzdFwiXSdcbmNvbnN0IFNFTEVDVE9SX0RST1BET1dOX1RPR0dMRSA9ICcuZHJvcGRvd24tdG9nZ2xlJ1xuY29uc3QgU0VMRUNUT1JfRFJPUERPV05fQUNUSVZFX0NISUxEID0gJzpzY29wZSA+IC5kcm9wZG93bi1tZW51IC5hY3RpdmUnXG5cbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDbGFzcyBEZWZpbml0aW9uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5jbGFzcyBUYWIgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgLy8gR2V0dGVyc1xuXG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICByZXR1cm4gTkFNRVxuICB9XG5cbiAgLy8gUHVibGljXG5cbiAgc2hvdygpIHtcbiAgICBpZiAoKHRoaXMuX2VsZW1lbnQucGFyZW50Tm9kZSAmJlxuICAgICAgdGhpcy5fZWxlbWVudC5wYXJlbnROb2RlLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSAmJlxuICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9BQ1RJVkUpKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgbGV0IHByZXZpb3VzXG4gICAgY29uc3QgdGFyZ2V0ID0gZ2V0RWxlbWVudEZyb21TZWxlY3Rvcih0aGlzLl9lbGVtZW50KVxuICAgIGNvbnN0IGxpc3RFbGVtZW50ID0gdGhpcy5fZWxlbWVudC5jbG9zZXN0KFNFTEVDVE9SX05BVl9MSVNUX0dST1VQKVxuXG4gICAgaWYgKGxpc3RFbGVtZW50KSB7XG4gICAgICBjb25zdCBpdGVtU2VsZWN0b3IgPSBsaXN0RWxlbWVudC5ub2RlTmFtZSA9PT0gJ1VMJyB8fCBsaXN0RWxlbWVudC5ub2RlTmFtZSA9PT0gJ09MJyA/IFNFTEVDVE9SX0FDVElWRV9VTCA6IFNFTEVDVE9SX0FDVElWRVxuICAgICAgcHJldmlvdXMgPSBTZWxlY3RvckVuZ2luZS5maW5kKGl0ZW1TZWxlY3RvciwgbGlzdEVsZW1lbnQpXG4gICAgICBwcmV2aW91cyA9IHByZXZpb3VzW3ByZXZpb3VzLmxlbmd0aCAtIDFdXG4gICAgfVxuXG4gICAgY29uc3QgaGlkZUV2ZW50ID0gcHJldmlvdXMgP1xuICAgICAgRXZlbnRIYW5kbGVyLnRyaWdnZXIocHJldmlvdXMsIEVWRU5UX0hJREUsIHtcbiAgICAgICAgcmVsYXRlZFRhcmdldDogdGhpcy5fZWxlbWVudFxuICAgICAgfSkgOlxuICAgICAgbnVsbFxuXG4gICAgY29uc3Qgc2hvd0V2ZW50ID0gRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfU0hPVywge1xuICAgICAgcmVsYXRlZFRhcmdldDogcHJldmlvdXNcbiAgICB9KVxuXG4gICAgaWYgKHNob3dFdmVudC5kZWZhdWx0UHJldmVudGVkIHx8IChoaWRlRXZlbnQgIT09IG51bGwgJiYgaGlkZUV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLl9hY3RpdmF0ZSh0aGlzLl9lbGVtZW50LCBsaXN0RWxlbWVudClcblxuICAgIGNvbnN0IGNvbXBsZXRlID0gKCkgPT4ge1xuICAgICAgRXZlbnRIYW5kbGVyLnRyaWdnZXIocHJldmlvdXMsIEVWRU5UX0hJRERFTiwge1xuICAgICAgICByZWxhdGVkVGFyZ2V0OiB0aGlzLl9lbGVtZW50XG4gICAgICB9KVxuICAgICAgRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfU0hPV04sIHtcbiAgICAgICAgcmVsYXRlZFRhcmdldDogcHJldmlvdXNcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgaWYgKHRhcmdldCkge1xuICAgICAgdGhpcy5fYWN0aXZhdGUodGFyZ2V0LCB0YXJnZXQucGFyZW50Tm9kZSwgY29tcGxldGUpXG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbXBsZXRlKClcbiAgICB9XG4gIH1cblxuICAvLyBQcml2YXRlXG5cbiAgX2FjdGl2YXRlKGVsZW1lbnQsIGNvbnRhaW5lciwgY2FsbGJhY2spIHtcbiAgICBjb25zdCBhY3RpdmVFbGVtZW50cyA9IGNvbnRhaW5lciAmJiAoY29udGFpbmVyLm5vZGVOYW1lID09PSAnVUwnIHx8IGNvbnRhaW5lci5ub2RlTmFtZSA9PT0gJ09MJykgP1xuICAgICAgU2VsZWN0b3JFbmdpbmUuZmluZChTRUxFQ1RPUl9BQ1RJVkVfVUwsIGNvbnRhaW5lcikgOlxuICAgICAgU2VsZWN0b3JFbmdpbmUuY2hpbGRyZW4oY29udGFpbmVyLCBTRUxFQ1RPUl9BQ1RJVkUpXG5cbiAgICBjb25zdCBhY3RpdmUgPSBhY3RpdmVFbGVtZW50c1swXVxuICAgIGNvbnN0IGlzVHJhbnNpdGlvbmluZyA9IGNhbGxiYWNrICYmIChhY3RpdmUgJiYgYWN0aXZlLmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX0ZBREUpKVxuXG4gICAgY29uc3QgY29tcGxldGUgPSAoKSA9PiB0aGlzLl90cmFuc2l0aW9uQ29tcGxldGUoZWxlbWVudCwgYWN0aXZlLCBjYWxsYmFjaylcblxuICAgIGlmIChhY3RpdmUgJiYgaXNUcmFuc2l0aW9uaW5nKSB7XG4gICAgICBhY3RpdmUuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19OQU1FX1NIT1cpXG4gICAgICB0aGlzLl9xdWV1ZUNhbGxiYWNrKGNvbXBsZXRlLCBlbGVtZW50LCB0cnVlKVxuICAgIH0gZWxzZSB7XG4gICAgICBjb21wbGV0ZSgpXG4gICAgfVxuICB9XG5cbiAgX3RyYW5zaXRpb25Db21wbGV0ZShlbGVtZW50LCBhY3RpdmUsIGNhbGxiYWNrKSB7XG4gICAgaWYgKGFjdGl2ZSkge1xuICAgICAgYWN0aXZlLmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9BQ1RJVkUpXG5cbiAgICAgIGNvbnN0IGRyb3Bkb3duQ2hpbGQgPSBTZWxlY3RvckVuZ2luZS5maW5kT25lKFNFTEVDVE9SX0RST1BET1dOX0FDVElWRV9DSElMRCwgYWN0aXZlLnBhcmVudE5vZGUpXG5cbiAgICAgIGlmIChkcm9wZG93bkNoaWxkKSB7XG4gICAgICAgIGRyb3Bkb3duQ2hpbGQuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19OQU1FX0FDVElWRSlcbiAgICAgIH1cblxuICAgICAgaWYgKGFjdGl2ZS5nZXRBdHRyaWJ1dGUoJ3JvbGUnKSA9PT0gJ3RhYicpIHtcbiAgICAgICAgYWN0aXZlLnNldEF0dHJpYnV0ZSgnYXJpYS1zZWxlY3RlZCcsIGZhbHNlKVxuICAgICAgfVxuICAgIH1cblxuICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX0FDVElWRSlcbiAgICBpZiAoZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3JvbGUnKSA9PT0gJ3RhYicpIHtcbiAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLXNlbGVjdGVkJywgdHJ1ZSlcbiAgICB9XG5cbiAgICByZWZsb3coZWxlbWVudClcblxuICAgIGlmIChlbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX0ZBREUpKSB7XG4gICAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9TSE9XKVxuICAgIH1cblxuICAgIGxldCBwYXJlbnQgPSBlbGVtZW50LnBhcmVudE5vZGVcbiAgICBpZiAocGFyZW50ICYmIHBhcmVudC5ub2RlTmFtZSA9PT0gJ0xJJykge1xuICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudE5vZGVcbiAgICB9XG5cbiAgICBpZiAocGFyZW50ICYmIHBhcmVudC5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9EUk9QRE9XTl9NRU5VKSkge1xuICAgICAgY29uc3QgZHJvcGRvd25FbGVtZW50ID0gZWxlbWVudC5jbG9zZXN0KFNFTEVDVE9SX0RST1BET1dOKVxuXG4gICAgICBpZiAoZHJvcGRvd25FbGVtZW50KSB7XG4gICAgICAgIFNlbGVjdG9yRW5naW5lLmZpbmQoU0VMRUNUT1JfRFJPUERPV05fVE9HR0xFLCBkcm9wZG93bkVsZW1lbnQpXG4gICAgICAgICAgLmZvckVhY2goZHJvcGRvd24gPT4gZHJvcGRvd24uY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX0FDVElWRSkpXG4gICAgICB9XG5cbiAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLWV4cGFuZGVkJywgdHJ1ZSlcbiAgICB9XG5cbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIGNhbGxiYWNrKClcbiAgICB9XG4gIH1cblxuICAvLyBTdGF0aWNcblxuICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKGNvbmZpZykge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgY29uc3QgZGF0YSA9IFRhYi5nZXRPckNyZWF0ZUluc3RhbmNlKHRoaXMpXG5cbiAgICAgIGlmICh0eXBlb2YgY29uZmlnID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAodHlwZW9mIGRhdGFbY29uZmlnXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXCIke2NvbmZpZ31cImApXG4gICAgICAgIH1cblxuICAgICAgICBkYXRhW2NvbmZpZ10oKVxuICAgICAgfVxuICAgIH0pXG4gIH1cbn1cblxuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIERhdGEgQXBpIGltcGxlbWVudGF0aW9uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5FdmVudEhhbmRsZXIub24oZG9jdW1lbnQsIEVWRU5UX0NMSUNLX0RBVEFfQVBJLCBTRUxFQ1RPUl9EQVRBX1RPR0dMRSwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gIGlmIChbJ0EnLCAnQVJFQSddLmluY2x1ZGVzKHRoaXMudGFnTmFtZSkpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpXG4gIH1cblxuICBpZiAoaXNEaXNhYmxlZCh0aGlzKSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgY29uc3QgZGF0YSA9IFRhYi5nZXRPckNyZWF0ZUluc3RhbmNlKHRoaXMpXG4gIGRhdGEuc2hvdygpXG59KVxuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogalF1ZXJ5XG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIGFkZCAuVGFiIHRvIGpRdWVyeSBvbmx5IGlmIGpRdWVyeSBpcyBwcmVzZW50XG4gKi9cblxuZGVmaW5lSlF1ZXJ5UGx1Z2luKFRhYilcblxuZXhwb3J0IGRlZmF1bHQgVGFiXG4iLCIvKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBCb290c3RyYXAgKHY1LjAuMik6IHRvYXN0LmpzXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuaW1wb3J0IHtcbiAgZGVmaW5lSlF1ZXJ5UGx1Z2luLFxuICByZWZsb3csXG4gIHR5cGVDaGVja0NvbmZpZ1xufSBmcm9tICcuL3V0aWwvaW5kZXgnXG5pbXBvcnQgRXZlbnRIYW5kbGVyIGZyb20gJy4vZG9tL2V2ZW50LWhhbmRsZXInXG5pbXBvcnQgTWFuaXB1bGF0b3IgZnJvbSAnLi9kb20vbWFuaXB1bGF0b3InXG5pbXBvcnQgQmFzZUNvbXBvbmVudCBmcm9tICcuL2Jhc2UtY29tcG9uZW50J1xuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29uc3RhbnRzXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5jb25zdCBOQU1FID0gJ3RvYXN0J1xuY29uc3QgREFUQV9LRVkgPSAnYnMudG9hc3QnXG5jb25zdCBFVkVOVF9LRVkgPSBgLiR7REFUQV9LRVl9YFxuXG5jb25zdCBFVkVOVF9DTElDS19ESVNNSVNTID0gYGNsaWNrLmRpc21pc3Mke0VWRU5UX0tFWX1gXG5jb25zdCBFVkVOVF9NT1VTRU9WRVIgPSBgbW91c2VvdmVyJHtFVkVOVF9LRVl9YFxuY29uc3QgRVZFTlRfTU9VU0VPVVQgPSBgbW91c2VvdXQke0VWRU5UX0tFWX1gXG5jb25zdCBFVkVOVF9GT0NVU0lOID0gYGZvY3VzaW4ke0VWRU5UX0tFWX1gXG5jb25zdCBFVkVOVF9GT0NVU09VVCA9IGBmb2N1c291dCR7RVZFTlRfS0VZfWBcbmNvbnN0IEVWRU5UX0hJREUgPSBgaGlkZSR7RVZFTlRfS0VZfWBcbmNvbnN0IEVWRU5UX0hJRERFTiA9IGBoaWRkZW4ke0VWRU5UX0tFWX1gXG5jb25zdCBFVkVOVF9TSE9XID0gYHNob3cke0VWRU5UX0tFWX1gXG5jb25zdCBFVkVOVF9TSE9XTiA9IGBzaG93biR7RVZFTlRfS0VZfWBcblxuY29uc3QgQ0xBU1NfTkFNRV9GQURFID0gJ2ZhZGUnXG5jb25zdCBDTEFTU19OQU1FX0hJREUgPSAnaGlkZSdcbmNvbnN0IENMQVNTX05BTUVfU0hPVyA9ICdzaG93J1xuY29uc3QgQ0xBU1NfTkFNRV9TSE9XSU5HID0gJ3Nob3dpbmcnXG5cbmNvbnN0IERlZmF1bHRUeXBlID0ge1xuICBhbmltYXRpb246ICdib29sZWFuJyxcbiAgYXV0b2hpZGU6ICdib29sZWFuJyxcbiAgZGVsYXk6ICdudW1iZXInXG59XG5cbmNvbnN0IERlZmF1bHQgPSB7XG4gIGFuaW1hdGlvbjogdHJ1ZSxcbiAgYXV0b2hpZGU6IHRydWUsXG4gIGRlbGF5OiA1MDAwXG59XG5cbmNvbnN0IFNFTEVDVE9SX0RBVEFfRElTTUlTUyA9ICdbZGF0YS1icy1kaXNtaXNzPVwidG9hc3RcIl0nXG5cbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDbGFzcyBEZWZpbml0aW9uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5jbGFzcyBUb2FzdCBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvcihlbGVtZW50LCBjb25maWcpIHtcbiAgICBzdXBlcihlbGVtZW50KVxuXG4gICAgdGhpcy5fY29uZmlnID0gdGhpcy5fZ2V0Q29uZmlnKGNvbmZpZylcbiAgICB0aGlzLl90aW1lb3V0ID0gbnVsbFxuICAgIHRoaXMuX2hhc01vdXNlSW50ZXJhY3Rpb24gPSBmYWxzZVxuICAgIHRoaXMuX2hhc0tleWJvYXJkSW50ZXJhY3Rpb24gPSBmYWxzZVxuICAgIHRoaXMuX3NldExpc3RlbmVycygpXG4gIH1cblxuICAvLyBHZXR0ZXJzXG5cbiAgc3RhdGljIGdldCBEZWZhdWx0VHlwZSgpIHtcbiAgICByZXR1cm4gRGVmYXVsdFR5cGVcbiAgfVxuXG4gIHN0YXRpYyBnZXQgRGVmYXVsdCgpIHtcbiAgICByZXR1cm4gRGVmYXVsdFxuICB9XG5cbiAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgIHJldHVybiBOQU1FXG4gIH1cblxuICAvLyBQdWJsaWNcblxuICBzaG93KCkge1xuICAgIGNvbnN0IHNob3dFdmVudCA9IEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX1NIT1cpXG5cbiAgICBpZiAoc2hvd0V2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMuX2NsZWFyVGltZW91dCgpXG5cbiAgICBpZiAodGhpcy5fY29uZmlnLmFuaW1hdGlvbikge1xuICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfRkFERSlcbiAgICB9XG5cbiAgICBjb25zdCBjb21wbGV0ZSA9ICgpID0+IHtcbiAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19OQU1FX1NIT1dJTkcpXG4gICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9TSE9XKVxuXG4gICAgICBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9TSE9XTilcblxuICAgICAgdGhpcy5fbWF5YmVTY2hlZHVsZUhpZGUoKVxuICAgIH1cblxuICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19OQU1FX0hJREUpXG4gICAgcmVmbG93KHRoaXMuX2VsZW1lbnQpXG4gICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfU0hPV0lORylcblxuICAgIHRoaXMuX3F1ZXVlQ2FsbGJhY2soY29tcGxldGUsIHRoaXMuX2VsZW1lbnQsIHRoaXMuX2NvbmZpZy5hbmltYXRpb24pXG4gIH1cblxuICBoaWRlKCkge1xuICAgIGlmICghdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9TSE9XKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3QgaGlkZUV2ZW50ID0gRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfSElERSlcblxuICAgIGlmIChoaWRlRXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3QgY29tcGxldGUgPSAoKSA9PiB7XG4gICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9ISURFKVxuICAgICAgRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfSElEREVOKVxuICAgIH1cblxuICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19OQU1FX1NIT1cpXG4gICAgdGhpcy5fcXVldWVDYWxsYmFjayhjb21wbGV0ZSwgdGhpcy5fZWxlbWVudCwgdGhpcy5fY29uZmlnLmFuaW1hdGlvbilcbiAgfVxuXG4gIGRpc3Bvc2UoKSB7XG4gICAgdGhpcy5fY2xlYXJUaW1lb3V0KClcblxuICAgIGlmICh0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX1NIT1cpKSB7XG4gICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9TSE9XKVxuICAgIH1cblxuICAgIHN1cGVyLmRpc3Bvc2UoKVxuICB9XG5cbiAgLy8gUHJpdmF0ZVxuXG4gIF9nZXRDb25maWcoY29uZmlnKSB7XG4gICAgY29uZmlnID0ge1xuICAgICAgLi4uRGVmYXVsdCxcbiAgICAgIC4uLk1hbmlwdWxhdG9yLmdldERhdGFBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpLFxuICAgICAgLi4uKHR5cGVvZiBjb25maWcgPT09ICdvYmplY3QnICYmIGNvbmZpZyA/IGNvbmZpZyA6IHt9KVxuICAgIH1cblxuICAgIHR5cGVDaGVja0NvbmZpZyhOQU1FLCBjb25maWcsIHRoaXMuY29uc3RydWN0b3IuRGVmYXVsdFR5cGUpXG5cbiAgICByZXR1cm4gY29uZmlnXG4gIH1cblxuICBfbWF5YmVTY2hlZHVsZUhpZGUoKSB7XG4gICAgaWYgKCF0aGlzLl9jb25maWcuYXV0b2hpZGUpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmICh0aGlzLl9oYXNNb3VzZUludGVyYWN0aW9uIHx8IHRoaXMuX2hhc0tleWJvYXJkSW50ZXJhY3Rpb24pIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMuX3RpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuaGlkZSgpXG4gICAgfSwgdGhpcy5fY29uZmlnLmRlbGF5KVxuICB9XG5cbiAgX29uSW50ZXJhY3Rpb24oZXZlbnQsIGlzSW50ZXJhY3RpbmcpIHtcbiAgICBzd2l0Y2ggKGV2ZW50LnR5cGUpIHtcbiAgICAgIGNhc2UgJ21vdXNlb3Zlcic6XG4gICAgICBjYXNlICdtb3VzZW91dCc6XG4gICAgICAgIHRoaXMuX2hhc01vdXNlSW50ZXJhY3Rpb24gPSBpc0ludGVyYWN0aW5nXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICdmb2N1c2luJzpcbiAgICAgIGNhc2UgJ2ZvY3Vzb3V0JzpcbiAgICAgICAgdGhpcy5faGFzS2V5Ym9hcmRJbnRlcmFjdGlvbiA9IGlzSW50ZXJhY3RpbmdcbiAgICAgICAgYnJlYWtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGJyZWFrXG4gICAgfVxuXG4gICAgaWYgKGlzSW50ZXJhY3RpbmcpIHtcbiAgICAgIHRoaXMuX2NsZWFyVGltZW91dCgpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCBuZXh0RWxlbWVudCA9IGV2ZW50LnJlbGF0ZWRUYXJnZXRcbiAgICBpZiAodGhpcy5fZWxlbWVudCA9PT0gbmV4dEVsZW1lbnQgfHwgdGhpcy5fZWxlbWVudC5jb250YWlucyhuZXh0RWxlbWVudCkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMuX21heWJlU2NoZWR1bGVIaWRlKClcbiAgfVxuXG4gIF9zZXRMaXN0ZW5lcnMoKSB7XG4gICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0NMSUNLX0RJU01JU1MsIFNFTEVDVE9SX0RBVEFfRElTTUlTUywgKCkgPT4gdGhpcy5oaWRlKCkpXG4gICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2VsZW1lbnQsIEVWRU5UX01PVVNFT1ZFUiwgZXZlbnQgPT4gdGhpcy5fb25JbnRlcmFjdGlvbihldmVudCwgdHJ1ZSkpXG4gICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2VsZW1lbnQsIEVWRU5UX01PVVNFT1VULCBldmVudCA9PiB0aGlzLl9vbkludGVyYWN0aW9uKGV2ZW50LCBmYWxzZSkpXG4gICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0ZPQ1VTSU4sIGV2ZW50ID0+IHRoaXMuX29uSW50ZXJhY3Rpb24oZXZlbnQsIHRydWUpKVxuICAgIEV2ZW50SGFuZGxlci5vbih0aGlzLl9lbGVtZW50LCBFVkVOVF9GT0NVU09VVCwgZXZlbnQgPT4gdGhpcy5fb25JbnRlcmFjdGlvbihldmVudCwgZmFsc2UpKVxuICB9XG5cbiAgX2NsZWFyVGltZW91dCgpIHtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5fdGltZW91dClcbiAgICB0aGlzLl90aW1lb3V0ID0gbnVsbFxuICB9XG5cbiAgLy8gU3RhdGljXG5cbiAgc3RhdGljIGpRdWVyeUludGVyZmFjZShjb25maWcpIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIGNvbnN0IGRhdGEgPSBUb2FzdC5nZXRPckNyZWF0ZUluc3RhbmNlKHRoaXMsIGNvbmZpZylcblxuICAgICAgaWYgKHR5cGVvZiBjb25maWcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YVtjb25maWddID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcIiR7Y29uZmlnfVwiYClcbiAgICAgICAgfVxuXG4gICAgICAgIGRhdGFbY29uZmlnXSh0aGlzKVxuICAgICAgfVxuICAgIH0pXG4gIH1cbn1cblxuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIGpRdWVyeVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBhZGQgLlRvYXN0IHRvIGpRdWVyeSBvbmx5IGlmIGpRdWVyeSBpcyBwcmVzZW50XG4gKi9cblxuZGVmaW5lSlF1ZXJ5UGx1Z2luKFRvYXN0KVxuXG5leHBvcnQgZGVmYXVsdCBUb2FzdFxuIiwiLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQm9vdHN0cmFwICh2NS4wLjIpOiBpbmRleC51bWQuanNcbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5pbXBvcnQgQWxlcnQgZnJvbSAnLi9zcmMvYWxlcnQnXG5pbXBvcnQgQnV0dG9uIGZyb20gJy4vc3JjL2J1dHRvbidcbmltcG9ydCBDYXJvdXNlbCBmcm9tICcuL3NyYy9jYXJvdXNlbCdcbmltcG9ydCBDb2xsYXBzZSBmcm9tICcuL3NyYy9jb2xsYXBzZSdcbmltcG9ydCBEcm9wZG93biBmcm9tICcuL3NyYy9kcm9wZG93bidcbmltcG9ydCBNb2RhbCBmcm9tICcuL3NyYy9tb2RhbCdcbmltcG9ydCBPZmZjYW52YXMgZnJvbSAnLi9zcmMvb2ZmY2FudmFzJ1xuaW1wb3J0IFBvcG92ZXIgZnJvbSAnLi9zcmMvcG9wb3ZlcidcbmltcG9ydCBTY3JvbGxTcHkgZnJvbSAnLi9zcmMvc2Nyb2xsc3B5J1xuaW1wb3J0IFRhYiBmcm9tICcuL3NyYy90YWInXG5pbXBvcnQgVG9hc3QgZnJvbSAnLi9zcmMvdG9hc3QnXG5pbXBvcnQgVG9vbHRpcCBmcm9tICcuL3NyYy90b29sdGlwJ1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIEFsZXJ0LFxuICBCdXR0b24sXG4gIENhcm91c2VsLFxuICBDb2xsYXBzZSxcbiAgRHJvcGRvd24sXG4gIE1vZGFsLFxuICBPZmZjYW52YXMsXG4gIFBvcG92ZXIsXG4gIFNjcm9sbFNweSxcbiAgVGFiLFxuICBUb2FzdCxcbiAgVG9vbHRpcFxufVxuIl0sIm5hbWVzIjpbIl9LRVlfVE9fRElSRUNUSU9OIiwiTk9ERV9URVhUIiwiU2VsZWN0b3JFbmdpbmUiLCJmaW5kIiwic2VsZWN0b3IiLCJfcmVmNSIsImVsZW1lbnQiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJ1bmRlZmluZWQiLCJkb2N1bWVudCIsImRvY3VtZW50RWxlbWVudCIsImNvbmNhdCIsImFwcGx5IiwiX3RvQ29uc3VtYWJsZUFycmF5IiwiRWxlbWVudCIsInByb3RvdHlwZSIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJjYWxsIiwiZmluZE9uZSIsInF1ZXJ5U2VsZWN0b3IiLCJjaGlsZHJlbiIsIl9yZWY2IiwiZmlsdGVyIiwiY2hpbGQiLCJtYXRjaGVzIiwicGFyZW50cyIsImFuY2VzdG9yIiwicGFyZW50Tm9kZSIsIm5vZGVUeXBlIiwiTm9kZSIsIkVMRU1FTlRfTk9ERSIsInB1c2giLCJwcmV2IiwicHJldmlvdXMiLCJwcmV2aW91c0VsZW1lbnRTaWJsaW5nIiwibmV4dCIsIm5leHRFbGVtZW50U2libGluZyIsIk1BWF9VSUQiLCJNSUxMSVNFQ09ORFNfTVVMVElQTElFUiIsIlRSQU5TSVRJT05fRU5EIiwidG9UeXBlIiwib2JqIiwidG9TdHJpbmciLCJtYXRjaCIsInRvTG93ZXJDYXNlIiwiZ2V0VUlEIiwicHJlZml4IiwiTWF0aCIsImZsb29yIiwicmFuZG9tIiwiZ2V0RWxlbWVudEJ5SWQiLCJnZXRTZWxlY3RvciIsImdldEF0dHJpYnV0ZSIsImhyZWZBdHRyIiwiaW5jbHVkZXMiLCJzdGFydHNXaXRoIiwic3BsaXQiLCJ0cmltIiwiZ2V0U2VsZWN0b3JGcm9tRWxlbWVudCIsImdldEVsZW1lbnRGcm9tU2VsZWN0b3IiLCJnZXRUcmFuc2l0aW9uRHVyYXRpb25Gcm9tRWxlbWVudCIsIl93aW5kb3ckZ2V0Q29tcHV0ZWRTdCIsIndpbmRvdyIsImdldENvbXB1dGVkU3R5bGUiLCJ0cmFuc2l0aW9uRHVyYXRpb24iLCJ0cmFuc2l0aW9uRGVsYXkiLCJmbG9hdFRyYW5zaXRpb25EdXJhdGlvbiIsIk51bWJlciIsInBhcnNlRmxvYXQiLCJmbG9hdFRyYW5zaXRpb25EZWxheSIsInRyaWdnZXJUcmFuc2l0aW9uRW5kIiwiZGlzcGF0Y2hFdmVudCIsIkV2ZW50IiwiaXNFbGVtZW50JDEiLCJpc0VsZW1lbnQiLCJfdHlwZW9mIiwianF1ZXJ5IiwiZ2V0RWxlbWVudCIsInR5cGVDaGVja0NvbmZpZyIsImNvbXBvbmVudE5hbWUiLCJjb25maWciLCJjb25maWdUeXBlcyIsIk9iamVjdCIsImtleXMiLCJmb3JFYWNoIiwicHJvcGVydHkiLCJleHBlY3RlZFR5cGVzIiwidmFsdWUiLCJ2YWx1ZVR5cGUiLCJSZWdFeHAiLCJ0ZXN0IiwiVHlwZUVycm9yIiwidG9VcHBlckNhc2UiLCJpc1Zpc2libGUiLCJnZXRDbGllbnRSZWN0cyIsImdldFByb3BlcnR5VmFsdWUiLCJpc0Rpc2FibGVkIiwiY2xhc3NMaXN0IiwiY29udGFpbnMiLCJkaXNhYmxlZCIsImhhc0F0dHJpYnV0ZSIsImZpbmRTaGFkb3dSb290IiwiYXR0YWNoU2hhZG93IiwiZ2V0Um9vdE5vZGUiLCJyb290IiwiU2hhZG93Um9vdCIsIm5vb3AiLCJyZWZsb3ciLCJvZmZzZXRIZWlnaHQiLCJnZXRqUXVlcnkiLCJfd2luZG93IiwialF1ZXJ5IiwiYm9keSIsIkRPTUNvbnRlbnRMb2FkZWRDYWxsYmFja3MiLCJvbkRPTUNvbnRlbnRMb2FkZWQiLCJjYWxsYmFjayIsInJlYWR5U3RhdGUiLCJhZGRFdmVudExpc3RlbmVyIiwiaXNSVEwiLCJkaXIiLCJkZWZpbmVKUXVlcnlQbHVnaW4iLCJwbHVnaW4iLCIkIiwibmFtZSIsIk5BTUUiLCJKUVVFUllfTk9fQ09ORkxJQ1QiLCJmbiIsImpRdWVyeUludGVyZmFjZSIsIkNvbnN0cnVjdG9yIiwibm9Db25mbGljdCIsImV4ZWN1dGUiLCJleGVjdXRlQWZ0ZXJUcmFuc2l0aW9uIiwidHJhbnNpdGlvbkVsZW1lbnQiLCJ3YWl0Rm9yVHJhbnNpdGlvbiIsImR1cmF0aW9uUGFkZGluZyIsImVtdWxhdGVkRHVyYXRpb24iLCJjYWxsZWQiLCJoYW5kbGVyIiwiX3JlZjciLCJ0YXJnZXQiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwic2V0VGltZW91dCIsImdldE5leHRBY3RpdmVFbGVtZW50IiwibGlzdCIsImFjdGl2ZUVsZW1lbnQiLCJzaG91bGRHZXROZXh0IiwiaXNDeWNsZUFsbG93ZWQiLCJpbmRleCIsImluZGV4T2YiLCJsaXN0TGVuZ3RoIiwibWF4IiwibWluIiwibmFtZXNwYWNlUmVnZXgiLCJzdHJpcE5hbWVSZWdleCIsInN0cmlwVWlkUmVnZXgiLCJldmVudFJlZ2lzdHJ5IiwidWlkRXZlbnQiLCJjdXN0b21FdmVudHMiLCJtb3VzZWVudGVyIiwibW91c2VsZWF2ZSIsImN1c3RvbUV2ZW50c1JlZ2V4IiwibmF0aXZlRXZlbnRzIiwiU2V0IiwiZ2V0VWlkRXZlbnQiLCJ1aWQiLCJnZXRFdmVudCIsImJvb3RzdHJhcEhhbmRsZXIiLCJldmVudCIsImRlbGVnYXRlVGFyZ2V0Iiwib25lT2ZmIiwiRXZlbnRIYW5kbGVyIiwib2ZmIiwidHlwZSIsImJvb3RzdHJhcERlbGVnYXRpb25IYW5kbGVyIiwiZG9tRWxlbWVudHMiLCJpIiwiZmluZEhhbmRsZXIiLCJldmVudHMiLCJkZWxlZ2F0aW9uU2VsZWN0b3IiLCJ1aWRFdmVudExpc3QiLCJsZW4iLCJvcmlnaW5hbEhhbmRsZXIiLCJub3JtYWxpemVQYXJhbXMiLCJvcmlnaW5hbFR5cGVFdmVudCIsImRlbGVnYXRpb25GbiIsImRlbGVnYXRpb24iLCJ0eXBlRXZlbnQiLCJnZXRUeXBlRXZlbnQiLCJpc05hdGl2ZSIsImhhcyIsImFkZEhhbmRsZXIiLCJ3cmFwRm4iLCJyZWxhdGVkVGFyZ2V0IiwiX25vcm1hbGl6ZVBhcmFtcyIsIl9ub3JtYWxpemVQYXJhbXMyIiwiX3NsaWNlZFRvQXJyYXkiLCJoYW5kbGVycyIsInByZXZpb3VzRm4iLCJyZXBsYWNlIiwicmVtb3ZlSGFuZGxlciIsIkJvb2xlYW4iLCJyZW1vdmVOYW1lc3BhY2VkSGFuZGxlcnMiLCJuYW1lc3BhY2UiLCJzdG9yZUVsZW1lbnRFdmVudCIsImhhbmRsZXJLZXkiLCJvbiIsIm9uZSIsIl9ub3JtYWxpemVQYXJhbXMzIiwiX25vcm1hbGl6ZVBhcmFtczQiLCJpbk5hbWVzcGFjZSIsImlzTmFtZXNwYWNlIiwiZWxlbWVudEV2ZW50Iiwic2xpY2UiLCJrZXlIYW5kbGVycyIsInRyaWdnZXIiLCJhcmdzIiwialF1ZXJ5RXZlbnQiLCJidWJibGVzIiwibmF0aXZlRGlzcGF0Y2giLCJkZWZhdWx0UHJldmVudGVkIiwiZXZ0IiwiaXNQcm9wYWdhdGlvblN0b3BwZWQiLCJpc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCIsImlzRGVmYXVsdFByZXZlbnRlZCIsImNyZWF0ZUV2ZW50IiwiaW5pdEV2ZW50IiwiQ3VzdG9tRXZlbnQiLCJjYW5jZWxhYmxlIiwia2V5IiwiZGVmaW5lUHJvcGVydHkiLCJnZXQiLCJwcmV2ZW50RGVmYXVsdCIsImVsZW1lbnRNYXAiLCJNYXAiLCJEYXRhIiwic2V0IiwiaW5zdGFuY2UiLCJpbnN0YW5jZU1hcCIsInNpemUiLCJjb25zb2xlIiwiZXJyb3IiLCJBcnJheSIsImZyb20iLCJyZW1vdmUiLCJWRVJTSU9OIiwiQmFzZUNvbXBvbmVudCIsIl9jbGFzc0NhbGxDaGVjayIsIl9lbGVtZW50IiwiY29uc3RydWN0b3IiLCJEQVRBX0tFWSIsIl9jcmVhdGVDbGFzcyIsImRpc3Bvc2UiLCJfdGhpcyIsIkVWRU5UX0tFWSIsImdldE93blByb3BlcnR5TmFtZXMiLCJwcm9wZXJ0eU5hbWUiLCJfcXVldWVDYWxsYmFjayIsImlzQW5pbWF0ZWQiLCJnZXRJbnN0YW5jZSIsImdldE9yQ3JlYXRlSW5zdGFuY2UiLCJFcnJvciIsIk5BTUUkYyIsIkRBVEFfS0VZJGIiLCJFVkVOVF9LRVkkYiIsIkRBVEFfQVBJX0tFWSQ4IiwiU0VMRUNUT1JfRElTTUlTUyIsIkVWRU5UX0NMT1NFIiwiRVZFTlRfQ0xPU0VEIiwiRVZFTlRfQ0xJQ0tfREFUQV9BUEkkNyIsIkNMQVNTX05BTUVfQUxFUlQiLCJDTEFTU19OQU1FX0ZBREUkNiIsIkNMQVNTX05BTUVfU0hPVyQ5IiwiQWxlcnQiLCJfQmFzZUNvbXBvbmVudCIsIl9pbmhlcml0cyIsIl9zdXBlciIsIl9jcmVhdGVTdXBlciIsImNsb3NlIiwicm9vdEVsZW1lbnQiLCJfZ2V0Um9vdEVsZW1lbnQiLCJjdXN0b21FdmVudCIsIl90cmlnZ2VyQ2xvc2VFdmVudCIsIl9yZW1vdmVFbGVtZW50IiwiY2xvc2VzdCIsIl90aGlzMiIsIl9kZXN0cm95RWxlbWVudCIsImVhY2giLCJkYXRhIiwiaGFuZGxlRGlzbWlzcyIsImFsZXJ0SW5zdGFuY2UiLCJOQU1FJGIiLCJEQVRBX0tFWSRhIiwiRVZFTlRfS0VZJGEiLCJEQVRBX0FQSV9LRVkkNyIsIkNMQVNTX05BTUVfQUNUSVZFJDMiLCJTRUxFQ1RPUl9EQVRBX1RPR0dMRSQ1IiwiRVZFTlRfQ0xJQ0tfREFUQV9BUEkkNiIsIkJ1dHRvbiIsIl9CYXNlQ29tcG9uZW50MiIsIl9zdXBlcjIiLCJ0b2dnbGUiLCJzZXRBdHRyaWJ1dGUiLCJidXR0b24iLCJub3JtYWxpemVEYXRhIiwidmFsIiwibm9ybWFsaXplRGF0YUtleSIsImNociIsIk1hbmlwdWxhdG9yIiwic2V0RGF0YUF0dHJpYnV0ZSIsInJlbW92ZURhdGFBdHRyaWJ1dGUiLCJyZW1vdmVBdHRyaWJ1dGUiLCJnZXREYXRhQXR0cmlidXRlcyIsImF0dHJpYnV0ZXMiLCJkYXRhc2V0IiwicHVyZUtleSIsImNoYXJBdCIsImdldERhdGFBdHRyaWJ1dGUiLCJvZmZzZXQiLCJyZWN0IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwidG9wIiwic2Nyb2xsVG9wIiwibGVmdCIsInNjcm9sbExlZnQiLCJwb3NpdGlvbiIsIm9mZnNldFRvcCIsIm9mZnNldExlZnQiLCJOQU1FJGEiLCJEQVRBX0tFWSQ5IiwiRVZFTlRfS0VZJDkiLCJEQVRBX0FQSV9LRVkkNiIsIkFSUk9XX0xFRlRfS0VZIiwiQVJST1dfUklHSFRfS0VZIiwiVE9VQ0hFVkVOVF9DT01QQVRfV0FJVCIsIlNXSVBFX1RIUkVTSE9MRCIsIkRlZmF1bHQkOSIsImludGVydmFsIiwia2V5Ym9hcmQiLCJzbGlkZSIsInBhdXNlIiwid3JhcCIsInRvdWNoIiwiRGVmYXVsdFR5cGUkOSIsIk9SREVSX05FWFQiLCJPUkRFUl9QUkVWIiwiRElSRUNUSU9OX0xFRlQiLCJESVJFQ1RJT05fUklHSFQiLCJLRVlfVE9fRElSRUNUSU9OIiwiX2RlZmluZVByb3BlcnR5IiwiRVZFTlRfU0xJREUiLCJFVkVOVF9TTElEIiwiRVZFTlRfS0VZRE9XTiIsIkVWRU5UX01PVVNFRU5URVIiLCJFVkVOVF9NT1VTRUxFQVZFIiwiRVZFTlRfVE9VQ0hTVEFSVCIsIkVWRU5UX1RPVUNITU9WRSIsIkVWRU5UX1RPVUNIRU5EIiwiRVZFTlRfUE9JTlRFUkRPV04iLCJFVkVOVF9QT0lOVEVSVVAiLCJFVkVOVF9EUkFHX1NUQVJUIiwiRVZFTlRfTE9BRF9EQVRBX0FQSSQyIiwiRVZFTlRfQ0xJQ0tfREFUQV9BUEkkNSIsIkNMQVNTX05BTUVfQ0FST1VTRUwiLCJDTEFTU19OQU1FX0FDVElWRSQyIiwiQ0xBU1NfTkFNRV9TTElERSIsIkNMQVNTX05BTUVfRU5EIiwiQ0xBU1NfTkFNRV9TVEFSVCIsIkNMQVNTX05BTUVfTkVYVCIsIkNMQVNTX05BTUVfUFJFViIsIkNMQVNTX05BTUVfUE9JTlRFUl9FVkVOVCIsIlNFTEVDVE9SX0FDVElWRSQxIiwiU0VMRUNUT1JfQUNUSVZFX0lURU0iLCJTRUxFQ1RPUl9JVEVNIiwiU0VMRUNUT1JfSVRFTV9JTUciLCJTRUxFQ1RPUl9ORVhUX1BSRVYiLCJTRUxFQ1RPUl9JTkRJQ0FUT1JTIiwiU0VMRUNUT1JfSU5ESUNBVE9SIiwiU0VMRUNUT1JfREFUQV9TTElERSIsIlNFTEVDVE9SX0RBVEFfUklERSIsIlBPSU5URVJfVFlQRV9UT1VDSCIsIlBPSU5URVJfVFlQRV9QRU4iLCJDYXJvdXNlbCIsIl9CYXNlQ29tcG9uZW50MyIsIl9zdXBlcjMiLCJfdGhpczMiLCJfaXRlbXMiLCJfaW50ZXJ2YWwiLCJfYWN0aXZlRWxlbWVudCIsIl9pc1BhdXNlZCIsIl9pc1NsaWRpbmciLCJ0b3VjaFRpbWVvdXQiLCJ0b3VjaFN0YXJ0WCIsInRvdWNoRGVsdGFYIiwiX2NvbmZpZyIsIl9nZXRDb25maWciLCJfaW5kaWNhdG9yc0VsZW1lbnQiLCJfdG91Y2hTdXBwb3J0ZWQiLCJuYXZpZ2F0b3IiLCJtYXhUb3VjaFBvaW50cyIsIl9wb2ludGVyRXZlbnQiLCJQb2ludGVyRXZlbnQiLCJfYWRkRXZlbnRMaXN0ZW5lcnMiLCJfc2xpZGUiLCJuZXh0V2hlblZpc2libGUiLCJoaWRkZW4iLCJjeWNsZSIsImNsZWFySW50ZXJ2YWwiLCJfdXBkYXRlSW50ZXJ2YWwiLCJzZXRJbnRlcnZhbCIsInZpc2liaWxpdHlTdGF0ZSIsImJpbmQiLCJ0byIsIl90aGlzNCIsImFjdGl2ZUluZGV4IiwiX2dldEl0ZW1JbmRleCIsIm9yZGVyIiwiX29iamVjdFNwcmVhZCIsIl9oYW5kbGVTd2lwZSIsImFic0RlbHRheCIsImFicyIsImRpcmVjdGlvbiIsIl90aGlzNSIsIl9rZXlkb3duIiwiX2FkZFRvdWNoRXZlbnRMaXN0ZW5lcnMiLCJfdGhpczYiLCJzdGFydCIsInBvaW50ZXJUeXBlIiwiY2xpZW50WCIsInRvdWNoZXMiLCJtb3ZlIiwiZW5kIiwiY2xlYXJUaW1lb3V0IiwiaXRlbUltZyIsImUiLCJhZGQiLCJ0YWdOYW1lIiwiX2dldEl0ZW1CeU9yZGVyIiwiaXNOZXh0IiwiX3RyaWdnZXJTbGlkZUV2ZW50IiwiZXZlbnREaXJlY3Rpb25OYW1lIiwidGFyZ2V0SW5kZXgiLCJmcm9tSW5kZXgiLCJfc2V0QWN0aXZlSW5kaWNhdG9yRWxlbWVudCIsImFjdGl2ZUluZGljYXRvciIsImluZGljYXRvcnMiLCJwYXJzZUludCIsImVsZW1lbnRJbnRlcnZhbCIsImRlZmF1bHRJbnRlcnZhbCIsImRpcmVjdGlvbk9yT3JkZXIiLCJfdGhpczciLCJfZGlyZWN0aW9uVG9PcmRlciIsImFjdGl2ZUVsZW1lbnRJbmRleCIsIm5leHRFbGVtZW50IiwibmV4dEVsZW1lbnRJbmRleCIsImlzQ3ljbGluZyIsImRpcmVjdGlvbmFsQ2xhc3NOYW1lIiwib3JkZXJDbGFzc05hbWUiLCJfb3JkZXJUb0RpcmVjdGlvbiIsInNsaWRlRXZlbnQiLCJ0cmlnZ2VyU2xpZEV2ZW50IiwiY29tcGxldGVDYWxsQmFjayIsImNhcm91c2VsSW50ZXJmYWNlIiwiYWN0aW9uIiwicmlkZSIsImRhdGFBcGlDbGlja0hhbmRsZXIiLCJzbGlkZUluZGV4IiwiY2Fyb3VzZWxzIiwiTkFNRSQ5IiwiREFUQV9LRVkkOCIsIkVWRU5UX0tFWSQ4IiwiREFUQV9BUElfS0VZJDUiLCJEZWZhdWx0JDgiLCJwYXJlbnQiLCJEZWZhdWx0VHlwZSQ4IiwiRVZFTlRfU0hPVyQ1IiwiRVZFTlRfU0hPV04kNSIsIkVWRU5UX0hJREUkNSIsIkVWRU5UX0hJRERFTiQ1IiwiRVZFTlRfQ0xJQ0tfREFUQV9BUEkkNCIsIkNMQVNTX05BTUVfU0hPVyQ4IiwiQ0xBU1NfTkFNRV9DT0xMQVBTRSIsIkNMQVNTX05BTUVfQ09MTEFQU0lORyIsIkNMQVNTX05BTUVfQ09MTEFQU0VEIiwiV0lEVEgiLCJIRUlHSFQiLCJTRUxFQ1RPUl9BQ1RJVkVTIiwiU0VMRUNUT1JfREFUQV9UT0dHTEUkNCIsIkNvbGxhcHNlIiwiX0Jhc2VDb21wb25lbnQ0IiwiX3N1cGVyNCIsIl90aGlzOCIsIl9pc1RyYW5zaXRpb25pbmciLCJfdHJpZ2dlckFycmF5IiwiaWQiLCJ0b2dnbGVMaXN0IiwiZWxlbSIsImZpbHRlckVsZW1lbnQiLCJmb3VuZEVsZW0iLCJfc2VsZWN0b3IiLCJfcGFyZW50IiwiX2dldFBhcmVudCIsIl9hZGRBcmlhQW5kQ29sbGFwc2VkQ2xhc3MiLCJoaWRlIiwic2hvdyIsIl90aGlzOSIsImFjdGl2ZXMiLCJhY3RpdmVzRGF0YSIsImNvbnRhaW5lciIsInRlbXBBY3RpdmVEYXRhIiwic3RhcnRFdmVudCIsImVsZW1BY3RpdmUiLCJjb2xsYXBzZUludGVyZmFjZSIsImRpbWVuc2lvbiIsIl9nZXREaW1lbnNpb24iLCJzdHlsZSIsInNldFRyYW5zaXRpb25pbmciLCJjb21wbGV0ZSIsImNhcGl0YWxpemVkRGltZW5zaW9uIiwic2Nyb2xsU2l6ZSIsIl90aGlzMTAiLCJ0cmlnZ2VyQXJyYXlMZW5ndGgiLCJpc1RyYW5zaXRpb25pbmciLCJfdGhpczExIiwic2VsZWN0ZWQiLCJ0cmlnZ2VyQXJyYXkiLCJpc09wZW4iLCJ0cmlnZ2VyRGF0YSIsInNlbGVjdG9yRWxlbWVudHMiLCJib3R0b20iLCJyaWdodCIsImF1dG8iLCJiYXNlUGxhY2VtZW50cyIsImNsaXBwaW5nUGFyZW50cyIsInZpZXdwb3J0IiwicG9wcGVyIiwicmVmZXJlbmNlIiwidmFyaWF0aW9uUGxhY2VtZW50cyIsInJlZHVjZSIsImFjYyIsInBsYWNlbWVudCIsInBsYWNlbWVudHMiLCJiZWZvcmVSZWFkIiwicmVhZCIsImFmdGVyUmVhZCIsImJlZm9yZU1haW4iLCJtYWluIiwiYWZ0ZXJNYWluIiwiYmVmb3JlV3JpdGUiLCJ3cml0ZSIsImFmdGVyV3JpdGUiLCJtb2RpZmllclBoYXNlcyIsImdldE5vZGVOYW1lIiwibm9kZU5hbWUiLCJnZXRXaW5kb3ciLCJub2RlIiwib3duZXJEb2N1bWVudCIsImRlZmF1bHRWaWV3IiwiT3duRWxlbWVudCIsImlzSFRNTEVsZW1lbnQiLCJIVE1MRWxlbWVudCIsImlzU2hhZG93Um9vdCIsImFwcGx5U3R5bGVzIiwiX3JlZiIsInN0YXRlIiwiZWxlbWVudHMiLCJzdHlsZXMiLCJhc3NpZ24iLCJlZmZlY3QkMiIsImVmZmVjdCIsIl9yZWYyIiwiaW5pdGlhbFN0eWxlcyIsIm9wdGlvbnMiLCJzdHJhdGVneSIsIm1hcmdpbiIsImFycm93Iiwic3R5bGVQcm9wZXJ0aWVzIiwiaGFzT3duUHJvcGVydHkiLCJhdHRyaWJ1dGUiLCJhcHBseVN0eWxlcyQxIiwiZW5hYmxlZCIsInBoYXNlIiwicmVxdWlyZXMiLCJnZXRCYXNlUGxhY2VtZW50Iiwid2lkdGgiLCJoZWlnaHQiLCJ4IiwieSIsImdldExheW91dFJlY3QiLCJjbGllbnRSZWN0Iiwib2Zmc2V0V2lkdGgiLCJyb290Tm9kZSIsImlzU2FtZU5vZGUiLCJob3N0IiwiZ2V0Q29tcHV0ZWRTdHlsZSQxIiwiaXNUYWJsZUVsZW1lbnQiLCJnZXREb2N1bWVudEVsZW1lbnQiLCJnZXRQYXJlbnROb2RlIiwiYXNzaWduZWRTbG90IiwiZ2V0VHJ1ZU9mZnNldFBhcmVudCIsIm9mZnNldFBhcmVudCIsImdldENvbnRhaW5pbmdCbG9jayIsImlzRmlyZWZveCIsInVzZXJBZ2VudCIsImlzSUUiLCJlbGVtZW50Q3NzIiwiY3VycmVudE5vZGUiLCJjc3MiLCJ0cmFuc2Zvcm0iLCJwZXJzcGVjdGl2ZSIsImNvbnRhaW4iLCJ3aWxsQ2hhbmdlIiwiZ2V0T2Zmc2V0UGFyZW50IiwiZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50Iiwicm91bmQiLCJ3aXRoaW4iLCJtaW4kMSIsIm1heCQxIiwiZ2V0RnJlc2hTaWRlT2JqZWN0IiwibWVyZ2VQYWRkaW5nT2JqZWN0IiwicGFkZGluZ09iamVjdCIsImV4cGFuZFRvSGFzaE1hcCIsImhhc2hNYXAiLCJ0b1BhZGRpbmdPYmplY3QiLCJwYWRkaW5nIiwicmVjdHMiLCJfc3RhdGUkbW9kaWZpZXJzRGF0YSQiLCJhcnJvd0VsZW1lbnQiLCJwb3BwZXJPZmZzZXRzIiwibW9kaWZpZXJzRGF0YSIsImJhc2VQbGFjZW1lbnQiLCJheGlzIiwiaXNWZXJ0aWNhbCIsImFycm93UmVjdCIsIm1pblByb3AiLCJtYXhQcm9wIiwiZW5kRGlmZiIsInN0YXJ0RGlmZiIsImFycm93T2Zmc2V0UGFyZW50IiwiY2xpZW50U2l6ZSIsImNsaWVudEhlaWdodCIsImNsaWVudFdpZHRoIiwiY2VudGVyVG9SZWZlcmVuY2UiLCJjZW50ZXIiLCJheGlzUHJvcCIsImNlbnRlck9mZnNldCIsImVmZmVjdCQxIiwiX29wdGlvbnMkZWxlbWVudCIsImFycm93JDEiLCJyZXF1aXJlc0lmRXhpc3RzIiwidW5zZXRTaWRlcyIsInJvdW5kT2Zmc2V0c0J5RFBSIiwid2luIiwiZHByIiwiZGV2aWNlUGl4ZWxSYXRpbyIsIm1hcFRvU3R5bGVzIiwiX09iamVjdCRhc3NpZ24yIiwicG9wcGVyUmVjdCIsIm9mZnNldHMiLCJncHVBY2NlbGVyYXRpb24iLCJhZGFwdGl2ZSIsInJvdW5kT2Zmc2V0cyIsIl9yZWYzIiwiX3JlZjMkeCIsIl9yZWYzJHkiLCJoYXNYIiwiaGFzWSIsInNpZGVYIiwic2lkZVkiLCJoZWlnaHRQcm9wIiwid2lkdGhQcm9wIiwiY29tbW9uU3R5bGVzIiwiX09iamVjdCRhc3NpZ24iLCJjb21wdXRlU3R5bGVzIiwiX3JlZjQiLCJfb3B0aW9ucyRncHVBY2NlbGVyYXQiLCJfb3B0aW9ucyRhZGFwdGl2ZSIsIl9vcHRpb25zJHJvdW5kT2Zmc2V0cyIsImNvbXB1dGVTdHlsZXMkMSIsInBhc3NpdmUiLCJfb3B0aW9ucyRzY3JvbGwiLCJzY3JvbGwiLCJfb3B0aW9ucyRyZXNpemUiLCJyZXNpemUiLCJzY3JvbGxQYXJlbnRzIiwic2Nyb2xsUGFyZW50IiwidXBkYXRlIiwiZXZlbnRMaXN0ZW5lcnMiLCJoYXNoJDEiLCJnZXRPcHBvc2l0ZVBsYWNlbWVudCIsIm1hdGNoZWQiLCJoYXNoIiwiZ2V0T3Bwb3NpdGVWYXJpYXRpb25QbGFjZW1lbnQiLCJnZXRXaW5kb3dTY3JvbGwiLCJwYWdlWE9mZnNldCIsInBhZ2VZT2Zmc2V0IiwiZ2V0V2luZG93U2Nyb2xsQmFyWCIsImdldFZpZXdwb3J0UmVjdCIsImh0bWwiLCJ2aXN1YWxWaWV3cG9ydCIsImdldERvY3VtZW50UmVjdCIsIl9lbGVtZW50JG93bmVyRG9jdW1lbiIsIndpblNjcm9sbCIsInNjcm9sbFdpZHRoIiwic2Nyb2xsSGVpZ2h0IiwiaXNTY3JvbGxQYXJlbnQiLCJfZ2V0Q29tcHV0ZWRTdHlsZSIsIm92ZXJmbG93Iiwib3ZlcmZsb3dYIiwib3ZlcmZsb3dZIiwiZ2V0U2Nyb2xsUGFyZW50IiwibGlzdFNjcm9sbFBhcmVudHMiLCJpc0JvZHkiLCJ1cGRhdGVkTGlzdCIsInJlY3RUb0NsaWVudFJlY3QiLCJnZXRJbm5lckJvdW5kaW5nQ2xpZW50UmVjdCIsImNsaWVudFRvcCIsImNsaWVudExlZnQiLCJnZXRDbGllbnRSZWN0RnJvbU1peGVkVHlwZSIsImNsaXBwaW5nUGFyZW50IiwiZ2V0Q2xpcHBpbmdQYXJlbnRzIiwiY2FuRXNjYXBlQ2xpcHBpbmciLCJjbGlwcGVyRWxlbWVudCIsImdldENsaXBwaW5nUmVjdCIsImJvdW5kYXJ5Iiwicm9vdEJvdW5kYXJ5IiwibWFpbkNsaXBwaW5nUGFyZW50cyIsImZpcnN0Q2xpcHBpbmdQYXJlbnQiLCJjbGlwcGluZ1JlY3QiLCJhY2NSZWN0IiwiZ2V0VmFyaWF0aW9uIiwiY29tcHV0ZU9mZnNldHMiLCJ2YXJpYXRpb24iLCJjb21tb25YIiwiY29tbW9uWSIsIm1haW5BeGlzIiwiZGV0ZWN0T3ZlcmZsb3ciLCJfb3B0aW9ucyIsIl9vcHRpb25zJHBsYWNlbWVudCIsIl9vcHRpb25zJGJvdW5kYXJ5IiwiX29wdGlvbnMkcm9vdEJvdW5kYXJ5IiwiX29wdGlvbnMkZWxlbWVudENvbnRlIiwiZWxlbWVudENvbnRleHQiLCJfb3B0aW9ucyRhbHRCb3VuZGFyeSIsImFsdEJvdW5kYXJ5IiwiX29wdGlvbnMkcGFkZGluZyIsImFsdENvbnRleHQiLCJyZWZlcmVuY2VFbGVtZW50IiwiY2xpcHBpbmdDbGllbnRSZWN0IiwiY29udGV4dEVsZW1lbnQiLCJyZWZlcmVuY2VDbGllbnRSZWN0IiwicG9wcGVyQ2xpZW50UmVjdCIsImVsZW1lbnRDbGllbnRSZWN0Iiwib3ZlcmZsb3dPZmZzZXRzIiwib2Zmc2V0RGF0YSIsIm11bHRpcGx5IiwiY29tcHV0ZUF1dG9QbGFjZW1lbnQiLCJmbGlwVmFyaWF0aW9ucyIsIl9vcHRpb25zJGFsbG93ZWRBdXRvUCIsImFsbG93ZWRBdXRvUGxhY2VtZW50cyIsInBsYWNlbWVudHMkMSIsImFsbG93ZWRQbGFjZW1lbnRzIiwib3ZlcmZsb3dzIiwic29ydCIsImEiLCJiIiwiZ2V0RXhwYW5kZWRGYWxsYmFja1BsYWNlbWVudHMiLCJvcHBvc2l0ZVBsYWNlbWVudCIsImZsaXAiLCJfc2tpcCIsIl9vcHRpb25zJG1haW5BeGlzIiwiY2hlY2tNYWluQXhpcyIsIl9vcHRpb25zJGFsdEF4aXMiLCJhbHRBeGlzIiwiY2hlY2tBbHRBeGlzIiwic3BlY2lmaWVkRmFsbGJhY2tQbGFjZW1lbnRzIiwiZmFsbGJhY2tQbGFjZW1lbnRzIiwiX29wdGlvbnMkZmxpcFZhcmlhdGlvIiwicHJlZmVycmVkUGxhY2VtZW50IiwiaXNCYXNlUGxhY2VtZW50IiwicmVmZXJlbmNlUmVjdCIsImNoZWNrc01hcCIsIm1ha2VGYWxsYmFja0NoZWNrcyIsImZpcnN0Rml0dGluZ1BsYWNlbWVudCIsIl9iYXNlUGxhY2VtZW50IiwiaXNTdGFydFZhcmlhdGlvbiIsIm1haW5WYXJpYXRpb25TaWRlIiwiYWx0VmFyaWF0aW9uU2lkZSIsImNoZWNrcyIsImV2ZXJ5IiwiY2hlY2siLCJudW1iZXJPZkNoZWNrcyIsIl9sb29wIiwiX2kiLCJmaXR0aW5nUGxhY2VtZW50IiwiX3JldCIsInJlc2V0IiwiZmxpcCQxIiwiZ2V0U2lkZU9mZnNldHMiLCJwcmV2ZW50ZWRPZmZzZXRzIiwiaXNBbnlTaWRlRnVsbHlDbGlwcGVkIiwic29tZSIsInNpZGUiLCJwcmV2ZW50T3ZlcmZsb3ciLCJyZWZlcmVuY2VPdmVyZmxvdyIsInBvcHBlckFsdE92ZXJmbG93IiwicmVmZXJlbmNlQ2xpcHBpbmdPZmZzZXRzIiwicG9wcGVyRXNjYXBlT2Zmc2V0cyIsImlzUmVmZXJlbmNlSGlkZGVuIiwiaGFzUG9wcGVyRXNjYXBlZCIsImhpZGUkMSIsImRpc3RhbmNlQW5kU2tpZGRpbmdUb1hZIiwiaW52ZXJ0RGlzdGFuY2UiLCJza2lkZGluZyIsImRpc3RhbmNlIiwiX29wdGlvbnMkb2Zmc2V0IiwiX2RhdGEkc3RhdGUkcGxhY2VtZW50Iiwib2Zmc2V0JDEiLCJwb3BwZXJPZmZzZXRzJDEiLCJnZXRBbHRBeGlzIiwiX29wdGlvbnMkdGV0aGVyIiwidGV0aGVyIiwiX29wdGlvbnMkdGV0aGVyT2Zmc2V0IiwidGV0aGVyT2Zmc2V0IiwidGV0aGVyT2Zmc2V0VmFsdWUiLCJtYWluU2lkZSIsImFsdFNpZGUiLCJhZGRpdGl2ZSIsIm1pbkxlbiIsIm1heExlbiIsImFycm93UGFkZGluZ09iamVjdCIsImFycm93UGFkZGluZ01pbiIsImFycm93UGFkZGluZ01heCIsImFycm93TGVuIiwibWluT2Zmc2V0IiwibWF4T2Zmc2V0IiwiY2xpZW50T2Zmc2V0Iiwib2Zmc2V0TW9kaWZpZXJWYWx1ZSIsInRldGhlck1pbiIsInRldGhlck1heCIsInByZXZlbnRlZE9mZnNldCIsIl9tYWluU2lkZSIsIl9hbHRTaWRlIiwiX29mZnNldCIsIl9taW4iLCJfbWF4IiwiX3ByZXZlbnRlZE9mZnNldCIsInByZXZlbnRPdmVyZmxvdyQxIiwiZ2V0SFRNTEVsZW1lbnRTY3JvbGwiLCJnZXROb2RlU2Nyb2xsIiwiZ2V0Q29tcG9zaXRlUmVjdCIsImVsZW1lbnRPclZpcnR1YWxFbGVtZW50IiwiaXNGaXhlZCIsImlzT2Zmc2V0UGFyZW50QW5FbGVtZW50IiwibW9kaWZpZXJzIiwibWFwIiwidmlzaXRlZCIsInJlc3VsdCIsIm1vZGlmaWVyIiwiZGVwIiwiZGVwTW9kaWZpZXIiLCJvcmRlck1vZGlmaWVycyIsIm9yZGVyZWRNb2RpZmllcnMiLCJkZWJvdW5jZSIsInBlbmRpbmciLCJQcm9taXNlIiwicmVzb2x2ZSIsInRoZW4iLCJtZXJnZUJ5TmFtZSIsIm1lcmdlZCIsImN1cnJlbnQiLCJleGlzdGluZyIsIkRFRkFVTFRfT1BUSU9OUyIsImFyZVZhbGlkRWxlbWVudHMiLCJfbGVuIiwiX2tleSIsInBvcHBlckdlbmVyYXRvciIsImdlbmVyYXRvck9wdGlvbnMiLCJfZ2VuZXJhdG9yT3B0aW9ucyIsIl9nZW5lcmF0b3JPcHRpb25zJGRlZiIsImRlZmF1bHRNb2RpZmllcnMiLCJfZ2VuZXJhdG9yT3B0aW9ucyRkZWYyIiwiZGVmYXVsdE9wdGlvbnMiLCJjcmVhdGVQb3BwZXIiLCJlZmZlY3RDbGVhbnVwRm5zIiwiaXNEZXN0cm95ZWQiLCJzZXRPcHRpb25zIiwiY2xlYW51cE1vZGlmaWVyRWZmZWN0cyIsIm0iLCJydW5Nb2RpZmllckVmZmVjdHMiLCJmb3JjZVVwZGF0ZSIsIl9zdGF0ZSRlbGVtZW50cyIsIl9zdGF0ZSRvcmRlcmVkTW9kaWZpZSIsIl9zdGF0ZSRvcmRlcmVkTW9kaWZpZTIiLCJkZXN0cm95Iiwib25GaXJzdFVwZGF0ZSIsIl9yZWYzJG9wdGlvbnMiLCJjbGVhbnVwRm4iLCJub29wRm4iLCJjcmVhdGVQb3BwZXIkMiIsImRlZmF1bHRNb2RpZmllcnMkMSIsImNyZWF0ZVBvcHBlciQxIiwiTkFNRSQ4IiwiREFUQV9LRVkkNyIsIkVWRU5UX0tFWSQ3IiwiREFUQV9BUElfS0VZJDQiLCJFU0NBUEVfS0VZJDIiLCJTUEFDRV9LRVkiLCJUQUJfS0VZIiwiQVJST1dfVVBfS0VZIiwiQVJST1dfRE9XTl9LRVkiLCJSSUdIVF9NT1VTRV9CVVRUT04iLCJSRUdFWFBfS0VZRE9XTiIsIkVWRU5UX0hJREUkNCIsIkVWRU5UX0hJRERFTiQ0IiwiRVZFTlRfU0hPVyQ0IiwiRVZFTlRfU0hPV04kNCIsIkVWRU5UX0NMSUNLIiwiRVZFTlRfQ0xJQ0tfREFUQV9BUEkkMyIsIkVWRU5UX0tFWURPV05fREFUQV9BUEkiLCJFVkVOVF9LRVlVUF9EQVRBX0FQSSIsIkNMQVNTX05BTUVfU0hPVyQ3IiwiQ0xBU1NfTkFNRV9EUk9QVVAiLCJDTEFTU19OQU1FX0RST1BFTkQiLCJDTEFTU19OQU1FX0RST1BTVEFSVCIsIkNMQVNTX05BTUVfTkFWQkFSIiwiU0VMRUNUT1JfREFUQV9UT0dHTEUkMyIsIlNFTEVDVE9SX01FTlUiLCJTRUxFQ1RPUl9OQVZCQVJfTkFWIiwiU0VMRUNUT1JfVklTSUJMRV9JVEVNUyIsIlBMQUNFTUVOVF9UT1AiLCJQTEFDRU1FTlRfVE9QRU5EIiwiUExBQ0VNRU5UX0JPVFRPTSIsIlBMQUNFTUVOVF9CT1RUT01FTkQiLCJQTEFDRU1FTlRfUklHSFQiLCJQTEFDRU1FTlRfTEVGVCIsIkRlZmF1bHQkNyIsImRpc3BsYXkiLCJwb3BwZXJDb25maWciLCJhdXRvQ2xvc2UiLCJEZWZhdWx0VHlwZSQ3IiwiRHJvcGRvd24iLCJfQmFzZUNvbXBvbmVudDUiLCJfc3VwZXI1IiwiX3RoaXMxMiIsIl9wb3BwZXIiLCJfbWVudSIsIl9nZXRNZW51RWxlbWVudCIsIl9pbk5hdmJhciIsIl9kZXRlY3ROYXZiYXIiLCJpc0FjdGl2ZSIsImdldFBhcmVudEZyb21FbGVtZW50Iiwic2hvd0V2ZW50IiwiUG9wcGVyIiwiX2dldFBvcHBlckNvbmZpZyIsImlzRGlzcGxheVN0YXRpYyIsIl9yZWY4IiwiZm9jdXMiLCJfY29tcGxldGVIaWRlIiwiX2dldCIsIl9nZXRQcm90b3R5cGVPZiIsIl90aGlzMTMiLCJoaWRlRXZlbnQiLCJfcmVmOSIsIkRlZmF1bHQiLCJEZWZhdWx0VHlwZSIsIl9nZXRQbGFjZW1lbnQiLCJwYXJlbnREcm9wZG93biIsImlzRW5kIiwiX2dldE9mZnNldCIsIl90aGlzMTQiLCJwb3BwZXJEYXRhIiwiZGVmYXVsdEJzUG9wcGVyQ29uZmlnIiwiX3NlbGVjdE1lbnVJdGVtIiwiX3JlZjEwIiwiaXRlbXMiLCJkcm9wZG93bkludGVyZmFjZSIsImNsZWFyTWVudXMiLCJ0b2dnbGVzIiwiY29udGV4dCIsImNvbXBvc2VkUGF0aCIsImlzTWVudVRhcmdldCIsImNsaWNrRXZlbnQiLCJkYXRhQXBpS2V5ZG93bkhhbmRsZXIiLCJfdGhpczE1Iiwic3RvcFByb3BhZ2F0aW9uIiwiZ2V0VG9nZ2xlQnV0dG9uIiwiY2xpY2siLCJTRUxFQ1RPUl9GSVhFRF9DT05URU5UIiwiU0VMRUNUT1JfU1RJQ0tZX0NPTlRFTlQiLCJTY3JvbGxCYXJIZWxwZXIiLCJnZXRXaWR0aCIsImRvY3VtZW50V2lkdGgiLCJpbm5lcldpZHRoIiwiX2Rpc2FibGVPdmVyRmxvdyIsIl9zZXRFbGVtZW50QXR0cmlidXRlcyIsImNhbGN1bGF0ZWRWYWx1ZSIsIl9zYXZlSW5pdGlhbEF0dHJpYnV0ZSIsInN0eWxlUHJvcCIsIl90aGlzMTYiLCJzY3JvbGxiYXJXaWR0aCIsIm1hbmlwdWxhdGlvbkNhbGxCYWNrIiwiX2FwcGx5TWFuaXB1bGF0aW9uQ2FsbGJhY2siLCJfcmVzZXRFbGVtZW50QXR0cmlidXRlcyIsImFjdHVhbFZhbHVlIiwicmVtb3ZlUHJvcGVydHkiLCJjYWxsQmFjayIsImlzT3ZlcmZsb3dpbmciLCJEZWZhdWx0JDYiLCJjbGlja0NhbGxiYWNrIiwiRGVmYXVsdFR5cGUkNiIsIk5BTUUkNyIsIkNMQVNTX05BTUVfQkFDS0RST1AiLCJDTEFTU19OQU1FX0ZBREUkNSIsIkNMQVNTX05BTUVfU0hPVyQ2IiwiRVZFTlRfTU9VU0VET1dOIiwiQmFja2Ryb3AiLCJfaXNBcHBlbmRlZCIsIl9hcHBlbmQiLCJfZ2V0RWxlbWVudCIsIl9lbXVsYXRlQW5pbWF0aW9uIiwiX3RoaXMxNyIsImJhY2tkcm9wIiwiY3JlYXRlRWxlbWVudCIsImNsYXNzTmFtZSIsIl90aGlzMTgiLCJhcHBlbmRDaGlsZCIsIk5BTUUkNiIsIkRBVEFfS0VZJDYiLCJFVkVOVF9LRVkkNiIsIkRBVEFfQVBJX0tFWSQzIiwiRVNDQVBFX0tFWSQxIiwiRGVmYXVsdCQ1IiwiRGVmYXVsdFR5cGUkNSIsIkVWRU5UX0hJREUkMyIsIkVWRU5UX0hJREVfUFJFVkVOVEVEIiwiRVZFTlRfSElEREVOJDMiLCJFVkVOVF9TSE9XJDMiLCJFVkVOVF9TSE9XTiQzIiwiRVZFTlRfRk9DVVNJTiQyIiwiRVZFTlRfUkVTSVpFIiwiRVZFTlRfQ0xJQ0tfRElTTUlTUyQyIiwiRVZFTlRfS0VZRE9XTl9ESVNNSVNTJDEiLCJFVkVOVF9NT1VTRVVQX0RJU01JU1MiLCJFVkVOVF9NT1VTRURPV05fRElTTUlTUyIsIkVWRU5UX0NMSUNLX0RBVEFfQVBJJDIiLCJDTEFTU19OQU1FX09QRU4iLCJDTEFTU19OQU1FX0ZBREUkNCIsIkNMQVNTX05BTUVfU0hPVyQ1IiwiQ0xBU1NfTkFNRV9TVEFUSUMiLCJTRUxFQ1RPUl9ESUFMT0ciLCJTRUxFQ1RPUl9NT0RBTF9CT0RZIiwiU0VMRUNUT1JfREFUQV9UT0dHTEUkMiIsIlNFTEVDVE9SX0RBVEFfRElTTUlTUyQyIiwiTW9kYWwiLCJfQmFzZUNvbXBvbmVudDYiLCJfc3VwZXI2IiwiX3RoaXMxOSIsIl9kaWFsb2ciLCJfYmFja2Ryb3AiLCJfaW5pdGlhbGl6ZUJhY2tEcm9wIiwiX2lzU2hvd24iLCJfaWdub3JlQmFja2Ryb3BDbGljayIsIl9zY3JvbGxCYXIiLCJfdGhpczIwIiwiX2lzQW5pbWF0ZWQiLCJfYWRqdXN0RGlhbG9nIiwiX3NldEVzY2FwZUV2ZW50IiwiX3NldFJlc2l6ZUV2ZW50IiwiX3Nob3dCYWNrZHJvcCIsIl9zaG93RWxlbWVudCIsIl90aGlzMjEiLCJfaGlkZU1vZGFsIiwiaHRtbEVsZW1lbnQiLCJoYW5kbGVVcGRhdGUiLCJfdGhpczIyIiwibW9kYWxCb2R5IiwiX2VuZm9yY2VGb2N1cyIsInRyYW5zaXRpb25Db21wbGV0ZSIsIl90aGlzMjMiLCJfdGhpczI0IiwiX3RyaWdnZXJCYWNrZHJvcFRyYW5zaXRpb24iLCJfdGhpczI1IiwiX3RoaXMyNiIsIl9yZXNldEFkanVzdG1lbnRzIiwiX3RoaXMyNyIsImN1cnJlbnRUYXJnZXQiLCJfdGhpczI4IiwiX3RoaXMkX2VsZW1lbnQiLCJpc01vZGFsT3ZlcmZsb3dpbmciLCJpc0JvZHlPdmVyZmxvd2luZyIsInBhZGRpbmdMZWZ0IiwicGFkZGluZ1JpZ2h0IiwiX3RoaXMyOSIsIk5BTUUkNSIsIkRBVEFfS0VZJDUiLCJFVkVOVF9LRVkkNSIsIkRBVEFfQVBJX0tFWSQyIiwiRVZFTlRfTE9BRF9EQVRBX0FQSSQxIiwiRVNDQVBFX0tFWSIsIkRlZmF1bHQkNCIsIkRlZmF1bHRUeXBlJDQiLCJDTEFTU19OQU1FX1NIT1ckNCIsIk9QRU5fU0VMRUNUT1IiLCJFVkVOVF9TSE9XJDIiLCJFVkVOVF9TSE9XTiQyIiwiRVZFTlRfSElERSQyIiwiRVZFTlRfSElEREVOJDIiLCJFVkVOVF9GT0NVU0lOJDEiLCJFVkVOVF9DTElDS19EQVRBX0FQSSQxIiwiRVZFTlRfQ0xJQ0tfRElTTUlTUyQxIiwiRVZFTlRfS0VZRE9XTl9ESVNNSVNTIiwiU0VMRUNUT1JfREFUQV9ESVNNSVNTJDEiLCJTRUxFQ1RPUl9EQVRBX1RPR0dMRSQxIiwiT2ZmY2FudmFzIiwiX0Jhc2VDb21wb25lbnQ3IiwiX3N1cGVyNyIsIl90aGlzMzAiLCJfdGhpczMxIiwidmlzaWJpbGl0eSIsIl9lbmZvcmNlRm9jdXNPbkVsZW1lbnQiLCJfdGhpczMyIiwiYmx1ciIsImNvbXBsZXRlQ2FsbGJhY2siLCJfdGhpczMzIiwiX3RoaXMzNCIsIl90aGlzMzUiLCJhbGxSZWFkeU9wZW4iLCJlbCIsInVyaUF0dHJzIiwiQVJJQV9BVFRSSUJVVEVfUEFUVEVSTiIsIlNBRkVfVVJMX1BBVFRFUk4iLCJEQVRBX1VSTF9QQVRURVJOIiwiYWxsb3dlZEF0dHJpYnV0ZSIsImF0dHIiLCJhbGxvd2VkQXR0cmlidXRlTGlzdCIsImF0dHJOYW1lIiwibm9kZVZhbHVlIiwicmVnRXhwIiwiYXR0clJlZ2V4IiwiRGVmYXVsdEFsbG93bGlzdCIsImFyZWEiLCJiciIsImNvbCIsImNvZGUiLCJkaXYiLCJlbSIsImhyIiwiaDEiLCJoMiIsImgzIiwiaDQiLCJoNSIsImg2IiwiaW1nIiwibGkiLCJvbCIsInAiLCJwcmUiLCJzIiwic21hbGwiLCJzcGFuIiwic3ViIiwic3VwIiwic3Ryb25nIiwidSIsInVsIiwic2FuaXRpemVIdG1sIiwidW5zYWZlSHRtbCIsImFsbG93TGlzdCIsInNhbml0aXplRm4iLCJfcmVmMTEiLCJkb21QYXJzZXIiLCJET01QYXJzZXIiLCJjcmVhdGVkRG9jdW1lbnQiLCJwYXJzZUZyb21TdHJpbmciLCJhbGxvd2xpc3RLZXlzIiwiX2xvb3AyIiwiX3JlZjEyIiwiZWxOYW1lIiwiYXR0cmlidXRlTGlzdCIsImFsbG93ZWRBdHRyaWJ1dGVzIiwiaW5uZXJIVE1MIiwiTkFNRSQ0IiwiREFUQV9LRVkkNCIsIkVWRU5UX0tFWSQ0IiwiQ0xBU1NfUFJFRklYJDEiLCJCU0NMU19QUkVGSVhfUkVHRVgkMSIsIkRJU0FMTE9XRURfQVRUUklCVVRFUyIsIkRlZmF1bHRUeXBlJDMiLCJhbmltYXRpb24iLCJ0ZW1wbGF0ZSIsInRpdGxlIiwiZGVsYXkiLCJjdXN0b21DbGFzcyIsInNhbml0aXplIiwiQXR0YWNobWVudE1hcCIsIkFVVE8iLCJUT1AiLCJSSUdIVCIsIkJPVFRPTSIsIkxFRlQiLCJEZWZhdWx0JDMiLCJFdmVudCQyIiwiSElERSIsIkhJRERFTiIsIlNIT1ciLCJTSE9XTiIsIklOU0VSVEVEIiwiQ0xJQ0siLCJGT0NVU0lOIiwiRk9DVVNPVVQiLCJNT1VTRUVOVEVSIiwiTU9VU0VMRUFWRSIsIkNMQVNTX05BTUVfRkFERSQzIiwiQ0xBU1NfTkFNRV9NT0RBTCIsIkNMQVNTX05BTUVfU0hPVyQzIiwiSE9WRVJfU1RBVEVfU0hPVyIsIkhPVkVSX1NUQVRFX09VVCIsIlNFTEVDVE9SX1RPT0xUSVBfSU5ORVIiLCJUUklHR0VSX0hPVkVSIiwiVFJJR0dFUl9GT0NVUyIsIlRSSUdHRVJfQ0xJQ0siLCJUUklHR0VSX01BTlVBTCIsIlRvb2x0aXAiLCJfQmFzZUNvbXBvbmVudDgiLCJfc3VwZXI4IiwiX3RoaXMzNiIsIl9pc0VuYWJsZWQiLCJfdGltZW91dCIsIl9ob3ZlclN0YXRlIiwiX2FjdGl2ZVRyaWdnZXIiLCJ0aXAiLCJfc2V0TGlzdGVuZXJzIiwiZW5hYmxlIiwiZGlzYWJsZSIsInRvZ2dsZUVuYWJsZWQiLCJfaW5pdGlhbGl6ZU9uRGVsZWdhdGVkVGFyZ2V0IiwiX2lzV2l0aEFjdGl2ZVRyaWdnZXIiLCJfZW50ZXIiLCJfbGVhdmUiLCJnZXRUaXBFbGVtZW50IiwiX2hpZGVNb2RhbEhhbmRsZXIiLCJfdGhpczM3IiwiaXNXaXRoQ29udGVudCIsInNoYWRvd1Jvb3QiLCJpc0luVGhlRG9tIiwidGlwSWQiLCJzZXRDb250ZW50IiwiYXR0YWNobWVudCIsIl9nZXRBdHRhY2htZW50IiwiX2FkZEF0dGFjaG1lbnRDbGFzcyIsIl90aXAkY2xhc3NMaXN0IiwiX3JlZjEzIiwicHJldkhvdmVyU3RhdGUiLCJfdGhpczM4IiwiX2NsZWFuVGlwQ2xhc3MiLCJfcmVmMTQiLCJnZXRUaXRsZSIsInNldEVsZW1lbnRDb250ZW50IiwiY29udGVudCIsInRleHRDb250ZW50IiwidXBkYXRlQXR0YWNobWVudCIsImRhdGFLZXkiLCJfZ2V0RGVsZWdhdGVDb25maWciLCJfdGhpczM5IiwiX3RoaXM0MCIsIl9oYW5kbGVQb3BwZXJQbGFjZW1lbnRDaGFuZ2UiLCJfdGhpczQxIiwidHJpZ2dlcnMiLCJldmVudEluIiwiZXZlbnRPdXQiLCJfZml4VGl0bGUiLCJvcmlnaW5hbFRpdGxlVHlwZSIsImRhdGFBdHRyaWJ1dGVzIiwiZGF0YUF0dHIiLCJ0YWJDbGFzcyIsInRva2VuIiwidENsYXNzIiwiTkFNRSQzIiwiREFUQV9LRVkkMyIsIkVWRU5UX0tFWSQzIiwiQ0xBU1NfUFJFRklYIiwiQlNDTFNfUFJFRklYX1JFR0VYIiwiRGVmYXVsdCQyIiwiRGVmYXVsdFR5cGUkMiIsIkV2ZW50JDEiLCJDTEFTU19OQU1FX0ZBREUkMiIsIkNMQVNTX05BTUVfU0hPVyQyIiwiU0VMRUNUT1JfVElUTEUiLCJTRUxFQ1RPUl9DT05URU5UIiwiUG9wb3ZlciIsIl9Ub29sdGlwIiwiX3N1cGVyOSIsIl9nZXRDb250ZW50IiwiTkFNRSQyIiwiREFUQV9LRVkkMiIsIkVWRU5UX0tFWSQyIiwiREFUQV9BUElfS0VZJDEiLCJEZWZhdWx0JDEiLCJtZXRob2QiLCJEZWZhdWx0VHlwZSQxIiwiRVZFTlRfQUNUSVZBVEUiLCJFVkVOVF9TQ1JPTEwiLCJFVkVOVF9MT0FEX0RBVEFfQVBJIiwiQ0xBU1NfTkFNRV9EUk9QRE9XTl9JVEVNIiwiQ0xBU1NfTkFNRV9BQ1RJVkUkMSIsIlNFTEVDVE9SX0RBVEFfU1BZIiwiU0VMRUNUT1JfTkFWX0xJU1RfR1JPVVAkMSIsIlNFTEVDVE9SX05BVl9MSU5LUyIsIlNFTEVDVE9SX05BVl9JVEVNUyIsIlNFTEVDVE9SX0xJU1RfSVRFTVMiLCJTRUxFQ1RPUl9EUk9QRE9XTiQxIiwiU0VMRUNUT1JfRFJPUERPV05fVE9HR0xFJDEiLCJNRVRIT0RfT0ZGU0VUIiwiTUVUSE9EX1BPU0lUSU9OIiwiU2Nyb2xsU3B5IiwiX0Jhc2VDb21wb25lbnQ5IiwiX3N1cGVyMTAiLCJfdGhpczQyIiwiX3Njcm9sbEVsZW1lbnQiLCJfb2Zmc2V0cyIsIl90YXJnZXRzIiwiX2FjdGl2ZVRhcmdldCIsIl9zY3JvbGxIZWlnaHQiLCJfcHJvY2VzcyIsInJlZnJlc2giLCJfdGhpczQzIiwiYXV0b01ldGhvZCIsIm9mZnNldE1ldGhvZCIsIm9mZnNldEJhc2UiLCJfZ2V0U2Nyb2xsVG9wIiwiX2dldFNjcm9sbEhlaWdodCIsInRhcmdldHMiLCJ0YXJnZXRTZWxlY3RvciIsInRhcmdldEJDUiIsIml0ZW0iLCJfZ2V0T2Zmc2V0SGVpZ2h0IiwiaW5uZXJIZWlnaHQiLCJtYXhTY3JvbGwiLCJfYWN0aXZhdGUiLCJfY2xlYXIiLCJpc0FjdGl2ZVRhcmdldCIsInF1ZXJpZXMiLCJsaW5rIiwiam9pbiIsImxpc3RHcm91cCIsIm5hdkl0ZW0iLCJzcHkiLCJOQU1FJDEiLCJEQVRBX0tFWSQxIiwiRVZFTlRfS0VZJDEiLCJEQVRBX0FQSV9LRVkiLCJFVkVOVF9ISURFJDEiLCJFVkVOVF9ISURERU4kMSIsIkVWRU5UX1NIT1ckMSIsIkVWRU5UX1NIT1dOJDEiLCJFVkVOVF9DTElDS19EQVRBX0FQSSIsIkNMQVNTX05BTUVfRFJPUERPV05fTUVOVSIsIkNMQVNTX05BTUVfQUNUSVZFIiwiQ0xBU1NfTkFNRV9GQURFJDEiLCJDTEFTU19OQU1FX1NIT1ckMSIsIlNFTEVDVE9SX0RST1BET1dOIiwiU0VMRUNUT1JfTkFWX0xJU1RfR1JPVVAiLCJTRUxFQ1RPUl9BQ1RJVkUiLCJTRUxFQ1RPUl9BQ1RJVkVfVUwiLCJTRUxFQ1RPUl9EQVRBX1RPR0dMRSIsIlNFTEVDVE9SX0RST1BET1dOX1RPR0dMRSIsIlNFTEVDVE9SX0RST1BET1dOX0FDVElWRV9DSElMRCIsIlRhYiIsIl9CYXNlQ29tcG9uZW50MTAiLCJfc3VwZXIxMSIsIl90aGlzNDQiLCJsaXN0RWxlbWVudCIsIml0ZW1TZWxlY3RvciIsIl90aGlzNDUiLCJhY3RpdmVFbGVtZW50cyIsImFjdGl2ZSIsIl90cmFuc2l0aW9uQ29tcGxldGUiLCJkcm9wZG93bkNoaWxkIiwiZHJvcGRvd25FbGVtZW50IiwiZHJvcGRvd24iLCJFVkVOVF9DTElDS19ESVNNSVNTIiwiRVZFTlRfTU9VU0VPVkVSIiwiRVZFTlRfTU9VU0VPVVQiLCJFVkVOVF9GT0NVU0lOIiwiRVZFTlRfRk9DVVNPVVQiLCJFVkVOVF9ISURFIiwiRVZFTlRfSElEREVOIiwiRVZFTlRfU0hPVyIsIkVWRU5UX1NIT1dOIiwiQ0xBU1NfTkFNRV9GQURFIiwiQ0xBU1NfTkFNRV9ISURFIiwiQ0xBU1NfTkFNRV9TSE9XIiwiQ0xBU1NfTkFNRV9TSE9XSU5HIiwiYXV0b2hpZGUiLCJTRUxFQ1RPUl9EQVRBX0RJU01JU1MiLCJUb2FzdCIsIl9CYXNlQ29tcG9uZW50MTEiLCJfc3VwZXIxMiIsIl90aGlzNDYiLCJfaGFzTW91c2VJbnRlcmFjdGlvbiIsIl9oYXNLZXlib2FyZEludGVyYWN0aW9uIiwiX3RoaXM0NyIsIl9jbGVhclRpbWVvdXQiLCJfbWF5YmVTY2hlZHVsZUhpZGUiLCJfdGhpczQ4IiwiX3RoaXM0OSIsIl9vbkludGVyYWN0aW9uIiwiaXNJbnRlcmFjdGluZyIsIl90aGlzNTAiLCJpbmRleF91bWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/assets/js/bootstrap.bundle.js\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./src/assets/js/bootstrap.bundle.js");
/******/ 	
/******/ })()
;